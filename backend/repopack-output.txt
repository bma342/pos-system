================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-09-04T16:42:24.557Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.github/
  workflows/
    security.yml
config/
  config.json
  database.js
migrations/
  helpers/
    migrationHelpers.js
  .eslintrc.js
  01_create_all_tables.js
  20240818161348-add-location-menu-override.js
  20240818161349-add-location-tax-config.js
  20240818161350-add-loyalty-challenge.js
  20240818161351-add-loyalty-config.js
  20240818161352-add-loyalty-integration.js
  20240828024349-update-role-and-template-associations.js
scripts/
  create-client.js
  docker-compose.yml
seeders/
  .eslintrc.js
  02-create-clients.js
  03-create-roles.js
  04-create-super-admin.js
  05-create-demo-enterprise.js
  20230101000000-demo-data.js
src/
  adapters/
    pos/
      RevelPOSAdapter.js
      ToastPOSAdapter.js
  config/
    config.json
    database.js
    redis.js
  controllers/
    abTestController.js
    abTestController.ts
    abTestResultController.js
    adminController.js
    analyticsController.js
    analyticsController.ts
    assetController.js
    auditLogController.js
    authController.js
    brandingController.js
    brandingProfileController.js
    campaignResultController.js
    campaignStepController.js
    categoryController.js
    cateringAdminController.js
    cateringController.js
    cateringMenuController.js
    cateringMenuItemController.js
    cateringOrderAssignmentsController.js
    cateringOrderController.js
    cateringOrderCustomizationController.js
    cateringOrderFeesController.js
    cateringOrderItemController.js
    cateringOrderLocationController.js
    cateringOrderModifierController.js
    cateringSettingsController.js
    checkoutController.js
    clientBrandingController.js
    clientController.js
    clientLocationsController.js
    clientPreferencesController.js
    clientProfileController.js
    clientSettingsController.js
    commissaryKitchenController.js
    commissaryLocationController.js
    corePosProfileController.js
    coreposProfilesController.js
    dashboardController.js
    dataWallController.js
    deliveryDriverController.js
    discountController.js
    discountItemController.js
    discountsController.js
    driverLocationsController.js
    dropoffScheduleController.js
    dropOffSpotController.js
    featureManagementController.js
    globalMenuController.js
    globalSettingController.js
    guestController.js
    guestDiscountsController.js
    guestLoyaltyProgramController.js
    guestProfileController.js
    guestRewardsController.js
    houseAccountController.js
    houseAccountLocationsController.js
    houseAccountUserController.js
    inventoryController.js
    invoiceController.js
    itemModifierController.js
    itemReviewController.js
    locationCard.js
    locationController.js
    locationController.ts
    locationMenuGroupController.js
    locationPosProfileController.js
    locationService.js
    locationTaxConfigController.js
    loyaltyChallengeController.js
    loyaltyController.js
    loyaltyWalletController.js
    marketingController.js
    menuController.js
    menuItemController.js
    menuService.js
    notificationController.js
    orderController.js
    orderHistoryController.js
    orderProviderController.js
    paymentController.js
    permissionController.js
    posAlertController.js
    posController.js
    PosController.js
    posIntegrationController.js
    posIntegrationErrorLogController.js
    posIntegrationMappingController.js
    posIntegrationSettingsController.js
    posProfileController.js
    posSettingsController.js
    posSyncController.js
    posSyncService.js
    providerController.js
    qrCodeController.js
    refundController.js
    reportController.js
    reviewController.js
    rewardController.js
    roleController.js
    roleTemplateAssignmentsController.js
    roleTemplateController.js
    serviceFeeController.js
    superAdminController.js
    tabletController.js
    taxController.js
    tipController.js
    trackingPixelController.js
    translatorController.js
    twoFactorController.js
    userController.js
    walletController.js
  cron/
    subscriptionCron.js
  middleware/
    auditLogger.js
    auth.js
    authorize.js
    brandingValidationMiddleware.js
    cache.js
    errorHandler.js
    logger.js
    permissionsMiddleware.js
    pixelMiddleware.js
    posProfileMiddleware.js
    rateLimiter.js
    sanitizeMiddleware.js
    security.js
    subdomainMiddleware.js
    subdomainRouter.js
    validate.js
  migrations/
    01_create_all_tables.js
    20240818161348-add-location-menu-override.js
    20240818161349-add-location-tax-config.js
    20240818161350-add-loyalty-challenge.js
    20240818161351-add-loyalty-config.js
    20240818161352-add-loyalty-integration.js
    20240821000100-add-cooldown-fields.js
    20240821000100-seed-sample-loyalty-and-discounts.js
    20240828024349-update-role-and-template-associations.js
    20240829024230-create-campaign.js
    YYYYMMDDHHMMSS-add-default-prep-time-to-locations.js
    YYYYMMDDHHMMSS-add-doordash-marketplace-fields.js
    YYYYMMDDHHMMSS-add-inventory-settings-to-locations.js
    YYYYMMDDHHMMSS-add-prep-time-and-inventory-offset-to-menu-items.js
    YYYYMMDDHHMMSS-add-scheduled-order-fields.js
    YYYYMMDDHHMMSS-create-client-branding.js
    YYYYMMDDHHMMSS-create-client-features.js
    YYYYMMDDHHMMSS-create-location-profile.js
    YYYYMMDDHHMMSS-create-location.js
    YYYYMMDDHHMMSS-create-order-provider.js
    YYYYMMDDHHMMSS-create-review.js
    YYYYMMDDHHMMSS-create-scheduled-order.js
    YYYYMMDDHHMMSS-create-user.js
    YYYYMMDDHHMMSS-update-pos-settings.js
  models/
    ABTest.js
    ABTestMetric.js
    ABTestResult.js
    ABTestVariant.js
    Analytics.js
    Asset.js
    AuditLog.js
    BaseModel.js
    Branding.js
    BrandingProfile.js
    Campaign.js
    CampaignResult.js
    CampaignStep.js
    Catering.js
    CateringAdmin.js
    CateringMenu.js
    CateringMenuItem.js
    CateringOrder.js
    CateringOrderAssignments.js
    CateringOrderCustomization.js
    CateringOrderFees.js
    CateringOrderItem.js
    CateringOrderLocation.js
    CateringOrderModifier.js
    CateringSettings.js
    Challenge.js
    checkModelExports.js
    checkModels.js
    Client.js
    ClientBranding.js
    ClientFeatures.js
    ClientPreferences.js
    ClientProfile.js
    ClientSettings.js
    CommissaryKitchen.js
    CommissaryLocation.js
    CorePOSProfile.js
    DataWall.js
    DeliveryDriver.js
    Discount.js
    DiscountItem.js
    DriverLocations.js
    DropOffSchedule.js
    DropOffSpot.js
    FeatureManagement.js
    GlobalMenu.js
    GlobalSetting.js
    Guest.js
    GuestDiscounts.js
    GuestLoyaltyProgram.js
    GuestProfile.js
    GuestRewards.js
    HouseAccount.js
    HouseAccountLocations.js
    HouseAccountUser.js
    index.js
    Inventory.js
    Invoice.js
    Item.js
    ItemModifier.js
    ItemReview.js
    Location.js
    LocationHours.js
    LocationMenu.js
    LocationMenuGroup.js
    LocationMenuOverride.js
    LocationPOSProfile.js
    LocationProfile.js
    LocationTaxConfig.js
    Logger.js
    Logger.js.save
    Loyalty.js
    LoyaltyAnalytics.js
    LoyaltyChallenge.js
    LoyaltyChallengeProgress.js
    LoyaltyChallengeRewards.js
    LoyaltyConfig.js
    LoyaltyIntegration.js
    LoyaltyProgram.js
    LoyaltyReward.js
    LoyaltySubscription.js
    LoyaltyTier.js
    LoyaltyTransaction.js
    MarketingCampaign.js
    MarketingPerformance.js
    MarketingReport.js
    Menu.js
    MenuAnalytics.js
    MenuBuilderSettings.js
    MenuGroup.js
    MenuItem.js
    MenuItemAnalytics.js
    MenuItemModifier.js
    MenuItemSizeModifier.js
    MenuSyncHistory.js
    MiniSite.js
    MiniSiteAnalytics.js
    ModelName.js
    Modifier.js
    Order.js
    OrderHistory.js
    OrderItem.js
    OrderProvider.js
    PaymentProfile.js
    Permission.js
    PosIntegration.js
    PosIntegrationErrorLog.js
    PosIntegrationMapping.js
    PosIntegrationSettings.js
    PosProfile.js
    PosProfileConfig.js
    PosSettings.js
    PricingOverride.js
    PricingUplift.js
    Product.js
    Provider.js
    ProviderIntegration.js
    ProviderPricing.js
    ProviderProfile.js
    Refund.js
    Report.js
    Review.js
    Reward.js
    RewardSchedule.js
    Role.js
    RolePermission.js
    RolePermissions.js
    RoleTemplate.js
    RoleTemplateAssignments.js
    SalesAnalytics.js
    SalesReport.js
    ScheduledOrder.js
    ServiceFee.js
    SizeModifier.js
    Staff.js
    StaffRole.js
    StaffSchedule.js
    Subscription.js
    SubscriptionPlan.js
    Tag.js
    Tax.js
    TaxRate.js
    Tenant.js
    TimeSlot.js
    Tip.js
    TipConfiguration.js
    TrackingPixel.js
    Transaction.js
    User.js
    UserRole.js
    Wallet.js
    WalletDrop.js
  posConnector/
    posConfigs.js
    posConnector.js
    posConnectorService.js
    posProfiles.js
  routes/
    abTestResultRoutes.js
    abTestRoutes.js
    adminRoutes.js
    analytics.js
    analyticsRoutes.js
    assetRoutes.js
    auth.js
    authRoutes.js
    brandingProfileRoutes.js
    brandingRoutes.js
    campaignResultRoutes.js
    campaignStepRoutes.js
    categoryRoutes.js
    cateringAdminRoutes.js
    cateringMenuItemRoutes.js
    cateringMenuRoutes.js
    cateringOrderAssignmentsRoutes.js
    cateringOrderCustomizationRoutes.js
    cateringOrderFeesRoutes.js
    cateringOrderItemRoutes.js
    cateringOrderLocationRoutes.js
    cateringOrderModifierRoutes.js
    cateringOrderRoutes.js
    cateringRoutes.js
    cateringSettingsRoutes.js
    checkoutRoutes.js
    clientLocationsRoutes.js
    clientRoutes.js
    clientSettingsRoutes.js
    commissaryKitchenRoutes.js
    commissaryLocationRoutes.js
    corePosProfileRoutes.js
    dashboardRoutes.js
    dataWallRoutes.js
    deliveryDriverRoutes.js
    discountItemRoutes.js
    discountRoutes.js
    discountsRoutes.js
    driverLocationsRoutes.js
    dropoffScheduleRoutes.js
    featureManagementRoutes.js
    globalMenuRoutes.js
    globalSettingRoutes.js
    guestDiscountsRoutes.js
    guestLoyaltyProgramRoutes.js
    guestProfileRoutes.js
    guestRewardsRoutes.js
    guestRoutes.js
    health.js
    houseAccountLocationsRoutes.js
    houseAccountRoutes.js
    houseAccountUserRoutes.js
    imageUploadRoutes.js
    index.js
    inventoryRoutes.js
    invoiceRoutes.js
    itemModifierRoutes.js
    itemReviewRoutes.js
    itemRoutes.js
    LocationCard.js
    locationHoursRoutes.js
    locationMenuGroupRoutes.js
    locationMenuOverrideRoutes.js
    locationPosProfileRoutes.js
    locationRoutes.js
    locations.js
    LocationSelectionPage.js
    locationTaxConfigRoutes.js
    loyaltyRoutes.js
    loyaltyWalletRoutes.js
    menuGroupRoutes.js
    menuItemRoutes.js
    menuRoutes.js
    modifierRoutes.js
    orderHistoryRoutes.js
    orderRoutes.js
    orders.js
    paymentRoutes.js
    posIntegrationMappingRoutes.js
    posIntegrationRoutes.js
    posIntegrationSettingsRoutes.js
    posRoutes.js
    posSyncRoutes.js
    pricingUtils.js
    providerIntegrationRoutes.js
    ProviderPricing.js
    providerPricingRoutes.js
    providerRoutes.js
    refundRoutes.js
    reportRoutes.js
    reviewRoutes.js
    rewardRoutes.js
    roleRoutes.js
    roleTemplateAssignmentsRoutes.js
    secureRoutes.js
    serviceFeeRoutes.js
    tabletRoutes.js
    tailwind.css
    taxRoutes.js
    throttleSettingsRoutes.js
    tipRoutes.js
    toastRoutes.js
    trackingPixelRoutes.js
    translatorRoutes.js
    twoFactorRoutes.js
    userRoutes.js
    walletRoutes.js
  seeders/
    enterpriseClientSeeder.js
    YYYYMMDDHHMMSS-seed-enterprise-client.js
  services/
    integrations/
      basePosService.js
      brinkService.js
      revelService.js
      squareService.js
      toastService.js
    abTestMetricsService.js
    abTestService.js
    adminService.js
    analyticsService.js
    analyticsService.Js
    auditLogService.js
    authService.js
    brandingService.js
    campaignResultService.js
    cartService.js
    categoryService.js
    cateringOrderService.js
    cateringService.js
    checkoutService.js
    clientBrandingService.js
    clientService.js
    commissaryKitchenService.js
    corePosProfileService.js
    currencyService.js
    dashboardService.js
    deliveryDriverService.js
    discountService.js
    DiscountService.js
    featureManagementService.js
    GlobalSettingsService.js
    guestService.js
    houseAccountService.js
    imageService.js
    integrationService.js
    inventoryService.js
    inventorySyncService.js
    invoiceService.js
    InvoiceService.js
    locationService.js
    logger.js
    loyaltyService.js
    menuItemService.js
    menuService.js
    menuSyncEnhancements.js
    notificationService.js
    orderPrepService.js
    orderProviderService.js
    orderService.js
    orderThrottleService.js
    paymentService.js
    permissionService.js
    posAlertService.js
    posIntegrationService.js
    posProfileService.js
    posService.js
    posSettingsService.js
    posSyncService.js
    pricingUtils.js
    providerIntegrationService.js
    providerService.js
    reportingService.js
    reportService.js
    reviewService.js
    roleService.js
    s3Service.js
    scheduledOrderService.js
    schedulingService.js
    serviceFeeService.js
    subscriptionService.js
    syncEngine.js
    syncService.js
    tabletService.js
    taxService.js
    toastService.js
    trackingPixelService.js
    translatorService.js
    twoFactorService.js
    userService.js
    walletDropService.js
    walletService.js
  ssl/
    server.cert
  tests/
    location.test.js
  translator/
    providerConfigs.js
    translatorService.js
  types/
    dto/
      user.js
    enums.js
  utils/
    cache.js
    dateUtils.js
    discountUtils.js
    emojiUtils.js
    errorHandler.js
    errors.js
    exportUtils.js
    invoiceUtils.js
    locationUtils.js
    logger.js
    loyaltyUtils.js
    menuSyncScheduler.js
    notificationService.js
    orderProviderIntegration.js
    orderScheduler.js
    pricingUtils.js
    readyTimeUtils.js
    scheduledOrderCron.js
    timezoneUtils.js
    translationEngine.js
  validators/
    clientValidator.js
  .env
  app.js
  cronJobs.js
  HouseAccountUser.js
  logger.js
  OrderThrottleService.js
  seedDatabase.js
  seedGuests.js
  seedRoles.js
  server.js
  socket.js
  websocket.js
ssl/
  server.cert
.babelrc
.dockerignore
.eslintrc.js
.sequelizerc
checkMigrations.js
collect-seed-errors.js
config.json
convert_to_js.sh
correctmodel1.js
correctmodelname.js
docker-compose.yml
docker-entrypoint.sh
Dockerfile
Dockerfile.migrate
drop_all_tables.sql
eslint.config.mjs
jsconfig.json
package.json
removeExtraBaseModels.js
route-check.js
search_role_template_assignments.sh
seed-errors.json
ts_to_js_converter.py
updateModels.js

================================================================
Repository Files
================================================================

================
File: .github/workflows/security.yml
================
name: Security Scanning

on:
  push:
    branches:
      - main
      - develop

jobs:
  owasp-zap:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Run OWASP ZAP Baseline Scan
        run: docker run -v $(pwd):/zap/wrk/:rw -t owasp/zap2docker-stable zap-baseline.py -t http://localhost:5000 -r zap-report.html

================
File: config/config.json
================
{
  "development": {
    "username": "bryce",
    "password": "1234",
    "database": "pos",
    "host": "db",
    "dialect": "postgres"
  },
  "test": {
    "username": "bryce",
    "password": "1234",
    "database": "pos_test",
    "host": "db",
    "dialect": "postgres"
  },
  "production": {
    "use_env_variable": "DATABASE_URL",
    "dialect": "postgres",
    "dialectOptions": {
      "ssl": {
        "require": true,
        "rejectUnauthorized": false
      }
    }
  }
}

================
File: config/database.js
================
const { Sequelize } = require('sequelize');

const sequelize = new Sequelize(
  process.env.DB_NAME || 'pos',
  process.env.DB_USER || 'bryce',
  process.env.DB_PASSWORD || '1234',
  {
    host: process.env.DB_HOST || 'db',
    dialect: 'postgres',
  }
);

module.exports = sequelize;

================
File: migrations/helpers/migrationHelpers.js
================
const { QueryTypes } = require('sequelize');

/**
 * Check if a table exists.
 * @param {object} queryInterface - The Sequelize queryInterface object.
 * @param {string} tableName - The name of the table.
 * @returns {Promise<boolean>} - True if the table exists, false otherwise.
 */
async function tableExists(queryInterface, tableName) {
  try {
    const tables = await queryInterface.sequelize.query(
      `SELECT table_name FROM information_schema.tables WHERE table_schema = 'public';`,
      { type: QueryTypes.SELECT }
    );
    return tables.some(table => table.table_name === tableName);
  } catch (error) {
    console.error(`Error checking if table ${tableName} exists:`, error);
    return false;
  }
}

/**
 * Check if a column exists in a table.
 * @param {object} queryInterface - The Sequelize queryInterface object.
 * @param {string} tableName - The name of the table.
 * @param {string} columnName - The name of the column.
 * @returns {Promise<boolean>} - True if the column exists, false otherwise.
 */
async function columnExists(queryInterface, tableName, columnName) {
  try {
    const tableDescription = await queryInterface.describeTable(tableName);
    return !!tableDescription[columnName];
  } catch (error) {
    console.error(`Error checking if column ${columnName} exists in table ${tableName}:`, error);
    return false;
  }
}

/**
 * Check if an index exists in a table.
 * @param {object} queryInterface - The Sequelize queryInterface object.
 * @param {string} tableName - The name of the table.
 * @param {string} indexName - The name of the index.
 * @returns {Promise<boolean>} - True if the index exists, false otherwise.
 */
async function indexExists(queryInterface, tableName, indexName) {
  try {
    const indexes = await queryInterface.showIndex(tableName);
    return indexes.some(index => index.name === indexName);
  } catch (error) {
    console.error(`Error checking if index ${indexName} exists in table ${tableName}:`, error);
    return false;
  }
}

module.exports = {
  tableExists,
  columnExists,
  indexExists
};

================
File: migrations/.eslintrc.js
================
module.exports = {
  rules: {
    'no-unused-vars': ['error', { argsIgnorePattern: '^(queryInterface|Sequelize)$' }],
  },
};

================
File: migrations/01_create_all_tables.js
================
'use strict';

const { tableExists } = require('./helpers/migrationHelpers');

module.exports = {
  up: async (queryInterface, Sequelize) => {
    // Clients table
    if (!(await tableExists(queryInterface, 'Clients'))) {
      await queryInterface.createTable('Clients', {
        id: {
          allowNull: false,
          autoIncrement: true,
          primaryKey: true,
          type: Sequelize.INTEGER,
        },
        name: {
          type: Sequelize.STRING,
          allowNull: false,
        },
        subdomain: {
          type: Sequelize.STRING,
          allowNull: false,
          unique: true,
        },
        features: {
          type: Sequelize.JSON,
          allowNull: true,
        },
        active: {
          type: Sequelize.BOOLEAN,
          defaultValue: true,
        },
        settings: {
          type: Sequelize.JSON,
          defaultValue: {},
        },
        brandingOptions: {
          type: Sequelize.JSONB,
          allowNull: true,
        },
        clientSettings: {
          type: Sequelize.JSONB,
          allowNull: true,
        },
        email: {
          type: Sequelize.STRING,
          allowNull: false,
          unique: true,
        },
        createdAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
        updatedAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
      });
      console.log('Clients table created');
    } else {
      console.log('Clients table already exists');
    }

    // Locations table
    if (!(await tableExists(queryInterface, 'Locations'))) {
      await queryInterface.createTable('Locations', {
        id: {
          allowNull: false,
          autoIncrement: true,
          primaryKey: true,
          type: Sequelize.INTEGER,
        },
        name: {
          type: Sequelize.STRING,
          allowNull: false,
        },
        address: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        city: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        state: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        zipCode: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        country: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        isOpen: {
          type: Sequelize.BOOLEAN,
          defaultValue: true,
        },
        diningOptions: {
          type: Sequelize.ARRAY(Sequelize.STRING),
          allowNull: true,
        },
        latitude: {
          type: Sequelize.FLOAT,
          allowNull: true,
        },
        longitude: {
          type: Sequelize.FLOAT,
          allowNull: true,
        },
        clientId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'Clients',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'SET NULL',
        },
        createdAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
        updatedAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
      });
      console.log('Locations table created');
    } else {
      console.log('Locations table already exists');
    }
    // Roles table
    if (!(await tableExists(queryInterface, 'Roles'))) {
      await queryInterface.createTable('Roles', {
        id: {
          allowNull: false,
          autoIncrement: true,
          primaryKey: true,
          type: Sequelize.INTEGER,
        },
        name: {
          type: Sequelize.STRING,
          allowNull: false,
          unique: true,
        },
        level: {
          type: Sequelize.INTEGER,
          allowNull: false,
        },
        clientId: {
          type: Sequelize.INTEGER,
          allowNull: true,
          references: {
            model: 'Clients',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'SET NULL',
        },
        createdAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
        updatedAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
      });
      console.log('Roles table created');
    } else {
      console.log('Roles table already exists');
    }

    // Users table
    if (!(await tableExists(queryInterface, 'Users'))) {
      await queryInterface.createTable('Users', {
        id: {
          allowNull: false,
          autoIncrement: true,
          primaryKey: true,
          type: Sequelize.INTEGER,
        },
        username: {
          type: Sequelize.STRING,
          allowNull: false,
          unique: true,
        },
        email: {
          type: Sequelize.STRING,
          allowNull: false,
          unique: true,
        },
        password: {
          type: Sequelize.STRING,
          allowNull: false,
        },
        roleId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'Roles',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE',
        },
        firstName: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        lastName: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        active: {
          type: Sequelize.BOOLEAN,
          allowNull: false,
          defaultValue: true,
        },
        createdAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
        updatedAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
      });
      console.log('Users table created');
    } else {
      console.log('Users table already exists');
    }

    // PosProfiles table
    if (!(await tableExists(queryInterface, 'PosProfiles'))) {
      await queryInterface.createTable('PosProfiles', {
        id: {
          type: Sequelize.INTEGER,
          autoIncrement: true,
          primaryKey: true,
        },
        name: {
          type: Sequelize.STRING,
          allowNull: false,
        },
        provider: {
          type: Sequelize.STRING,
          allowNull: false,
        },
        posApiKey: {
          type: Sequelize.STRING,
          allowNull: false,
        },
        apiBaseUrl: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        clientSecret: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        contentType: {
          type: Sequelize.STRING,
          allowNull: true,
          defaultValue: 'application/json',
        },
        roundingOption: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        testProfile: {
          type: Sequelize.BOOLEAN,
          allowNull: false,
          defaultValue: false,
        },
        isActive: {
          type: Sequelize.BOOLEAN,
          allowNull: false,
          defaultValue: true,
        },
        lastSyncedAt: {
          type: Sequelize.DATE,
          allowNull: true,
        },
        syncFrequency: {
          type: Sequelize.INTEGER,
          allowNull: true,
          defaultValue: 24,
        },
        createdAt: {
          type: Sequelize.DATE,
          allowNull: false,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
        updatedAt: {
          type: Sequelize.DATE,
          allowNull: false,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
      });
      console.log('PosProfiles table created');
    } else {
      console.log('PosProfiles table already exists');
    }
    // Menus table
    if (!(await tableExists(queryInterface, 'Menus'))) {
      await queryInterface.createTable('Menus', {
        id: {
          allowNull: false,
          autoIncrement: true,
          primaryKey: true,
          type: Sequelize.INTEGER,
        },
        name: {
          type: Sequelize.STRING,
          allowNull: false,
        },
        description: {
          type: Sequelize.TEXT,
          allowNull: true,
        },
        clientId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'Clients',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE',
        },
        locationId: {
          type: Sequelize.INTEGER,
          allowNull: true,
          references: {
            model: 'Locations',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'SET NULL',
        },
        isActive: {
          type: Sequelize.BOOLEAN,
          allowNull: false,
          defaultValue: true,
        },
        startDate: {
          type: Sequelize.DATE,
          allowNull: true,
        },
        endDate: {
          type: Sequelize.DATE,
          allowNull: true,
        },
        menuType: {
          type: Sequelize.STRING,
          allowNull: false,
          defaultValue: 'regular',
        },
        createdAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
        updatedAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
      });
      console.log('Menus table created');
    } else {
      console.log('Menus table already exists');
    }

    // MenuGroups table
    if (!(await tableExists(queryInterface, 'MenuGroups'))) {
      await queryInterface.createTable('MenuGroups', {
        id: {
          allowNull: false,
          autoIncrement: true,
          primaryKey: true,
          type: Sequelize.INTEGER,
        },
        name: {
          type: Sequelize.STRING,
          allowNull: false,
        },
        description: {
          type: Sequelize.TEXT,
          allowNull: true,
        },
        menuId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'Menus',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE',
        },
        displayOrder: {
          type: Sequelize.INTEGER,
          allowNull: false,
          defaultValue: 0,
        },
        isActive: {
          type: Sequelize.BOOLEAN,
          allowNull: false,
          defaultValue: true,
        },
        startTime: {
          type: Sequelize.TIME,
          allowNull: true,
        },
        endTime: {
          type: Sequelize.TIME,
          allowNull: true,
        },
        daysAvailable: {
          type: Sequelize.ARRAY(Sequelize.STRING),
          allowNull: true,
        },
        image: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        createdAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
        updatedAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
      });
      console.log('MenuGroups table created');
    } else {
      console.log('MenuGroups table already exists');
    }

    // MenuItems table
    if (!(await tableExists(queryInterface, 'MenuItems'))) {
      await queryInterface.createTable('MenuItems', {
        id: {
          allowNull: false,
          autoIncrement: true,
          primaryKey: true,
          type: Sequelize.INTEGER,
        },
        name: {
          type: Sequelize.STRING,
          allowNull: false,
        },
        description: {
          type: Sequelize.TEXT,
          allowNull: true,
        },
        menuGroupId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'MenuGroups',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE',
        },
        basePrice: {
          type: Sequelize.FLOAT,
          allowNull: false,
        },
        pointsPrice: {
          type: Sequelize.INTEGER,
          allowNull: true,
        },
        posItemId: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        imageUrl: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        isActive: {
          type: Sequelize.BOOLEAN,
          allowNull: false,
          defaultValue: true,
        },
        displayOrder: {
          type: Sequelize.INTEGER,
          allowNull: false,
          defaultValue: 0,
        },
        calories: {
          type: Sequelize.INTEGER,
          allowNull: true,
        },
        allergens: {
          type: Sequelize.ARRAY(Sequelize.STRING),
          allowNull: true,
        },
        dietaryRestrictions: {
          type: Sequelize.ARRAY(Sequelize.STRING),
          allowNull: true,
        },
        customizations: {
          type: Sequelize.JSONB,
          allowNull: true,
        },
        createdAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
        updatedAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
      });
      console.log('MenuItems table created');
    } else {
      console.log('MenuItems table already exists');
    }

    // Modifiers table
    if (!(await tableExists(queryInterface, 'Modifiers'))) {
      await queryInterface.createTable('Modifiers', {
        id: {
          allowNull: false,
          autoIncrement: true,
          primaryKey: true,
          type: Sequelize.INTEGER,
        },
        name: {
          type: Sequelize.STRING,
          allowNull: false,
        },
        description: {
          type: Sequelize.TEXT,
          allowNull: true,
        },
        price: {
          type: Sequelize.FLOAT,
          allowNull: true,
        },
        posModifierId: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        isActive: {
          type: Sequelize.BOOLEAN,
          allowNull: false,
          defaultValue: true,
        },
        modifierType: {
          type: Sequelize.ENUM('add-on', 'removal', 'substitution'),
          allowNull: false,
          defaultValue: 'add-on',
        },
        clientId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'Clients',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE',
        },
        calories: {
          type: Sequelize.INTEGER,
          allowNull: true,
        },
        allergens: {
          type: Sequelize.ARRAY(Sequelize.STRING),
          allowNull: true,
        },
        displayOrder: {
          type: Sequelize.INTEGER,
          allowNull: false,
          defaultValue: 0,
        },
        imageUrl: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        createdAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
        updatedAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
      });
      console.log('Modifiers table created');
    } else {
      console.log('Modifiers table already exists');
    }

    // MenuItemModifiers table
    if (!(await tableExists(queryInterface, 'MenuItemModifiers'))) {
      await queryInterface.createTable('MenuItemModifiers', {
        id: {
          allowNull: false,
          autoIncrement: true,
          primaryKey: true,
          type: Sequelize.INTEGER,
        },
        menuItemId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'MenuItems',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE',
        },
        modifierId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'Modifiers',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE',
        },
        isDefault: {
          type: Sequelize.BOOLEAN,
          allowNull: false,
          defaultValue: false,
        },
        isRequired: {
          type: Sequelize.BOOLEAN,
          allowNull: false,
          defaultValue: false,
        },
        minQuantity: {
          type: Sequelize.INTEGER,
          allowNull: false,
          defaultValue: 0,
        },
        maxQuantity: {
          type: Sequelize.INTEGER,
          allowNull: true,
        },
        displayOrder: {
          type: Sequelize.INTEGER,
          allowNull: false,
          defaultValue: 0,
        },
        priceOverride: {
          type: Sequelize.FLOAT,
          allowNull: true,
        },
        createdAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
        updatedAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
      });
      console.log('MenuItemModifiers table created');
    } else {
      console.log('MenuItemModifiers table already exists');
    }

    // Guests table
    if (!(await tableExists(queryInterface, 'Guests'))) {
      await queryInterface.createTable('Guests', {
        id: {
          allowNull: false,
          autoIncrement: true,
          primaryKey: true,
          type: Sequelize.INTEGER,
        },
        firstName: {
          type: Sequelize.STRING,
          allowNull: false,
        },
        lastName: {
          type: Sequelize.STRING,
          allowNull: false,
        },
        email: {
          type: Sequelize.STRING,
          allowNull: false,
          unique: true,
        },
        phoneNumber: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        createdAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
        updatedAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
      });
      console.log('Guests table created');
    } else {
      console.log('Guests table already exists');
    }
    // Orders table
    if (!(await tableExists(queryInterface, 'Orders'))) {
      await queryInterface.createTable('Orders', {
        id: {
          allowNull: false,
          autoIncrement: true,
          primaryKey: true,
          type: Sequelize.INTEGER,
        },
        clientId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'Clients',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE',
        },
        guestId: {
          type: Sequelize.INTEGER,
          allowNull: true,
          references: {
            model: 'Guests',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'SET NULL',
        },
        locationId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'Locations',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE',
        },
        orderDate: {
          type: Sequelize.DATE,
          allowNull: false,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
        status: {
          type: Sequelize.ENUM('pending', 'completed', 'canceled'),
          allowNull: false,
          defaultValue: 'pending',
        },
        totalAmount: {
          type: Sequelize.FLOAT,
          allowNull: false,
        },
        subtotal: {
          type: Sequelize.FLOAT,
          allowNull: false,
        },
        tax: {
          type: Sequelize.FLOAT,
          allowNull: false,
        },
        tip: {
          type: Sequelize.FLOAT,
          allowNull: true,
        },
        discount: {
          type: Sequelize.FLOAT,
          allowNull: false,
          defaultValue: 0,
        },
        paymentMethod: {
          type: Sequelize.STRING,
          allowNull: false,
        },
        loyaltyPointsEarned: {
          type: Sequelize.INTEGER,
          allowNull: false,
          defaultValue: 0,
        },
        loyaltyPointsRedeemed: {
          type: Sequelize.INTEGER,
          allowNull: false,
          defaultValue: 0,
        },
        orderType: {
          type: Sequelize.ENUM('pickup', 'delivery', 'dine-in'),
          allowNull: false,
        },
        specialInstructions: {
          type: Sequelize.TEXT,
          allowNull: true,
        },
        estimatedPickupTime: {
          type: Sequelize.DATE,
          allowNull: true,
        },
        actualPickupTime: {
          type: Sequelize.DATE,
          allowNull: true,
        },
        createdAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
        updatedAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
      });
      console.log('Orders table created');
    } else {
      console.log('Orders table already exists');
    }

    // OrderItems table
    if (!(await tableExists(queryInterface, 'OrderItems'))) {
      await queryInterface.createTable('OrderItems', {
        id: {
          allowNull: false,
          autoIncrement: true,
          primaryKey: true,
          type: Sequelize.INTEGER,
        },
        orderId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'Orders',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE',
        },
        itemId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'MenuItems',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE',
        },
        itemName: {
          type: Sequelize.STRING,
          allowNull: false,
        },
        itemPrice: {
          type: Sequelize.FLOAT,
          allowNull: false,
        },
        quantity: {
          type: Sequelize.INTEGER,
          allowNull: false,
          defaultValue: 1,
        },
        createdAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
        updatedAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
      });
      console.log('OrderItems table created');
    } else {
      console.log('OrderItems table already exists');
    }

    // OrderModifiers table
    if (!(await tableExists(queryInterface, 'OrderModifiers'))) {
      await queryInterface.createTable('OrderModifiers', {
        id: {
          allowNull: false,
          autoIncrement: true,
          primaryKey: true,
          type: Sequelize.INTEGER,
        },
        orderItemId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'OrderItems',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE',
        },
        modifierId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'Modifiers',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE',
        },
        modifierName: {
          type: Sequelize.STRING,
          allowNull: false,
        },
        modifierPrice: {
          type: Sequelize.FLOAT,
          allowNull: false,
        },
        quantity: {
          type: Sequelize.INTEGER,
          allowNull: false,
          defaultValue: 1,
        },
        createdAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
        updatedAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
      });
      console.log('OrderModifiers table created');
    } else {
      console.log('OrderModifiers table already exists');
    }

    // Wallets table
    if (!(await tableExists(queryInterface, 'Wallets'))) {
      await queryInterface.createTable('Wallets', {
        id: {
          allowNull: false,
          autoIncrement: true,
          primaryKey: true,
          type: Sequelize.INTEGER,
        },
        guestId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'Guests',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE',
        },
        clientId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'Clients',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE',
        },
        balance: {
          type: Sequelize.DECIMAL(10, 2),
          allowNull: false,
          defaultValue: 0.00,
        },
        currency: {
          type: Sequelize.STRING,
          allowNull: false,
          defaultValue: 'USD',
        },
        isActive: {
          type: Sequelize.BOOLEAN,
          allowNull: false,
          defaultValue: true,
        },
        lastTransactionDate: {
          type: Sequelize.DATE,
          allowNull: true,
        },
        createdAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
        updatedAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
      });
      console.log('Wallets table created');
    } else {
      console.log('Wallets table already exists');
    }

    // Discounts table
    if (!(await tableExists(queryInterface, 'Discounts'))) {
      await queryInterface.createTable('Discounts', {
        id: {
          allowNull: false,
          autoIncrement: true,
          primaryKey: true,
          type: Sequelize.INTEGER,
        },
        clientId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'Clients',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE',
        },
        name: {
          type: Sequelize.STRING,
          allowNull: false,
        },
        type: {
          type: Sequelize.ENUM('percentage', 'fixed'),
          allowNull: false,
        },
        value: {
          type: Sequelize.DECIMAL(10, 2),
          allowNull: false,
        },
        validFrom: {
          type: Sequelize.DATE,
          allowNull: false,
        },
        validTo: {
          type: Sequelize.DATE,
          allowNull: false,
        },
        createdAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.fn('NOW'),
        },
        updatedAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.fn('NOW'),
        },
      });
      console.log('Discounts table created');
    } else {
      console.log('Discounts table already exists');
    }

    // LoyaltyPrograms table
    if (!(await tableExists(queryInterface, 'LoyaltyPrograms'))) {
      await queryInterface.createTable('LoyaltyPrograms', {
        id: {
          allowNull: false,
          autoIncrement: true,
          primaryKey: true,
          type: Sequelize.INTEGER,
        },
        clientId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'Clients',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE',
        },
        name: {
          type: Sequelize.STRING,
          allowNull: false,
        },
        description: {
          type: Sequelize.TEXT,
          allowNull: true,
        },
        pointsPerDollar: {
          type: Sequelize.INTEGER,
          allowNull: false,
          defaultValue: 1,
        },
        redemptionRate: {
          type: Sequelize.FLOAT,
          allowNull: false,
          defaultValue: 0.01,
        },
        isActive: {
          type: Sequelize.BOOLEAN,
          allowNull: false,
          defaultValue: true,
        },
        createdAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
        updatedAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
      });
      console.log('LoyaltyPrograms table created');
    } else {
      console.log('LoyaltyPrograms table already exists');
    }
    // Rewards table
    if (!(await tableExists(queryInterface, 'Rewards'))) {
      await queryInterface.createTable('Rewards', {
        id: {
          allowNull: false,
          autoIncrement: true,
          primaryKey: true,
          type: Sequelize.INTEGER,
        },
        loyaltyProgramId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'LoyaltyPrograms',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE',
        },
        name: {
          type: Sequelize.STRING,
          allowNull: false,
        },
        description: {
          type: Sequelize.TEXT,
          allowNull: true,
        },
        pointsRequired: {
          type: Sequelize.INTEGER,
          allowNull: false,
        },
        isActive: {
          type: Sequelize.BOOLEAN,
          allowNull: false,
          defaultValue: true,
        },
        createdAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
        updatedAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
      });
      console.log('Rewards table created');
    } else {
      console.log('Rewards table already exists');
    }

    // Coupons table
    if (!(await tableExists(queryInterface, 'Coupons'))) {
      await queryInterface.createTable('Coupons', {
        id: {
          allowNull: false,
          autoIncrement: true,
          primaryKey: true,
          type: Sequelize.INTEGER,
        },
        code: {
          type: Sequelize.STRING,
          allowNull: false,
          unique: true,
        },
        discountType: {
          type: Sequelize.ENUM('percentage', 'fixed'),
          allowNull: false,
        },
        discountValue: {
          type: Sequelize.FLOAT,
          allowNull: false,
        },
        startDate: {
          type: Sequelize.DATE,
          allowNull: false,
        },
        endDate: {
          type: Sequelize.DATE,
          allowNull: true,
        },
        usageLimit: {
          type: Sequelize.INTEGER,
          allowNull: true,
        },
        isActive: {
          type: Sequelize.BOOLEAN,
          allowNull: false,
          defaultValue: true,
        },
        createdAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
        updatedAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
      });
      console.log('Coupons table created');
    } else {
      console.log('Coupons table already exists');
    }

    // Brandings table
    if (!(await tableExists(queryInterface, 'Brandings'))) {
      await queryInterface.createTable('Brandings', {
        id: {
          allowNull: false,
          autoIncrement: true,
          primaryKey: true,
          type: Sequelize.INTEGER,
        },
        clientId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'Clients',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE',
        },
        primaryColor: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        secondaryColor: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        tertiaryColor: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        fontColor: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        secondaryFontColor: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        fontFamily: {
          type: Sequelize.STRING,
          allowNull: true,
          defaultValue: 'Arial',
        },
        logoUrl: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        backgroundUrl: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        faviconUrl: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        customCss: {
          type: Sequelize.TEXT,
          allowNull: true,
        },
        buttonStyle: {
          type: Sequelize.JSONB,
          allowNull: true,
        },
        headerStyle: {
          type: Sequelize.JSONB,
          allowNull: true,
        },
        footerStyle: {
          type: Sequelize.JSONB,
          allowNull: true,
        },
        isActive: {
          type: Sequelize.BOOLEAN,
          allowNull: false,
          defaultValue: true,
        },
        createdAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
        updatedAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
      });
      console.log('Brandings table created');
    } else {
      console.log('Brandings table already exists');
    }

    // GuestPreferences table
    if (!(await tableExists(queryInterface, 'GuestPreferences'))) {
      await queryInterface.createTable('GuestPreferences', {
        id: {
          allowNull: false,
          autoIncrement: true,
          primaryKey: true,
          type: Sequelize.INTEGER,
        },
        guestId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'Guests',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE',
        },
        preferenceType: {
          type: Sequelize.STRING,
          allowNull: false,
        },
        preferenceValue: {
          type: Sequelize.STRING,
          allowNull: false,
        },
        createdAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
        updatedAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
      });
      console.log('GuestPreferences table created');
    } else {
      console.log('GuestPreferences table already exists');
    }

    // Reports table
    if (!(await tableExists(queryInterface, 'Reports'))) {
      await queryInterface.createTable('Reports', {
        id: {
          allowNull: false,
          autoIncrement: true,
          primaryKey: true,
          type: Sequelize.INTEGER,
        },
        clientId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'Clients',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE',
        },
        reportType: {
          type: Sequelize.STRING,
          allowNull: false,
        },
        reportData: {
          type: Sequelize.JSONB,
          allowNull: true,
        },
        createdAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
        updatedAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
      });
      console.log('Reports table created');
    } else {
      console.log('Reports table already exists');
    }

    // CateringOrders table
    if (!(await tableExists(queryInterface, 'CateringOrders'))) {
      await queryInterface.createTable('CateringOrders', {
        id: {
          allowNull: false,
          autoIncrement: true,
          primaryKey: true,
          type: Sequelize.INTEGER,
        },
        guestId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'Guests',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE',
        },
        locationId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'Locations',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'SET NULL',
        },
        eventDate: {
          type: Sequelize.DATE,
          allowNull: false,
        },
        totalCost: {
          type: Sequelize.FLOAT,
          allowNull: false,
        },
        notes: {
          type: Sequelize.TEXT,
          allowNull: true,
        },
        status: {
          type: Sequelize.ENUM('pending', 'confirmed', 'completed', 'cancelled'),
          allowNull: false,
          defaultValue: 'pending',
        },
        createdAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
        updatedAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
      });
      console.log('CateringOrders table created');
    } else {
      console.log('CateringOrders table already exists');
    }

    // ABTests table
    if (!(await tableExists(queryInterface, 'ABTests'))) {
      await queryInterface.createTable('ABTests', {
        id: {
          allowNull: false,
          autoIncrement: true,
          primaryKey: true,
          type: Sequelize.INTEGER,
        },
        testName: {
          type: Sequelize.STRING,
          allowNull: false,
        },
        menuItemId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'MenuItems',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE',
        },
        testVariant: {
          type: Sequelize.STRING,
          allowNull: false,
        },
        variantDescription: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        testType: {
          type: Sequelize.STRING,
          allowNull: false,
        },
        upliftSettings: {
          type: Sequelize.JSONB,
          allowNull: true,
        },
        startDate: {
          type: Sequelize.DATE,
          allowNull: false,
        },
        endDate: {
          type: Sequelize.DATE,
          allowNull: true,
        },
        status: {
          type: Sequelize.STRING,
          defaultValue: 'active',
        },
        clientId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'Clients',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE',
        },
        createdAt: {
          allowNull: false,
          type: Sequelize.DATE,
        },
        updatedAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
      });
      console.log('ABTests table created');
    } else {
      console.log('ABTests table already exists');
    }

    // AuditLogs table
    if (!(await tableExists(queryInterface, 'AuditLogs'))) {
      await queryInterface.createTable('AuditLogs', {
        id: {
          allowNull: false,
          autoIncrement: true,
          primaryKey: true,
          type: Sequelize.INTEGER,
        },
        clientId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'Clients',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE',
        },
        userId: {
          type: Sequelize.INTEGER,
          allowNull: true,
          references: {
            model: 'Users',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'SET NULL',
        },
        action: {
          type: Sequelize.STRING,
          allowNull: false,
        },
        entityType: {
          type: Sequelize.STRING,
          allowNull: false,
        },
        entityId: {
          type: Sequelize.INTEGER,
          allowNull: true,
        },
        details: {
          type: Sequelize.JSONB,
          allowNull: true,
        },
        ipAddress: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        userAgent: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        timestamp: {
          type: Sequelize.DATE,
          allowNull: false,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
        createdAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
        updatedAt: {
          allowNull: false,
          type: Sequelize.DATE,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
      });
      console.log('AuditLogs table created');
    } else {
      console.log('AuditLogs table already exists');
    }

    // HouseAccounts table
    if (!(await tableExists(queryInterface, 'HouseAccounts'))) {
      await queryInterface.createTable('HouseAccounts', {
        id: {
          type: Sequelize.INTEGER,
          primaryKey: true,
          autoIncrement: true,
        },
        clientId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'Clients',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE',
        },
        accountName: {
          type: Sequelize.STRING,
          allowNull: false,
        },
        billingAddress: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        contactEmail: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        creditLimit: {
          type: Sequelize.FLOAT,
          allowNull: false,
          defaultValue: 0,
        },
        createdAt: {
          type: Sequelize.DATE,
          allowNull: false,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
        updatedAt: {
          type: Sequelize.DATE,
          allowNull: false,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
      });
      console.log('HouseAccounts table created');
    } else {
      console.log('HouseAccounts table already exists');
    }

    // Analytics table
    if (!(await tableExists(queryInterface, 'Analytics'))) {
      await queryInterface.createTable('Analytics', {
        id: {
          type: Sequelize.INTEGER,
          primaryKey: true,
          autoIncrement: true,
        },
        clientId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'Clients',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE',
        },
        locationId: {
          type: Sequelize.INTEGER,
          allowNull: true,
          references: {
            model: 'Locations',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'SET NULL',
        },
        date: {
          type: Sequelize.DATEONLY,
          allowNull: false,
        },
        metricType: {
          type: Sequelize.STRING,
          allowNull: false,
        },
        metricValue: {
          type: Sequelize.FLOAT,
          allowNull: false,
        },
        dimension1: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        dimension2: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        dimension3: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        additionalData: {
          type: Sequelize.JSONB,
          allowNull: true,
        },
        createdAt: {
          type: Sequelize.DATE,
          allowNull: false,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
        updatedAt: {
          type: Sequelize.DATE,
          allowNull: false,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
      });
      console.log('Analytics table created');
    } else {
      console.log('Analytics table already exists');
    }

    // GlobalSettings table
    if (!(await tableExists(queryInterface, 'GlobalSettings'))) {
      await queryInterface.createTable('GlobalSettings', {
        id: {
          type: Sequelize.INTEGER,
          primaryKey: true,
          autoIncrement: true,
        },
        key: {
          type: Sequelize.STRING,
          allowNull: false,
          unique: true,
        },
        value: {
          type: Sequelize.TEXT,
          allowNull: true,
        },
        dataType: {
          type: Sequelize.ENUM('string', 'number', 'boolean', 'json'),
          allowNull: false,
          defaultValue: 'string',
        },
        description: {
          type: Sequelize.TEXT,
          allowNull: true,
        },
        category: {
          type: Sequelize.STRING,
          allowNull: true,
        },
        isEditable: {
          type: Sequelize.BOOLEAN,
          allowNull: false,
          defaultValue: true,
        },
        lastModifiedBy: {
          type: Sequelize.INTEGER,
          allowNull: true,
          references: {
            model: 'Users',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'SET NULL',
        },
        createdAt: {
          type: Sequelize.DATE,
          allowNull: false,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
        updatedAt: {
          type: Sequelize.DATE,
          allowNull: false,
          defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
        },
      });
      console.log('GlobalSettings table created');
    } else {
      console.log('GlobalSettings table already exists');
    }

    console.log('All tables created or verified successfully');
  },

  down: async (queryInterface, Sequelize) => {
    // Drop all tables in reverse order
    await queryInterface.dropTable('GlobalSettings');
    await queryInterface.dropTable('Analytics');
    await queryInterface.dropTable('HouseAccounts');
    await queryInterface.dropTable('AuditLogs');
    await queryInterface.dropTable('ABTests');
    await queryInterface.dropTable('CateringOrders');
    await queryInterface.dropTable('Reports');
    await queryInterface.dropTable('GuestPreferences');
    await queryInterface.dropTable('Brandings');
    await queryInterface.dropTable('Coupons');
    await queryInterface.dropTable('Rewards');
    await queryInterface.dropTable('LoyaltyPrograms');
    await queryInterface.dropTable('Discounts');
    await queryInterface.dropTable('Wallets');
    await queryInterface.dropTable('OrderModifiers');
    await queryInterface.dropTable('OrderItems');
    await queryInterface.dropTable('Orders');
    await queryInterface.dropTable('Guests');
    await queryInterface.dropTable('MenuItemModifiers');
    await queryInterface.dropTable('Modifiers');
    await queryInterface.dropTable('MenuItems');
    await queryInterface.dropTable('MenuGroups');
    await queryInterface.dropTable('Menus');
    await queryInterface.dropTable('CorePOSProfiles');
    await queryInterface.dropTable('PosIntegrationSettings');
    await queryInterface.dropTable('PosProfiles');
    await queryInterface.dropTable('Users');
    await queryInterface.dropTable('Roles');
    await queryInterface.dropTable('Locations');
    await queryInterface.dropTable('Clients');
    // Add any additional table drops here...

    console.log('All tables dropped successfully');
  }
};

================
File: migrations/20240818161348-add-location-menu-override.js
================
'use strict';

module.exports = {
  async up (queryInterface, Sequelize) {
    // Check if the table already exists
    const tableExists = await queryInterface.showAllTables().then(tables => tables.includes('LocationMenuOverrides'));
    
    if (!tableExists) {
      await queryInterface.createTable('LocationMenuOverrides', {
        id: {
          allowNull: false,
          autoIncrement: true,
          primaryKey: true,
          type: Sequelize.INTEGER
        },
        locationId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'Locations',
            key: 'id'
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE'
        },
        menuItemId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'MenuItems',
            key: 'id'
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE'
        },
        price: {
          type: Sequelize.DECIMAL(10, 2),
          allowNull: true
        },
        isAvailable: {
          type: Sequelize.BOOLEAN,
          defaultValue: true
        },
        createdAt: {
          allowNull: false,
          type: Sequelize.DATE
        },
        updatedAt: {
          allowNull: false,
          type: Sequelize.DATE
        }
      });
    } else {
      // If table exists, check for and add missing columns
      const columns = await queryInterface.describeTable('LocationMenuOverrides');
      
      if (!columns.price) {
        await queryInterface.addColumn('LocationMenuOverrides', 'price', {
          type: Sequelize.DECIMAL(10, 2),
          allowNull: true
        });
      }
      
      if (!columns.isAvailable) {
        await queryInterface.addColumn('LocationMenuOverrides', 'isAvailable', {
          type: Sequelize.BOOLEAN,
          defaultValue: true
        });
      }
    }
  },

  async down (queryInterface, Sequelize) {
    await queryInterface.dropTable('LocationMenuOverrides');
  }
};

================
File: migrations/20240818161349-add-location-tax-config.js
================
'use strict';

module.exports = {
  async up (queryInterface, Sequelize) {
    const tableExists = await queryInterface.showAllTables().then(tables => tables.includes('LocationTaxConfigs'));
    
    if (!tableExists) {
      await queryInterface.createTable('LocationTaxConfigs', {
        id: {
          allowNull: false,
          autoIncrement: true,
          primaryKey: true,
          type: Sequelize.INTEGER
        },
        locationId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'Locations',
            key: 'id'
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE'
        },
        taxRate: {
          type: Sequelize.DECIMAL(5, 2),
          allowNull: false
        },
        taxType: {
          type: Sequelize.ENUM('Sales', 'VAT', 'GST'),
          allowNull: false
        },
        createdAt: {
          allowNull: false,
          type: Sequelize.DATE
        },
        updatedAt: {
          allowNull: false,
          type: Sequelize.DATE
        }
      });
    } else {
      const columns = await queryInterface.describeTable('LocationTaxConfigs');
      
      if (!columns.taxRate) {
        await queryInterface.addColumn('LocationTaxConfigs', 'taxRate', {
          type: Sequelize.DECIMAL(5, 2),
          allowNull: false
        });
      }
      
      if (!columns.taxType) {
        await queryInterface.addColumn('LocationTaxConfigs', 'taxType', {
          type: Sequelize.ENUM('Sales', 'VAT', 'GST'),
          allowNull: false
        });
      }
    }
  },

  async down (queryInterface, Sequelize) {
    await queryInterface.dropTable('LocationTaxConfigs');
  }
};

================
File: migrations/20240818161350-add-loyalty-challenge.js
================
'use strict';

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up (queryInterface, Sequelize) {
    /**
     * Add altering commands here.
     *
     * Example:
     * await queryInterface.createTable('users', { id: Sequelize.INTEGER });
     */
  },

  async down (queryInterface, Sequelize) {
    /**
     * Add reverting commands here.
     *
     * Example:
     * await queryInterface.dropTable('users');
     */
  }
};

================
File: migrations/20240818161351-add-loyalty-config.js
================
'use strict';

module.exports = {
  async up (queryInterface, Sequelize) {
    const tableExists = await queryInterface.showAllTables().then(tables => tables.includes('LoyaltyConfigs'));
    
    if (!tableExists) {
      await queryInterface.createTable('LoyaltyConfigs', {
        id: {
          allowNull: false,
          autoIncrement: true,
          primaryKey: true,
          type: Sequelize.INTEGER
        },
        clientId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'Clients',
            key: 'id'
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE'
        },
        pointsPerDollar: {
          type: Sequelize.INTEGER,
          allowNull: false,
          defaultValue: 1
        },
        expirationPeriod: {
          type: Sequelize.INTEGER,
          allowNull: true,
          comment: 'Number of days before points expire'
        },
        createdAt: {
          allowNull: false,
          type: Sequelize.DATE
        },
        updatedAt: {
          allowNull: false,
          type: Sequelize.DATE
        }
      });
    } else {
      const columns = await queryInterface.describeTable('LoyaltyConfigs');
      
      if (!columns.expirationPeriod) {
        await queryInterface.addColumn('LoyaltyConfigs', 'expirationPeriod', {
          type: Sequelize.INTEGER,
          allowNull: true,
          comment: 'Number of days before points expire'
        });
      }
    }
  },

  async down (queryInterface, Sequelize) {
    await queryInterface.dropTable('LoyaltyConfigs');
  }
};

================
File: migrations/20240818161352-add-loyalty-integration.js
================
'use strict';

module.exports = {
  async up (queryInterface, Sequelize) {
    const tableExists = await queryInterface.showAllTables().then(tables => tables.includes('LoyaltyIntegrations'));
    
    if (!tableExists) {
      await queryInterface.createTable('LoyaltyIntegrations', {
        id: {
          allowNull: false,
          autoIncrement: true,
          primaryKey: true,
          type: Sequelize.INTEGER
        },
        clientId: {
          type: Sequelize.INTEGER,
          allowNull: false,
          references: {
            model: 'Clients',
            key: 'id'
          },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE'
        },
        integrationType: {
          type: Sequelize.ENUM('POS', 'CRM', 'Custom'),
          allowNull: false
        },
        integrationDetails: {
          type: Sequelize.JSON,
          allowNull: false
        },
        isActive: {
          type: Sequelize.BOOLEAN,
          defaultValue: true
        },
        createdAt: {
          allowNull: false,
          type: Sequelize.DATE
        },
        updatedAt: {
          allowNull: false,
          type: Sequelize.DATE
        }
      });
    } else {
      const columns = await queryInterface.describeTable('LoyaltyIntegrations');
      
      if (!columns.isActive) {
        await queryInterface.addColumn('LoyaltyIntegrations', 'isActive', {
          type: Sequelize.BOOLEAN,
          defaultValue: true
        });
      }
    }
  },

  async down (queryInterface, Sequelize) {
    await queryInterface.dropTable('LoyaltyIntegrations');
  }
};

================
File: migrations/20240828024349-update-role-and-template-associations.js
================
'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
    const transaction = await queryInterface.sequelize.transaction();

    try {
      // Helper function to check if a table exists
      const tableExists = async (tableName) => {
        try {
          await queryInterface.describeTable(tableName);
          return true;
        } catch (error) {
          return false;
        }
      };

      // Helper function to add a column if it doesn't exist
      const addColumnIfNotExists = async (tableName, columnName, columnDefinition) => {
        const table = await queryInterface.describeTable(tableName);
        if (!table[columnName]) {
          await queryInterface.addColumn(tableName, columnName, columnDefinition, { transaction });
        }
      };

      // Create or update RoleTemplates table
      if (!(await tableExists('RoleTemplates'))) {
        await queryInterface.createTable('RoleTemplates', {
          id: {
            allowNull: false,
            autoIncrement: true,
            primaryKey: true,
            type: Sequelize.INTEGER
          },
          name: {
            type: Sequelize.STRING,
            allowNull: false,
            unique: true,
          },
          description: {
            type: Sequelize.STRING,
            allowNull: true,
          },
          isEditable: {
            type: Sequelize.BOOLEAN,
            defaultValue: true,
          },
          isPredefined: {
            type: Sequelize.BOOLEAN,
            defaultValue: false,
          },
          createdAt: {
            allowNull: false,
            type: Sequelize.DATE,
            defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
          },
          updatedAt: {
            allowNull: false,
            type: Sequelize.DATE,
            defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
          }
        }, { transaction });
      } else {
        // Add columns if they don't exist
        await addColumnIfNotExists('RoleTemplates', 'isEditable', {
          type: Sequelize.BOOLEAN,
          defaultValue: true,
        });
        await addColumnIfNotExists('RoleTemplates', 'isPredefined', {
          type: Sequelize.BOOLEAN,
          defaultValue: false,
        });
      }

      // Create or update Roles table
      if (!(await tableExists('Roles'))) {
        await queryInterface.createTable('Roles', {
          id: {
            allowNull: false,
            autoIncrement: true,
            primaryKey: true,
            type: Sequelize.INTEGER
          },
          name: {
            type: Sequelize.STRING,
            allowNull: false,
          },
          level: {
            type: Sequelize.INTEGER,
            allowNull: false,
            defaultValue: 1,
          },
          description: {
            type: Sequelize.TEXT,
            allowNull: true,
          },
          isPredefined: {
            type: Sequelize.BOOLEAN,
            defaultValue: false,
          },
          isEditable: {
            type: Sequelize.BOOLEAN,
            defaultValue: true,
          },
          isAssignable: {
            type: Sequelize.BOOLEAN,
            defaultValue: true,
          },
          clientId: {
            type: Sequelize.INTEGER,
            allowNull: false,
            references: {
              model: 'Clients',
              key: 'id',
            },
            onDelete: 'CASCADE',
          },
          createdAt: {
            allowNull: false,
            type: Sequelize.DATE,
            defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
          },
          updatedAt: {
            allowNull: false,
            type: Sequelize.DATE,
            defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
          }
        }, { transaction });
      } else {
        // Add columns if they don't exist
        await addColumnIfNotExists('Roles', 'level', {
          type: Sequelize.INTEGER,
          allowNull: false,
          defaultValue: 1,
        });
        await addColumnIfNotExists('Roles', 'isPredefined', {
          type: Sequelize.BOOLEAN,
          defaultValue: false,
        });
        await addColumnIfNotExists('Roles', 'isEditable', {
          type: Sequelize.BOOLEAN,
          defaultValue: true,
        });
        await addColumnIfNotExists('Roles', 'isAssignable', {
          type: Sequelize.BOOLEAN,
          defaultValue: true,
        });
      }

      // Create RoleTemplateAssignments table if it doesn't exist
      if (!(await tableExists('RoleTemplateAssignments'))) {
        await queryInterface.createTable('RoleTemplateAssignments', {
          id: {
            allowNull: false,
            autoIncrement: true,
            primaryKey: true,
            type: Sequelize.INTEGER
          },
          roleId: {
            type: Sequelize.INTEGER,
            references: {
              model: 'Roles',
              key: 'id',
            },
            onDelete: 'CASCADE',
            allowNull: false,
          },
          roleTemplateId: {
            type: Sequelize.INTEGER,
            references: {
              model: 'RoleTemplates',
              key: 'id',
            },
            onDelete: 'CASCADE',
            allowNull: false,
          },
          clientId: {
            type: Sequelize.INTEGER,
            references: {
              model: 'Clients',
              key: 'id',
            },
            onDelete: 'CASCADE',
            allowNull: false,
          },
          createdAt: {
            allowNull: false,
            type: Sequelize.DATE,
            defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
          },
          updatedAt: {
            allowNull: false,
            type: Sequelize.DATE,
            defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
          }
        }, { transaction });

        // Add index only if the table was just created
        await queryInterface.addIndex('RoleTemplateAssignments', ['roleId', 'roleTemplateId', 'clientId'], {
          unique: true,
          name: 'unique_role_template_assignment',
          transaction
        });
      }

      await transaction.commit();
    } catch (error) {
      await transaction.rollback();
      throw error;
    }
  },

  down: async (queryInterface, Sequelize) => {
    const transaction = await queryInterface.sequelize.transaction();

    try {
      // Remove index if it exists
      await queryInterface.removeIndex('RoleTemplateAssignments', 'unique_role_template_assignment', { transaction }).catch(() => {});

      // Drop tables if they exist
      await queryInterface.dropTable('RoleTemplateAssignments', { transaction }).catch(() => {});
      
      // Remove added columns from Roles if they exist
      await queryInterface.removeColumn('Roles', 'level', { transaction }).catch(() => {});
      await queryInterface.removeColumn('Roles', 'isPredefined', { transaction }).catch(() => {});
      await queryInterface.removeColumn('Roles', 'isEditable', { transaction }).catch(() => {});
      await queryInterface.removeColumn('Roles', 'isAssignable', { transaction }).catch(() => {});

      // Remove added columns from RoleTemplates if they exist
      await queryInterface.removeColumn('RoleTemplates', 'isEditable', { transaction }).catch(() => {});
      await queryInterface.removeColumn('RoleTemplates', 'isPredefined', { transaction }).catch(() => {});

      await transaction.commit();
    } catch (error) {
      await transaction.rollback();
      throw error;
    }
  }
};

================
File: scripts/create-client.js
================
const { Client } = require('../src/models');
const crypto = require('crypto');

async function createClient(name) {
  const subdomain = name.toLowerCase().replace(/[^a-z0-9]/g, '');
  const existingClient = await Client.findOne({ where: { subdomain } });

  if (existingClient) {
    console.log(`Client with subdomain '${subdomain}' already exists.`);
    return;
  }

  const clientId = crypto.randomBytes(16).toString('hex'); // Generate a secure client ID

  const client = await Client.create({
    id: clientId,
    name,
    subdomain,
    settings: {
      theme: 'default',
      features: ['online_ordering', 'reservations'],
    },
  });

  console.log(`Created client: ${client.name} with subdomain: ${client.subdomain}`);
}

const clientName = process.argv[2];
if (!clientName) {
  console.error('Please provide a client name');
  process.exit(1);
}

createClient(clientName).catch((error) => {
  console.error('Error creating client:', error);
  process.exit(1);
});

================
File: scripts/docker-compose.yml
================
version: '3.8'

services:
  backend:
    build: 
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "5000:5000"
    environment:
      - NODE_ENV=production
    env_file: .env
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:5000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    restart: unless-stopped

  frontend:
    build: 
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "80:80"
      - "443:443"
    depends_on:
      - backend
    volumes:
      - /etc/ssl/private/nginx-selfsigned.key:/etc/nginx/ssl/nginx-selfsigned.key
      - /etc/ssl/certs/nginx-selfsigned.crt:/etc/nginx/ssl/nginx-selfsigned.crt
    restart: unless-stopped

  db:
    image: postgres:14-alpine
    environment:
      - POSTGRES_DB=${DB_NAME}
      - POSTGRES_USER=${DB_USER}
      - POSTGRES_PASSWORD=${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER} -d ${DB_NAME}"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  redis:
    image: redis:6-alpine
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:

================
File: seeders/.eslintrc.js
================
module.exports = {
  rules: {
    'no-unused-vars': ['error', { argsIgnorePattern: '^(queryInterface|Sequelize)$' }],
  },
};

================
File: seeders/02-create-clients.js
================
'use strict';

module.exports = {
  up: async (queryInterface) => {
    // ... existing code ...
  },
  down: async (queryInterface) => {
    // ... existing code ...
  }
};

================
File: seeders/03-create-roles.js
================
'use strict';

module.exports = {
  up: async (queryInterface) => {
    // ... existing code ...
  },
  down: async (queryInterface) => {
    // ... existing code ...
  }
};

================
File: seeders/04-create-super-admin.js
================
'use strict';

const bcrypt = require('bcrypt');

module.exports = {
  up: async (queryInterface) => {
    const transaction = await queryInterface.sequelize.transaction();

    try {
      // Check if Super Admin role exists
      let superAdminRole = await queryInterface.sequelize.query(
        `SELECT id FROM "Roles" WHERE name = 'Super Admin' LIMIT 1`,
        { type: queryInterface.sequelize.QueryTypes.SELECT, transaction }
      );

      let superAdminRoleId;

      if (superAdminRole.length === 0) {
        // Create Super Admin role if it doesn't exist
        [superAdminRole] = await queryInterface.bulkInsert('Roles', [{
          name: 'Super Admin',
          level: 5,
          createdAt: new Date(),
          updatedAt: new Date()
        }], { returning: true, transaction });
        superAdminRoleId = superAdminRole.id;
      } else {
        superAdminRoleId = superAdminRole[0].id;
      }

      // Check if Super Admin user exists
      const existingSuperAdmin = await queryInterface.sequelize.query(
        `SELECT id FROM "Users" WHERE username = 'superadmin' LIMIT 1`,
        { type: queryInterface.sequelize.QueryTypes.SELECT, transaction }
      );

      if (existingSuperAdmin.length === 0) {
        // Create Super Admin user if it doesn't exist
        const hashedPassword = await bcrypt.hash('Brycer23@$', 10);

        await queryInterface.bulkInsert('Users', [{
          username: 'superadmin',
          email: 'superadmin@yourdomain.com',
          password: hashedPassword,
          roleId: superAdminRoleId,
          firstName: 'Super',
          lastName: 'Admin',
          active: true,
          createdAt: new Date(),
          updatedAt: new Date()
        }], { transaction });

        console.log('Super Admin user created successfully');
      } else {
        console.log('Super Admin user already exists');
      }

      await transaction.commit();
    } catch (error) {
      await transaction.rollback();
      console.error('Error in Super Admin creation:', error);
      throw error;
    }
  },

  down: async (queryInterface) => {
    const transaction = await queryInterface.sequelize.transaction();

    try {
      // Remove Super Admin user
      await queryInterface.bulkDelete('Users', { username: 'superadmin' }, { transaction });

      // Remove Super Admin role
      await queryInterface.bulkDelete('Roles', { name: 'Super Admin' }, { transaction });

      await transaction.commit();
      console.log('Super Admin user and role removed successfully');
    } catch (error) {
      await transaction.rollback();
      console.error('Error removing Super Admin user and role:', error);
      throw error;
    }
  }
};

================
File: seeders/05-create-demo-enterprise.js
================
'use strict';

const faker = require('faker');

module.exports = {
  up: async (queryInterface) => {
    const transaction = await queryInterface.sequelize.transaction();

    try {
      // Check if Demo Enterprise client already exists
      let [enterpriseClient] = await queryInterface.sequelize.query(
        `SELECT id FROM "Clients" WHERE subdomain = 'demo-enterprise' LIMIT 1`,
        { type: queryInterface.sequelize.QueryTypes.SELECT, transaction }
      );

      let clientId;

      if (!enterpriseClient) {
        // Create demo enterprise client if it doesn't exist
        [enterpriseClient] = await queryInterface.bulkInsert('Clients', [{
          name: 'Demo Enterprise',
          subdomain: 'demo-enterprise',
          email: 'admin@demo-enterprise.com',
          features: JSON.stringify({ feature1: true, feature2: true, feature3: true }),
          active: true,
          settings: JSON.stringify({
            timezone: 'America/Los_Angeles',
            currency: 'USD',
          }),
          brandingOptions: JSON.stringify({
            primaryColor: '#4a90e2',
            secondaryColor: '#50e3c2',
            logo: 'demo_enterprise_logo.png',
          }),
          clientSettings: JSON.stringify({
            allowNotifications: true,
            defaultLanguage: 'en',
          }),
          createdAt: new Date(),
          updatedAt: new Date()
        }], { returning: true, transaction });

        clientId = enterpriseClient.id;
      } else {
        clientId = enterpriseClient.id;
      }

      // Create roles if they don't exist
      const roles = ['Enterprise Admin', 'Location Manager', 'Staff'];
      for (const role of roles) {
        await queryInterface.bulkInsert('Roles', [{
          name: role,
          clientId,
          createdAt: new Date(),
          updatedAt: new Date()
        }], { ignoreDuplicates: true, transaction });
      }

      // Create 10 locations in Las Vegas if they don't exist
      const lasVegasZipCodes = ['89101', '89102', '89103', '89104', '89105', '89106', '89107', '89108', '89109', '89110'];
      for (let i = 0; i < 10; i++) {
        await queryInterface.bulkInsert('Locations', [{
          clientId,
          name: `Las Vegas Location ${i + 1}`,
          address: faker.address.streetAddress(),
          city: 'Las Vegas',
          state: 'NV',
          zipCode: lasVegasZipCodes[i],
          phone: faker.phone.phoneNumber(),
          email: `lasvegas${i + 1}@demo-enterprise.com`,
          createdAt: new Date(),
          updatedAt: new Date()
        }], { ignoreDuplicates: true, transaction });
      }

      // Create PosIntegrationSettings for FAKE Toast POS if it doesn't exist
      let [posIntegrationSettings] = await queryInterface.sequelize.query(
        `SELECT id FROM "PosIntegrationSettings" WHERE name = 'FAKE Toast POS Settings' LIMIT 1`,
        { type: queryInterface.sequelize.QueryTypes.SELECT, transaction }
      );

      if (!posIntegrationSettings) {
        [posIntegrationSettings] = await queryInterface.bulkInsert('PosIntegrationSettings', [{
          name: 'FAKE Toast POS Settings',
          type: 'TOAST',
          settings: JSON.stringify({
            apiKey: faker.datatype.uuid(),
            apiSecret: faker.datatype.uuid(),
            restaurantGuid: faker.datatype.uuid(),
            baseUrl: 'https://api.toasttab.com/v1'
          }),
          createdAt: new Date(),
          updatedAt: new Date()
        }], { returning: true, transaction });
      }

      // Create Fake Toast POS profile as a CorePOSProfile if it doesn't exist
      await queryInterface.bulkInsert('CorePOSProfiles', [{
        profileName: 'FAKE Toast POS',
        integrationSettingsId: posIntegrationSettings.id,
        defaultAPISettings: JSON.stringify({
          baseUrl: 'https://api.toasttab.com/v1',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ${apiKey}'
          }
        }),
        translationMapping: JSON.stringify({
          orderId: 'externalOrderId',
          items: 'orderItems',
          total: 'totalAmount',
        }),
        hardcodedSettings: JSON.stringify({
          posProvider: 'Toast',
          version: '1.0'
        }),
        isActive: true,
        createdAt: new Date(),
        updatedAt: new Date()
      }], { ignoreDuplicates: true, transaction });

      // Create loyalty program if it doesn't exist
      await queryInterface.bulkInsert('LoyaltyPrograms', [{
        clientId,
        name: 'Demo Loyalty Program',
        pointsPerDollar: 10,
        createdAt: new Date(),
        updatedAt: new Date()
      }], { ignoreDuplicates: true, transaction });

      // Create sample guests and their profiles
      for (let i = 0; i < 100; i++) {
        const guestId = faker.datatype.uuid();
        await queryInterface.bulkInsert('Guests', [{
          id: guestId,
          clientId,
          firstName: faker.name.firstName(),
          lastName: faker.name.lastName(),
          email: faker.internet.email(),
          phone: faker.phone.phoneNumber(),
          createdAt: new Date(),
          updatedAt: new Date()
        }], { ignoreDuplicates: true, transaction });

        await queryInterface.bulkInsert('GuestProfiles', [{
          guestId,
          loyaltyPoints: faker.datatype.number({ min: 0, max: 1000 }),
          totalSpent: faker.datatype.float({ min: 0, max: 1000, precision: 0.01 }),
          lastVisit: faker.date.past(),
          createdAt: new Date(),
          updatedAt: new Date()
        }], { ignoreDuplicates: true, transaction });
      }

      // Create sample orders
      const locations = await queryInterface.sequelize.query(
        `SELECT id FROM "Locations" WHERE "clientId" = :clientId`,
        { 
          replacements: { clientId },
          type: queryInterface.sequelize.QueryTypes.SELECT,
          transaction
        }
      );

      const guests = await queryInterface.sequelize.query(
        `SELECT id FROM "Guests" WHERE "clientId" = :clientId LIMIT 100`,
        { 
          replacements: { clientId },
          type: queryInterface.sequelize.QueryTypes.SELECT,
          transaction
        }
      );

      for (let i = 0; i < 500; i++) {
        const orderId = faker.datatype.uuid();
        const locationId = locations[faker.datatype.number({ min: 0, max: locations.length - 1 })].id;
        const guestId = guests[faker.datatype.number({ min: 0, max: guests.length - 1 })].id;
        const orderTotal = faker.datatype.float({ min: 10, max: 200, precision: 0.01 });

        await queryInterface.bulkInsert('Orders', [{
          id: orderId,
          clientId,
          locationId,
          guestId,
          orderNumber: faker.random.alphaNumeric(8).toUpperCase(),
          status: faker.random.arrayElement(['pending', 'completed', 'cancelled']),
          total: orderTotal,
          createdAt: faker.date.past(),
          updatedAt: new Date()
        }], { ignoreDuplicates: true, transaction });

        // Create 1-5 order items for each order
        const itemCount = faker.datatype.number({ min: 1, max: 5 });
        for (let j = 0; j < itemCount; j++) {
          await queryInterface.bulkInsert('OrderItems', [{
            orderId,
            name: faker.commerce.productName(),
            price: faker.datatype.float({ min: 5, max: 50, precision: 0.01 }),
            quantity: faker.datatype.number({ min: 1, max: 5 }),
            createdAt: new Date(),
            updatedAt: new Date()
          }], { ignoreDuplicates: true, transaction });
        }

        // Simulate POS integration by creating an audit log entry
        const posData = {
          orderId,
          total: orderTotal,
          guestId,
          locationId
        };

        await queryInterface.bulkInsert('AuditLogs', [{
          action: 'POS_ORDER_SENT',
          details: JSON.stringify(posData),
          userId: null, // Since this is a system action
          clientId,
          createdAt: new Date(),
          updatedAt: new Date()
        }], { ignoreDuplicates: true, transaction });
      }

      await transaction.commit();
      console.log('Demo Enterprise data created successfully');
    } catch (error) {
      await transaction.rollback();
      console.error('Error creating Demo Enterprise data:', error);
      throw error;
    }
  },

  down: async (queryInterface) => {
    const transaction = await queryInterface.sequelize.transaction();

    try {
      const [enterpriseClient] = await queryInterface.sequelize.query(
        `SELECT id FROM "Clients" WHERE subdomain = 'demo-enterprise' LIMIT 1`,
        { type: queryInterface.sequelize.QueryTypes.SELECT, transaction }
      );

      if (enterpriseClient) {
        const clientId = enterpriseClient.id;

        // Remove all data related to Demo Enterprise
        await queryInterface.bulkDelete('AuditLogs', { clientId }, { transaction });
        await queryInterface.bulkDelete('OrderItems', { orderId: Sequelize.literal(`(SELECT id FROM "Orders" WHERE "clientId" = ${clientId})`) }, { transaction });
        await queryInterface.bulkDelete('Orders', { clientId }, { transaction });
        await queryInterface.bulkDelete('GuestProfiles', { guestId: Sequelize.literal(`(SELECT id FROM "Guests" WHERE "clientId" = ${clientId})`) }, { transaction });
        await queryInterface.bulkDelete('Guests', { clientId }, { transaction });
        await queryInterface.bulkDelete('LoyaltyPrograms', { clientId }, { transaction });
        await queryInterface.bulkDelete('Locations', { clientId }, { transaction });
        await queryInterface.bulkDelete('Roles', { clientId }, { transaction });
        await queryInterface.bulkDelete('Clients', { id: clientId }, { transaction });
      }

      // Remove POS related data
      await queryInterface.bulkDelete('CorePOSProfiles', { profileName: 'FAKE Toast POS' }, { transaction });
      await queryInterface.bulkDelete('PosIntegrationSettings', { name: 'FAKE Toast POS Settings' }, { transaction });

      await transaction.commit();
      console.log('Demo Enterprise data removed successfully');
    } catch (error) {
      await transaction.rollback();
      console.error('Error removing Demo Enterprise data:', error);
      throw error;
    }
  }
};

================
File: seeders/20230101000000-demo-data.js
================
'use strict';
const bcrypt = require('bcrypt');

module.exports = {
  up: async (queryInterface, Sequelize) => {
    const hashedPassword = await bcrypt.hash('password123', 10);

    // Insert Client
    const [client] = await queryInterface.bulkInsert('Clients', [{
      name: 'Demo Client',
      createdAt: new Date(),
      updatedAt: new Date()
    }], { returning: true });

    // Insert ClientSettings
    await queryInterface.bulkInsert('ClientSettings', [{
      clientId: client.id,
      twoFactorRequired: false,
      defaultPaymentGateways: JSON.stringify(['stripe', 'paypal']),
      createdAt: new Date(),
      updatedAt: new Date()
    }]);

    // Insert Users
    await queryInterface.bulkInsert('Users', [
      {
        name: 'Admin User',
        email: 'admin@example.com',
        password: hashedPassword,
        role: 'clientAdmin',
        clientId: client.id,
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        name: 'Manager User',
        email: 'manager@example.com',
        password: hashedPassword,
        role: 'manager',
        clientId: client.id,
        createdAt: new Date(),
        updatedAt: new Date()
      }
    ]);

    // Insert Locations
    await queryInterface.bulkInsert('Locations', [
      {
        name: 'Main Store',
        address: '123 Main St, City, State 12345',
        clientId: client.id,
        twoFactorException: false,
        paymentGatewayExceptions: null,
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        name: 'Branch Store',
        address: '456 Branch St, City, State 12345',
        clientId: client.id,
        twoFactorException: true,
        paymentGatewayExceptions: JSON.stringify(['stripe']),
        createdAt: new Date(),
        updatedAt: new Date()
      }
    ]);

    // Add more seed data for other models as needed...
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.bulkDelete('Users', null, {});
    await queryInterface.bulkDelete('ClientSettings', null, {});
    await queryInterface.bulkDelete('Locations', null, {});
    await queryInterface.bulkDelete('Clients', null, {});
    // Remove seed data for other models...
  }
};

================
File: src/adapters/pos/RevelPOSAdapter.js
================
export class RevelPOSAdapter {
  constructor(private apiKey) {}

  async getDiscounts() {
    // Implement Revel-specific API call to get discounts
    // Return discounts in a standardized format
  }
}

================
File: src/adapters/pos/ToastPOSAdapter.js
================
export class ToastPOSAdapter {
  constructor(private apiKey) {}

  async getDiscounts() {
    // Implement Toast-specific API call to get discounts
    // Return discounts in a standardized format
  }
}

================
File: src/config/config.json
================
{
  "development": {
    "username": "bryce",
    "password": "1234",
    "database": "pos",
    "host": "db",
    "dialect": "postgres"
  },
  "test": {
    "username": "root",
    "password": null,
    "database": "database_test",
    "host": "127.0.0.1",
    "dialect": "postgres"
  },
  "production": {
    "username": "root",
    "password": null,
    "database": "database_production",
    "host": "127.0.0.1",
    "dialect": "postgres"
  }
}

================
File: src/config/database.js
================
const { Sequelize } = require('sequelize');
require('dotenv').config();

const env = process.env.NODE_ENV || 'development';
const config = {
  development: {
    username: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    host: process.env.DB_HOST,
    dialect: 'postgres',
    logging: console.log,
  },
  test: {
    // ... (keep existing test configuration)
  },
  production: {
    // ... (keep existing production configuration)
  }
};

const sequelize = new Sequelize(config[env].database, config[env].username, config[env].password, config[env]);

module.exports = sequelize;

================
File: src/config/redis.js
================
const Redis = require('ioredis');

const redisClient = new Redis({
  host: process.env.REDIS_HOST || 'localhost',
  port: process.env.REDIS_PORT || 6379,
  // Add any other configuration options here
});

module.exports = redisClient;

================
File: src/controllers/abTestController.js
================
const { validationResult } = require('express-validator');
const abTestService = require('../services/abTestService');
const logger = require('../utils/logger');
const { AppError } = require('../utils/errorHandler');

const validateRequest = (req) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    throw new AppError('Validation failed', 400, errors.array());
  }
};

const createABTest = async (req, res, next) => {
  try {
    validateRequest(req);
    const abTest = await abTestService.createABTest(req.body);
    logger.info(`A/B Test created with ID: ${abTest.id}`);
    res.status(201).json(abTest);
  } catch (error) {
    logger.error('Error creating A/B Test:', error);
    next(error);
  }
};

const getABTest = async (req, res, next) => {
  try {
    const abTest = await abTestService.getABTest(req.params.id);
    if (!abTest) {
      throw new AppError('A/B Test not found', 404);
    }
    res.json(abTest);
  } catch (error) {
    logger.error(`Error fetching A/B Test with ID ${req.params.id}:`, error);
    next(error);
  }
};

const updateABTest = async (req, res, next) => {
  try {
    validateRequest(req);
    const updatedABTest = await abTestService.updateABTest(req.params.id, req.body);
    logger.info(`A/B Test updated with ID: ${req.params.id}`);
    res.json(updatedABTest);
  } catch (error) {
    logger.error(`Error updating A/B Test with ID ${req.params.id}:`, error);
    next(error);
  }
};

const deleteABTest = async (req, res, next) => {
  try {
    await abTestService.deleteABTest(req.params.id);
    logger.info(`A/B Test deleted with ID: ${req.params.id}`);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting A/B Test with ID ${req.params.id}:`, error);
    next(error);
  }
};

const getABTestResults = async (req, res, next) => {
  try {
    const results = await abTestService.getABTestResults(req.params.id);
    res.json(results);
  } catch (error) {
    logger.error(`Error fetching A/B Test results for ID ${req.params.id}:`, error);
    next(error);
  }
};

const startABTest = async (req, res, next) => {
  try {
    const startedTest = await abTestService.startABTest(req.params.id);
    logger.info(`A/B Test started with ID: ${req.params.id}`);
    res.json(startedTest);
  } catch (error) {
    logger.error(`Error starting A/B Test with ID ${req.params.id}:`, error);
    next(error);
  }
};

const stopABTest = async (req, res, next) => {
  try {
    const stoppedTest = await abTestService.stopABTest(req.params.id);
    logger.info(`A/B Test stopped with ID: ${req.params.id}`);
    res.json(stoppedTest);
  } catch (error) {
    logger.error(`Error stopping A/B Test with ID ${req.params.id}:`, error);
    next(error);
  }
};

module.exports = {
  createABTest,
  getABTest,
  updateABTest,
  deleteABTest,
  getABTestResults,
  startABTest,
  stopABTest
};

================
File: src/controllers/abTestController.ts
================
import { Request, Response } from 'express';
import { createABTest, getABTests, updateABTest, deleteABTest, checkAndUpdateABTests } from '../services/abTestService';
import { AppError } from '../utils/errorHandler';
import { trackABTestMetric, getABTestMetrics } from '../services/abTestMetricsService';

export const createTest = async (req: Request, res: Response) => {
  try {
    const test = await createABTest(req.body);
    res.status(201).json(test);
  } catch (error) {
    if (error instanceof AppError) {
      res.status(error.statusCode).json({ message: error.message });
    } else {
      res.status(500).json({ message: 'Error creating A/B test' });
    }
  }
};

export const getTests = async (req: Request, res: Response) => {
  try {
    const tests = await getABTests();
    res.status(200).json(tests);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching A/B tests' });
  }
};

export const updateTest = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const test = await updateABTest(id, req.body);
    res.status(200).json(test);
  } catch (error) {
    if (error instanceof AppError) {
      res.status(error.statusCode).json({ message: error.message });
    } else {
      res.status(500).json({ message: 'Error updating A/B test' });
    }
  }
};

export const deleteTest = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    await deleteABTest(id);
    res.status(204).send();
  } catch (error) {
    if (error instanceof AppError) {
      res.status(error.statusCode).json({ message: error.message });
    } else {
      res.status(500).json({ message: 'Error deleting A/B test' });
    }
  }
};

export const checkAndUpdateTests = async (req: Request, res: Response) => {
  try {
    const updatedTests = await checkAndUpdateABTests();
    res.status(200).json(updatedTests);
  } catch (error) {
    res.status(500).json({ message: 'Error checking and updating A/B tests' });
  }
};

export const trackMetric = async (req: Request, res: Response) => {
  try {
    const { testId, variant, metricType, value } = req.body;
    const metric = await trackABTestMetric(testId, variant, metricType, value);
    res.status(201).json(metric);
  } catch (error) {
    res.status(500).json({ message: 'Error tracking A/B test metric' });
  }
};

export const getMetrics = async (req: Request, res: Response) => {
  try {
    const { testId } = req.params;
    const metrics = await getABTestMetrics(testId);
    res.status(200).json(metrics);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching A/B test metrics' });
  }
};

================
File: src/controllers/abTestResultController.js
================
const { ABTestResult, Modifier, MenuItem } = require('../models');

exports.getAllABTestResults = async (req, res) => {
  try {
    const abTestResults = await ABTestResult.findAll({
      include: [{ model: Modifier }, { model: MenuItem }]
    });
    res.json(abTestResults);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching AB test results', error: error.message });
  }
};

exports.createABTestResult = async (req, res) => {
  try {
    const newABTestResult = await ABTestResult.create(req.body);
    res.status(201).json(newABTestResult);
  } catch (error) {
    res.status(400).json({ message: 'Error creating AB test result', error: error.message });
  }
};

exports.getABTestResult = async (req, res) => {
  try {
    const abTestResult = await ABTestResult.findByPk(req.params.id, {
      include: [{ model: Modifier }, { model: MenuItem }]
    });
    if (abTestResult) {
      res.json(abTestResult);
    } else {
      res.status(404).json({ message: 'AB test result not found' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Error fetching AB test result', error: error.message });
  }
};

exports.updateABTestResult = async (req, res) => {
  try {
    const [updated] = await ABTestResult.update(req.body, {
      where: { id: req.params.id }
    });
    if (updated) {
      const updatedABTestResult = await ABTestResult.findByPk(req.params.id, {
        include: [{ model: Modifier }, { model: MenuItem }]
      });
      res.json(updatedABTestResult);
    } else {
      res.status(404).json({ message: 'AB test result not found' });
    }
  } catch (error) {
    res.status(400).json({ message: 'Error updating AB test result', error: error.message });
  }
};

exports.deleteABTestResult = async (req, res) => {
  try {
    const deleted = await ABTestResult.destroy({
      where: { id: req.params.id }
    });
    if (deleted) {
      res.status(204).send();
    } else {
      res.status(404).json({ message: 'AB test result not found' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Error deleting AB test result', error: error.message });
  }
};

================
File: src/controllers/adminController.js
================
const { validationResult } = require('express-validator');
const adminService = require('../services/adminService');
const dashboardService = require('../services/dashboardService');
const logger = require('../utils/logger');
const { AppError } = require('../utils/errorHandler');

const validateRequest = (req) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    throw new AppError('Validation failed', 400, errors.array());
  }
};

const getDashboardData = async (req, res, next) => {
  try {
    const dashboardData = await dashboardService.getDashboardData();
    res.status(200).json(dashboardData);
  } catch (error) {
    logger.error('Error fetching dashboard data:', error);
    next(new AppError('Error fetching dashboard data', 500));
  }
};

const getUsers = async (req, res, next) => {
  try {
    const users = await adminService.getUsers(req.query);
    res.status(200).json(users);
  } catch (error) {
    logger.error('Error fetching users:', error);
    next(new AppError('Error fetching users', 500));
  }
};

const createUser = async (req, res, next) => {
  try {
    validateRequest(req);
    const newUser = await adminService.createUser(req.body);
    logger.info(`New user created: ${newUser.id}`);
    res.status(201).json(newUser);
  } catch (error) {
    logger.error('Error creating user:', error);
    next(error);
  }
};

const updateUser = async (req, res, next) => {
  try {
    validateRequest(req);
    const updatedUser = await adminService.updateUser(req.params.id, req.body);
    logger.info(`User updated: ${req.params.id}`);
    res.status(200).json(updatedUser);
  } catch (error) {
    logger.error(`Error updating user ${req.params.id}:`, error);
    next(error);
  }
};

const deleteUser = async (req, res, next) => {
  try {
    await adminService.deleteUser(req.params.id);
    logger.info(`User deleted: ${req.params.id}`);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting user ${req.params.id}:`, error);
    next(error);
  }
};

const getSystemLogs = async (req, res, next) => {
  try {
    const logs = await adminService.getSystemLogs(req.query);
    res.status(200).json(logs);
  } catch (error) {
    logger.error('Error fetching system logs:', error);
    next(new AppError('Error fetching system logs', 500));
  }
};

const getSystemHealth = async (req, res, next) => {
  try {
    const healthData = await adminService.getSystemHealth();
    res.status(200).json(healthData);
  } catch (error) {
    logger.error('Error fetching system health:', error);
    next(new AppError('Error fetching system health', 500));
  }
};

const backupDatabase = async (req, res, next) => {
  try {
    const backupResult = await adminService.backupDatabase();
    logger.info('Database backup initiated');
    res.status(200).json(backupResult);
  } catch (error) {
    logger.error('Error initiating database backup:', error);
    next(new AppError('Error initiating database backup', 500));
  }
};

const restoreDatabase = async (req, res, next) => {
  try {
    validateRequest(req);
    const restoreResult = await adminService.restoreDatabase(req.body.backupId);
    logger.info(`Database restore initiated from backup: ${req.body.backupId}`);
    res.status(200).json(restoreResult);
  } catch (error) {
    logger.error('Error initiating database restore:', error);
    next(new AppError('Error initiating database restore', 500));
  }
};

module.exports = {
  getDashboardData,
  getUsers,
  createUser,
  updateUser,
  deleteUser,
  getSystemLogs,
  getSystemHealth,
  backupDatabase,
  restoreDatabase
};

================
File: src/controllers/analyticsController.js
================
const { Request, Response } = require('express');
const { getRevenueData, getCustomerMetrics, getRealtimeMetrics } = require('../services/analyticsService');
const { AppError } = require('../utils/errorHandler');
const cacheMiddleware = require('../middleware/cache'); // Changed this line
const { Order, Guest } = require('../models');

const getOrderAnalytics = async (req, res) => {
  try {
    const startDate = new Date(req.query.start);
    const endDate = new Date(req.query.end);

    const orders = await Order.find({
      createdAt: { $gte: startDate, $lte: endDate }
    });

    // Process orders data for Grafana
    const processedData = orders.map(order => ({
      timestamp: order.createdAt,
      total: order.total,
      // Add other relevant fields
    }));

    res.json(processedData);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching order analytics' });
  }
};

const getGuestAnalytics = async (req, res) => {
  try {
    const guests = await Guest.find();

    // Process guest data for Grafana
    const processedData = guests.map(guest => ({
      id: guest.id,
      loyaltyPoints: guest.loyaltyPoints,
      totalOrders: guest.orders.length,
      // Add other relevant fields
    }));

    res.json(processedData);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching guest analytics' });
  }
};

const getRevenue = async (req, res) => {
  try {
    const { startDate, endDate } = req.query;
    if (!startDate || !endDate) {
      throw new AppError('Start date and end date are required', 400);
    }
    const revenue = await getRevenueData(new Date(startDate), new Date(endDate));
    res.json(revenue);
  } catch (error) {
    if (error instanceof AppError) {
      res.status(error.statusCode).json({ message: error.message });
    } else {
      res.status(500).json({ message: 'Error fetching revenue data' });
    }
  }
};

const getCustomers = async (req, res) => {
  try {
    const metrics = await getCustomerMetrics();
    res.json(metrics);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching customer metrics' });
  }
};

const getRealtimeMetricsController = [
  cacheMiddleware(60), // Cache for 1 minute
  async (req, res) => {
    try {
      const metrics = await getRealtimeMetrics();
      res.json(metrics);
    } catch (error) {
      res.status(500).json({ message: 'Error fetching realtime metrics' });
    }
  }
];

module.exports = {
  getOrderAnalytics,
  getGuestAnalytics,
  getRevenue,
  getCustomers,
  getRealtimeMetricsController
};

================
File: src/controllers/analyticsController.ts
================
import express from 'express';
import { getRevenueData, getCustomerMetrics, getRealtimeMetricsData } from '../services/analyticsService';
import { AppError } from '../utils/errorHandler';
import { cacheMiddleware } from '../middleware/cache';
import OrderModel from '../models/Order';
import GuestModel from '../models/Guest';

export const getOrderAnalytics = async (req: express.Request, res: express.Response) => {
  try {
    const startDate = new Date(req.query.start as string);
    const endDate = new Date(req.query.end as string);

    const orders = await OrderModel.find({
      createdAt: { $gte: startDate, $lte: endDate }
    });

    // Process orders data as needed for Grafana
    const processedData = orders.map(order => ({
      timestamp: order.createdAt,
      total: order.total,
      // Add other relevant fields
    }));

    res.json(processedData);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching order analytics' });
  }
};

export const getGuestAnalytics = async (req: express.Request, res: express.Response) => {
  try {
    const guests = await GuestModel.find();

    // Process guest data as needed for Grafana
    const processedData = guests.map(guest => ({
      id: guest.id,
      loyaltyPoints: guest.loyaltyPoints,
      totalOrders: guest.orders.length,
      // Add other relevant fields
    }));

    res.json(processedData);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching guest analytics' });
  }
};

export const getRevenue = async (req: express.Request, res: express.Response) => {
  try {
    const { startDate, endDate } = req.query;
    if (!startDate || !endDate) {
      throw new AppError('Start date and end date are required', 400);
    }
    const revenue = await getRevenueData(new Date(startDate as string), new Date(endDate as string));
    res.json(revenue);
  } catch (error) {
    if (error instanceof AppError) {
      res.status(error.statusCode).json({ message: error.message });
    } else {
      res.status(500).json({ message: 'Error fetching revenue data' });
    }
  }
};

export const getCustomers = async (req: express.Request, res: express.Response) => {
  try {
    const metrics = await getCustomerMetrics();
    res.json(metrics);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching customer metrics' });
  }
};

export const getRealtimeMetricsHandler = [
  cacheMiddleware(60), // Cache for 1 minute
  async (req: express.Request, res: express.Response, next: express.NextFunction) => {
    try {
      const metrics = await getRealtimeMetricsData();
      res.json(metrics);
    } catch (error) {
      next(error);
    }
  }
];

================
File: src/controllers/assetController.js
================
const path = require('path');
const fs = require('fs').promises;
const { v4: uuidv4 } = require('uuid');
const { Asset } = require('../models');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');
const { optimizeImage } = require('../services/imageService');

const UPLOAD_DIR = path.join(__dirname, '..', '..', 'uploads');

const ensureUploadDir = async () => {
  try {
    await fs.access(UPLOAD_DIR);
  } catch {
    await fs.mkdir(UPLOAD_DIR, { recursive: true });
  }
};

const getAllAssets = async (req, res, next) => {
  try {
    const assets = await Asset.findAll({ where: { tenantId: req.user.tenantId } });
    res.status(200).json(assets);
  } catch (error) {
    logger.error('Error fetching assets:', error);
    next(new AppError('Error fetching assets', 500));
  }
};

const getAsset = async (req, res, next) => {
  try {
    const asset = await Asset.findOne({ 
      where: { id: req.params.id, tenantId: req.user.tenantId } 
    });
    if (!asset) {
      return next(new AppError('Asset not found', 404));
    }
    res.status(200).json(asset);
  } catch (error) {
    logger.error(`Error fetching asset ${req.params.id}:`, error);
    next(new AppError('Error fetching asset', 500));
  }
};

const uploadAsset = async (req, res, next) => {
  try {
    if (!req.file) {
      return next(new AppError('No file uploaded', 400));
    }

    await ensureUploadDir();

    const optimizedBuffer = await optimizeImage(req.file.buffer);
    const filename = `${uuidv4()}-${req.file.originalname}`;
    const filePath = path.join(UPLOAD_DIR, filename);

    await fs.writeFile(filePath, optimizedBuffer);

    const asset = await Asset.create({
      name: req.file.originalname,
      type: req.file.mimetype,
      url: `/uploads/${filename}`,
      size: optimizedBuffer.length,
      tenantId: req.user.tenantId
    });

    logger.info(`Asset uploaded: ${asset.id}`);
    res.status(201).json(asset);
  } catch (error) {
    logger.error('Error uploading asset:', error);
    next(new AppError('Error uploading asset', 500));
  }
};

const updateAsset = async (req, res, next) => {
  try {
    const asset = await Asset.findOne({ 
      where: { id: req.params.id, tenantId: req.user.tenantId } 
    });
    if (!asset) {
      return next(new AppError('Asset not found', 404));
    }

    const updatedAsset = await asset.update(req.body);
    logger.info(`Asset updated: ${updatedAsset.id}`);
    res.status(200).json(updatedAsset);
  } catch (error) {
    logger.error(`Error updating asset ${req.params.id}:`, error);
    next(new AppError('Error updating asset', 500));
  }
};

const deleteAsset = async (req, res, next) => {
  try {
    const asset = await Asset.findOne({ 
      where: { id: req.params.id, tenantId: req.user.tenantId } 
    });
    if (!asset) {
      return next(new AppError('Asset not found', 404));
    }

    const filePath = path.join(UPLOAD_DIR, path.basename(asset.url));
    await fs.unlink(filePath);
    await asset.destroy();

    logger.info(`Asset deleted: ${req.params.id}`);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting asset ${req.params.id}:`, error);
    next(new AppError('Error deleting asset', 500));
  }
};

module.exports = {
  getAllAssets,
  getAsset,
  uploadAsset,
  updateAsset,
  deleteAsset
};

================
File: src/controllers/auditLogController.js
================
const { Request, Response } = require 'express';
const { AuditLog } = require '../models';

const getAuditLogs = async (req, res) => {
  try {
    const { page = 1, limit = 20, startDate, endDate, userId, action } = req.query;
    const options = {
      order: [['createdAt', 'DESC']],
      limit(limit ),
      offset: (parseInt(page ) - 1) * parseInt(limit ),
    };

    if (startDate && endDate) {
      options.where = {
        ...options.where,
        createdAt: {
          [Op.between]: [new Date(startDate ), new Date(endDate )],
        },
      };
    }

    if (userId) {
      options.where = {
        ...options.where,
        userId,
      };
    }

    if (action) {
      options.where = {
        ...options.where,
        action,
      };
    }

    const logs = await AuditLog.findAndCountAll(options);

    res.json({
      logs.rows,
      totalPages.ceil(logs.count / parseInt(limit )),
      currentPage(page ),
    });
  } catch (error) {
    res.status(500).json({ message: 'Error fetching audit logs', error });
  }
};

================
File: src/controllers/authController.js
================
const { validationResult } = require('express-validator');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');
const { User } = require('../models');
const userService = require('../services/userService');
const { UnauthorizedError } = require('../utils/errors');
const Client = require('../models/Client'); // Assuming Client model is defined

const login = async (req, res) => {
  const { email, password } = req.body;
  const { subdomain } = req.params; // Assuming subdomain is passed as a route parameter

  try {
    const client = await Client.findOne({ subdomain });
    if (!client) {
      return res.status(404).json({ message: 'Client not found' });
    }

    const user = await User.findOne({ email, clientId: client._id });
    if (!user || !(await user.comparePassword(password))) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }

    const token = user.generateAuthToken();
    res.json({ user, token });
  } catch (error) {
    res.status(500).json({ message: 'Server error' });
  }
};

const register = async (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  const { username, email, password } = req.body;

  try {
    const hashedPassword = await bcrypt.hash(password, 10);
    const user = await User.create({
      username,
      email,
      password: hashedPassword
    });

    const token = jwt.sign(
      { userId: user.id, username: user.username, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: '1d' }
    );

    res.status(201).json({ token, user: { id: user.id, username: user.username, role: user.role } });
  } catch (error) {
    next(error);
  }
};

const logout = (req, res) => {
  // In a stateless JWT setup, we don't need to do anything server-side for logout
  res.json({ message: 'Logged out successfully' });
};

const getUser = async (req, res, next) => {
  try {
    const user = await User.findByPk(req.user.id, {
      attributes: { exclude: ['password'] }
    });
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    res.json(user);
  } catch (error) {
    next(error);
  }
};

const verifyPhone = async (req, res, next) => {
  // Implement phone verification logic
};

const requestLoginCode = async (req, res, next) => {
  // Implement login code request logic
};

const loginWithCode = async (req, res, next) => {
  // Implement login with code logic
};

module.exports = {
  login,
  register,
  logout,
  getUser,
  verifyPhone,
  requestLoginCode,
  loginWithCode,
};

================
File: src/controllers/brandingController.js
================
const brandingService = require('../services/brandingService');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const getBrandingProfiles = async (req, res, next) => {
  try {
    const { clientId } = req.params;
    const profiles = await brandingService.getBrandingProfiles(clientId);
    res.status(200).json(profiles);
  } catch (error) {
    logger.error(`Error fetching branding profiles for client ${req.params.clientId}:`, error);
    next(new AppError('Error fetching branding profiles', 500));
  }
};

const getBrandingProfileById = async (req, res, next) => {
  try {
    const { id } = req.params;
    const profile = await brandingService.getBrandingProfileById(id);
    if (!profile) {
      return next(new AppError('Branding profile not found', 404));
    }
    res.status(200).json(profile);
  } catch (error) {
    logger.error(`Error fetching branding profile ${req.params.id}:`, error);
    next(new AppError('Error fetching branding profile', 500));
  }
};

const createBrandingProfile = async (req, res, next) => {
  try {
    const newProfile = await brandingService.createBrandingProfile(req.body);
    logger.info(`New branding profile created: ${newProfile.id}`);
    res.status(201).json(newProfile);
  } catch (error) {
    logger.error('Error creating branding profile:', error);
    next(new AppError('Error creating branding profile', 500));
  }
};

const updateBrandingProfile = async (req, res, next) => {
  try {
    const { id } = req.params;
    const updatedProfile = await brandingService.updateBrandingProfile(id, req.body);
    if (!updatedProfile) {
      return next(new AppError('Branding profile not found', 404));
    }
    logger.info(`Branding profile updated: ${id}`);
    res.status(200).json(updatedProfile);
  } catch (error) {
    logger.error(`Error updating branding profile ${req.params.id}:`, error);
    next(new AppError('Error updating branding profile', 500));
  }
};

const deleteBrandingProfile = async (req, res, next) => {
  try {
    const { id } = req.params;
    await brandingService.deleteBrandingProfile(id);
    logger.info(`Branding profile deleted: ${id}`);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting branding profile ${req.params.id}:`, error);
    next(new AppError('Error deleting branding profile', 500));
  }
};

module.exports = {
  getBrandingProfiles,
  getBrandingProfileById,
  createBrandingProfile,
  updateBrandingProfile,
  deleteBrandingProfile
};

================
File: src/controllers/brandingProfileController.js
================
const { BrandingProfile } = require('../models');

exports.getBrandingProfile = async (req, res) => {
  try {
    const brandingProfile = await BrandingProfile.findOne({ where: { clientId: req.user.clientId } });
    if (brandingProfile) {
      res.json(brandingProfile);
    } else {
      res.status(404).json({ message: 'Branding profile not found' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Error fetching branding profile', error: error.message });
  }
};

exports.createBrandingProfile = async (req, res) => {
  try {
    const newBrandingProfile = await BrandingProfile.create({ ...req.body, clientId: req.user.clientId });
    res.status(201).json(newBrandingProfile);
  } catch (error) {
    res.status(400).json({ message: 'Error creating branding profile', error: error.message });
  }
};

exports.updateBrandingProfile = async (req, res) => {
  try {
    const [updated] = await BrandingProfile.update(req.body, {
      where: { clientId: req.user.clientId }
    });
    if (updated) {
      const updatedBrandingProfile = await BrandingProfile.findOne({ where: { clientId: req.user.clientId } });
      res.json(updatedBrandingProfile);
    } else {
      res.status(404).json({ message: 'Branding profile not found' });
    }
  } catch (error) {
    res.status(400).json({ message: 'Error updating branding profile', error: error.message });
  }
};

exports.deleteBrandingProfile = async (req, res) => {
  try {
    const deleted = await BrandingProfile.destroy({
      where: { clientId: req.user.clientId }
    });
    if (deleted) {
      res.status(204).send();
    } else {
      res.status(404).json({ message: 'Branding profile not found' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Error deleting branding profile', error: error.message });
  }
};

================
File: src/controllers/campaignResultController.js
================
const campaignResultService = require('../services/campaignResultService');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const getAllCampaignResults = async (req, res, next) => {
  try {
    const results = await campaignResultService.getAllCampaignResults();
    res.status(200).json(results);
  } catch (error) {
    logger.error('Error fetching campaign results:', error);
    next(new AppError('Error fetching campaign results', 500));
  }
};

const getCampaignResultById = async (req, res, next) => {
  try {
    const result = await campaignResultService.getCampaignResultById(req.params.id);
    if (!result) {
      return next(new AppError('Campaign result not found', 404));
    }
    res.status(200).json(result);
  } catch (error) {
    logger.error(`Error fetching campaign result ${req.params.id}:`, error);
    next(new AppError('Error fetching campaign result', 500));
  }
};

const createCampaignResult = async (req, res, next) => {
  try {
    const newResult = await campaignResultService.createCampaignResult(req.body);
    res.status(201).json(newResult);
  } catch (error) {
    logger.error('Error creating campaign result:', error);
    next(new AppError('Error creating campaign result', 500));
  }
};

const updateCampaignResult = async (req, res, next) => {
  try {
    const updatedResult = await campaignResultService.updateCampaignResult(req.params.id, req.body);
    if (!updatedResult) {
      return next(new AppError('Campaign result not found', 404));
    }
    res.status(200).json(updatedResult);
  } catch (error) {
    logger.error(`Error updating campaign result ${req.params.id}:`, error);
    next(new AppError('Error updating campaign result', 500));
  }
};

const deleteCampaignResult = async (req, res, next) => {
  try {
    const deleted = await campaignResultService.deleteCampaignResult(req.params.id);
    if (!deleted) {
      return next(new AppError('Campaign result not found', 404));
    }
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting campaign result ${req.params.id}:`, error);
    next(new AppError('Error deleting campaign result', 500));
  }
};

module.exports = {
  getAllCampaignResults,
  getCampaignResultById,
  createCampaignResult,
  updateCampaignResult,
  deleteCampaignResult
};

================
File: src/controllers/campaignStepController.js
================
const { CampaignStep } = require('../models');

exports.getAllCampaignSteps = async (req, res) => {
  try {
    const campaignSteps = await CampaignStep.findAll();
    res.json(campaignSteps);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching campaign steps', error: error.message });
  }
};

exports.createCampaignStep = async (req, res) => {
  try {
    const newCampaignStep = await CampaignStep.create(req.body);
    res.status(201).json(newCampaignStep);
  } catch (error) {
    res.status(400).json({ message: 'Error creating campaign step', error: error.message });
  }
};

exports.getCampaignStep = async (req, res) => {
  try {
    const campaignStep = await CampaignStep.findByPk(req.params.id);
    if (campaignStep) {
      res.json(campaignStep);
    } else {
      res.status(404).json({ message: 'Campaign step not found' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Error fetching campaign step', error: error.message });
  }
};

exports.updateCampaignStep = async (req, res) => {
  try {
    const [updated] = await CampaignStep.update(req.body, {
      where: { id: req.params.id }
    });
    if (updated) {
      const updatedCampaignStep = await CampaignStep.findByPk(req.params.id);
      res.json(updatedCampaignStep);
    } else {
      res.status(404).json({ message: 'Campaign step not found' });
    }
  } catch (error) {
    res.status(400).json({ message: 'Error updating campaign step', error: error.message });
  }
};

exports.deleteCampaignStep = async (req, res) => {
  try {
    const deleted = await CampaignStep.destroy({
      where: { id: req.params.id }
    });
    if (deleted) {
      res.status(204).send();
    } else {
      res.status(404).json({ message: 'Campaign step not found' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Error deleting campaign step', error: error.message });
  }
};

================
File: src/controllers/categoryController.js
================
const categoryService = require('../services/categoryService');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const getAllCategories = async (req, res, next) => {
  try {
    const categories = await categoryService.getAllCategories(req.user.clientId);
    res.status(200).json(categories);
  } catch (error) {
    logger.error('Error fetching categories:', error);
    next(new AppError('Error fetching categories', 500));
  }
};

const getCategoryById = async (req, res, next) => {
  try {
    const category = await categoryService.getCategoryById(req.params.id, req.user.clientId);
    res.status(200).json(category);
  } catch (error) {
    logger.error(`Error fetching category ${req.params.id}:`, error);
    next(error);
  }
};

const createCategory = async (req, res, next) => {
  try {
    const newCategory = await categoryService.createCategory(req.body, req.user.clientId);
    res.status(201).json(newCategory);
  } catch (error) {
    logger.error('Error creating category:', error);
    next(error);
  }
};

const updateCategory = async (req, res, next) => {
  try {
    const updatedCategory = await categoryService.updateCategory(req.params.id, req.body, req.user.clientId);
    res.status(200).json(updatedCategory);
  } catch (error) {
    logger.error(`Error updating category ${req.params.id}:`, error);
    next(error);
  }
};

const deleteCategory = async (req, res, next) => {
  try {
    await categoryService.deleteCategory(req.params.id, req.user.clientId);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting category ${req.params.id}:`, error);
    next(error);
  }
};

module.exports = {
  getAllCategories,
  getCategoryById,
  createCategory,
  updateCategory,
  deleteCategory
};

================
File: src/controllers/cateringAdminController.js
================
const { CateringAdmin, User, Location } = require('../models');

exports.getAllCateringAdmins = async (req, res) => {
  try {
    const cateringAdmins = await CateringAdmin.findAll({
      include: [
        { model: User, attributes: ['id', 'name', 'email'] },
        { model: Location, attributes: ['id', 'name'] }
      ]
    });
    res.json(cateringAdmins);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching catering admins', error: error.message });
  }
};

exports.createCateringAdmin = async (req, res) => {
  try {
    const newCateringAdmin = await CateringAdmin.create(req.body);
    res.status(201).json(newCateringAdmin);
  } catch (error) {
    res.status(400).json({ message: 'Error creating catering admin', error: error.message });
  }
};

exports.getCateringAdmin = async (req, res) => {
  try {
    const cateringAdmin = await CateringAdmin.findByPk(req.params.id, {
      include: [
        { model: User, attributes: ['id', 'name', 'email'] },
        { model: Location, attributes: ['id', 'name'] }
      ]
    });
    if (cateringAdmin) {
      res.json(cateringAdmin);
    } else {
      res.status(404).json({ message: 'Catering admin not found' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Error fetching catering admin', error: error.message });
  }
};

exports.updateCateringAdmin = async (req, res) => {
  try {
    const [updated] = await CateringAdmin.update(req.body, {
      where: { id: req.params.id }
    });
    if (updated) {
      const updatedCateringAdmin = await CateringAdmin.findByPk(req.params.id, {
        include: [
          { model: User, attributes: ['id', 'name', 'email'] },
          { model: Location, attributes: ['id', 'name'] }
        ]
      });
      res.json(updatedCateringAdmin);
    } else {
      res.status(404).json({ message: 'Catering admin not found' });
    }
  } catch (error) {
    res.status(400).json({ message: 'Error updating catering admin', error: error.message });
  }
};

exports.deleteCateringAdmin = async (req, res) => {
  try {
    const deleted = await CateringAdmin.destroy({
      where: { id: req.params.id }
    });
    if (deleted) {
      res.status(204).send();
    } else {
      res.status(404).json({ message: 'Catering admin not found' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Error deleting catering admin', error: error.message });
  }
};

================
File: src/controllers/cateringController.js
================
const cateringService = require('../services/cateringService');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const getCateringMenu = async (req, res, next) => {
  try {
    const { locationId } = req.params;
    const menu = await cateringService.getCateringMenu(locationId, req.user.clientId);
    res.status(200).json(menu);
  } catch (error) {
    logger.error(`Error fetching catering menu for location ${req.params.locationId}:`, error);
    next(new AppError('Error fetching catering menu', 500));
  }
};

const createCateringOrder = async (req, res, next) => {
  try {
    const order = await cateringService.createCateringOrder(req.body, req.user.clientId);
    res.status(201).json(order);
  } catch (error) {
    logger.error('Error creating catering order:', error);
    next(new AppError('Error creating catering order', 500));
  }
};

const getCateringOrderDetails = async (req, res, next) => {
  try {
    const { orderId } = req.params;
    const order = await cateringService.getCateringOrderDetails(orderId, req.user.clientId);
    res.status(200).json(order);
  } catch (error) {
    logger.error(`Error fetching catering order details for order ${req.params.orderId}:`, error);
    next(new AppError('Error fetching catering order details', 500));
  }
};

const updateCateringOrderStatus = async (req, res, next) => {
  try {
    const { orderId } = req.params;
    const { status } = req.body;
    const updatedOrder = await cateringService.updateCateringOrderStatus(orderId, status, req.user.clientId);
    res.status(200).json(updatedOrder);
  } catch (error) {
    logger.error(`Error updating catering order status for order ${req.params.orderId}:`, error);
    next(new AppError('Error updating catering order status', 500));
  }
};

const getAllCateringOrders = async (req, res, next) => {
  try {
    const orders = await cateringService.getAllCateringOrders(req.user.clientId);
    res.status(200).json(orders);
  } catch (error) {
    logger.error('Error fetching all catering orders:', error);
    next(new AppError('Error fetching catering orders', 500));
  }
};

const upsertCateringMenuItem = async (req, res, next) => {
  try {
    const menuItem = await cateringService.upsertCateringMenuItem(req.body, req.user.clientId);
    res.status(201).json(menuItem);
  } catch (error) {
    logger.error('Error upserting catering menu item:', error);
    next(new AppError('Error upserting catering menu item', 500));
  }
};

const deleteCateringMenuItem = async (req, res, next) => {
  try {
    const { itemId } = req.params;
    await cateringService.deleteCateringMenuItem(itemId, req.user.clientId);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting catering menu item ${req.params.itemId}:`, error);
    next(new AppError('Error deleting catering menu item', 500));
  }
};

module.exports = {
  getCateringMenu,
  createCateringOrder,
  getCateringOrderDetails,
  updateCateringOrderStatus,
  getAllCateringOrders,
  upsertCateringMenuItem,
  deleteCateringMenuItem
};

================
File: src/controllers/cateringMenuController.js
================
const { CateringMenu } = require('../models');

exports.getAllCateringMenus = async (req, res) => {
  try {
    const menus = await CateringMenu.findAll({ where: { clientId: req.user.clientId } });
    res.json(menus);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching catering menus', error: error.message });
  }
};

exports.createCateringMenu = async (req, res) => {
  try {
    const newMenu = await CateringMenu.create({ ...req.body, clientId: req.user.clientId });
    res.status(201).json(newMenu);
  } catch (error) {
    res.status(400).json({ message: 'Error creating catering menu', error: error.message });
  }
};

exports.getCateringMenu = async (req, res) => {
  try {
    const menu = await CateringMenu.findOne({ 
      where: { id: req.params.id, clientId: req.user.clientId }
    });
    if (menu) {
      res.json(menu);
    } else {
      res.status(404).json({ message: 'Catering menu not found' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Error fetching catering menu', error: error.message });
  }
};

exports.updateCateringMenu = async (req, res) => {
  try {
    const [updated] = await CateringMenu.update(req.body, {
      where: { id: req.params.id, clientId: req.user.clientId }
    });
    if (updated) {
      const updatedMenu = await CateringMenu.findOne({ where: { id: req.params.id } });
      res.json(updatedMenu);
    } else {
      res.status(404).json({ message: 'Catering menu not found' });
    }
  } catch (error) {
    res.status(400).json({ message: 'Error updating catering menu', error: error.message });
  }
};

exports.deleteCateringMenu = async (req, res) => {
  try {
    const deleted = await CateringMenu.destroy({
      where: { id: req.params.id, clientId: req.user.clientId }
    });
    if (deleted) {
      res.status(204).send();
    } else {
      res.status(404).json({ message: 'Catering menu not found' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Error deleting catering menu', error: error.message });
  }
};

================
File: src/controllers/cateringMenuItemController.js
================
const { CateringMenuItem } = require('../models');

exports.getAllCateringMenuItems = async (req, res) => {
  try {
    const items = await CateringMenuItem.findAll({ where: { menuId: req.params.menuId } });
    res.json(items);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching catering menu items', error: error.message });
  }
};

exports.createCateringMenuItem = async (req, res) => {
  try {
    const newItem = await CateringMenuItem.create({ ...req.body, menuId: req.params.menuId });
    res.status(201).json(newItem);
  } catch (error) {
    res.status(400).json({ message: 'Error creating catering menu item', error: error.message });
  }
};

exports.getCateringMenuItem = async (req, res) => {
  try {
    const item = await CateringMenuItem.findOne({ 
      where: { id: req.params.id, menuId: req.params.menuId }
    });
    if (item) {
      res.json(item);
    } else {
      res.status(404).json({ message: 'Catering menu item not found' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Error fetching catering menu item', error: error.message });
  }
};

exports.updateCateringMenuItem = async (req, res) => {
  try {
    const [updated] = await CateringMenuItem.update(req.body, {
      where: { id: req.params.id, menuId: req.params.menuId }
    });
    if (updated) {
      const updatedItem = await CateringMenuItem.findOne({ where: { id: req.params.id } });
      res.json(updatedItem);
    } else {
      res.status(404).json({ message: 'Catering menu item not found' });
    }
  } catch (error) {
    res.status(400).json({ message: 'Error updating catering menu item', error: error.message });
  }
};

exports.deleteCateringMenuItem = async (req, res) => {
  try {
    const deleted = await CateringMenuItem.destroy({
      where: { id: req.params.id, menuId: req.params.menuId }
    });
    if (deleted) {
      res.status(204).send();
    } else {
      res.status(404).json({ message: 'Catering menu item not found' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Error deleting catering menu item', error: error.message });
  }
};

================
File: src/controllers/cateringOrderAssignmentsController.js
================
const { CateringOrderAssignment } = require('../models');

exports.getAllAssignments = async (req, res) => {
  try {
    const assignments = await CateringOrderAssignment.findAll({ where: { clientId: req.user.clientId } });
    res.json(assignments);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching assignments', error: error.message });
  }
};

exports.createAssignment = async (req, res) => {
  try {
    const newAssignment = await CateringOrderAssignment.create({ ...req.body, clientId: req.user.clientId });
    res.status(201).json(newAssignment);
  } catch (error) {
    res.status(400).json({ message: 'Error creating assignment', error: error.message });
  }
};

exports.getAssignment = async (req, res) => {
  try {
    const assignment = await CateringOrderAssignment.findOne({ 
      where: { id: req.params.id, clientId: req.user.clientId }
    });
    if (assignment) {
      res.json(assignment);
    } else {
      res.status(404).json({ message: 'Assignment not found' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Error fetching assignment', error: error.message });
  }
};

exports.updateAssignment = async (req, res) => {
  try {
    const [updated] = await CateringOrderAssignment.update(req.body, {
      where: { id: req.params.id, clientId: req.user.clientId }
    });
    if (updated) {
      const updatedAssignment = await CateringOrderAssignment.findOne({ where: { id: req.params.id } });
      res.json(updatedAssignment);
    } else {
      res.status(404).json({ message: 'Assignment not found' });
    }
  } catch (error) {
    res.status(400).json({ message: 'Error updating assignment', error: error.message });
  }
};

exports.deleteAssignment = async (req, res) => {
  try {
    const deleted = await CateringOrderAssignment.destroy({
      where: { id: req.params.id, clientId: req.user.clientId }
    });
    if (deleted) {
      res.status(204).send();
    } else {
      res.status(404).json({ message: 'Assignment not found' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Error deleting assignment', error: error.message });
  }
};

================
File: src/controllers/cateringOrderController.js
================
const CateringOrderService = require('../services/cateringOrderService');
const logger = require('../services/logger');
const { check, validationResult } = require('express-validator');
const CateringOrder = require('../models/CateringOrder');
const CateringOrderItem = require('../models/CateringOrderItem');
const Modifier = require('../models/Modifier');

// Validation middleware for catering order creation
const validateCateringOrder = [
  check('guestId').isInt().withMessage('Valid guest ID is required'),
  check('locationId').isInt().withMessage('Valid location ID is required'),
  check('scheduledDate').isISO8601().withMessage('Valid scheduled date is required'),
  check('orderDetails').isArray().withMessage('Order details must be an array of items'),
  check('houseAccountId').optional().isInt().withMessage('Valid house account ID is required'),
  check('serviceFees').optional().isObject().withMessage('Service fees must be an object'),
  check('tips').optional().isObject().withMessage('Tips must be an object'),
];

// Create a new catering order
exports.createCateringOrder = [
  ...validateCateringOrder,
  async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    try {
      const order = await CateringOrderService.createCateringOrder(req.body);
      res.status(201).json(order);
    } catch (error) {
      logger.error(`Error creating catering order: ${error.message}`);
      res.status(500).json({ message: 'Error creating catering order', error });
    }
  }
];

// Fetch catering orders by house account
exports.getCateringOrdersByHouseAccount = async (req, res) => {
  try {
    const orders = await CateringOrderService.getCateringOrdersByHouseAccount(req.params.houseAccountId);
    res.json(orders);
  } catch (error) {
    logger.error(`Error fetching catering orders by house account: ${error.message}`);
    res.status(500).json({ message: 'Error fetching catering orders', error });
  }
};

// Fetch catering orders by guest
exports.getCateringOrdersByGuest = async (req, res) => {
  try {
    const orders = await CateringOrderService.getCateringOrdersByGuest(req.params.guestId);
    res.json(orders);
  } catch (error) {
    logger.error(`Error fetching catering orders by guest: ${error.message}`);
    res.status(500).json({ message: 'Error fetching catering orders', error });
  }
};

// Handle catering invoicing
exports.handleCateringInvoicing = async (req, res) => {
  try {
    const result = await CateringOrderService.handleCateringInvoicing(req.params.orderId);
    res.json(result);
  } catch (error) {
    logger.error(`Error handling catering invoicing: ${error.message}`);
    res.status(500).json({ message: 'Error handling catering invoicing', error });
  }
};

// Get orders
exports.getOrders = async (req, res) => {
  try {
    const { clientId } = req.params;
    const { status } = req.query;
    let query = { clientId };
    if (status && status !== 'all') {
      query.status = status;
    }
    const orders = await CateringOrder.find(query);
    res.json(orders);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching catering orders', error: error.message });
  }
};

// Update order status
exports.updateOrderStatus = async (req, res) => {
  try {
    const { clientId, orderId } = req.params;
    const { status } = req.body;
    const updatedOrder = await CateringOrder.findOneAndUpdate(
      { _id: orderId, clientId },
      { status },
      { new: true }
    );
    if (!updatedOrder) {
      return res.status(404).json({ message: 'Order not found' });
    }
    res.json(updatedOrder);
  } catch (error) {
    res.status(500).json({ message: 'Error updating order status', error: error.message });
  }
};

// Delete order
exports.deleteOrder = async (req, res) => {
  try {
    const { clientId, orderId } = req.params;
    const deletedOrder = await CateringOrder.findOneAndDelete({ _id: orderId, clientId });
    if (!deletedOrder) {
      return res.status(404).json({ message: 'Order not found' });
    }
    res.json({ message: 'Order deleted successfully' });
  } catch (error) {
    res.status(500).json({ message: 'Error deleting order', error: error.message });
  }
};

================
File: src/controllers/cateringOrderCustomizationController.js
================
const CateringOrderCustomization = require('../models/CateringOrderCustomization');

exports.getAllCustomizations = async (req, res) => {
  try {
    const customizations = await CateringOrderCustomization.findAll();
    res.status(200).json(customizations);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching customizations', error: error.message });
  }
};

exports.getCustomizationById = async (req, res) => {
  try {
    const customization = await CateringOrderCustomization.findByPk(req.params.id);
    if (!customization) {
      return res.status(404).json({ message: 'Customization not found' });
    }
    res.status(200).json(customization);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching customization', error: error.message });
  }
};

exports.createCustomization = async (req, res) => {
  try {
    const newCustomization = await CateringOrderCustomization.create(req.body);
    res.status(201).json(newCustomization);
  } catch (error) {
    res.status(500).json({ message: 'Error creating customization', error: error.message });
  }
};

exports.updateCustomization = async (req, res) => {
  try {
    const [updated] = await CateringOrderCustomization.update(req.body, {
      where: { id: req.params.id }
    });
    if (updated) {
      const updatedCustomization = await CateringOrderCustomization.findByPk(req.params.id);
      res.status(200).json(updatedCustomization);
    } else {
      res.status(404).json({ message: 'Customization not found' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Error updating customization', error: error.message });
  }
};

exports.deleteCustomization = async (req, res) => {
  try {
    const deleted = await CateringOrderCustomization.destroy({
      where: { id: req.params.id }
    });
    if (deleted) {
      res.status(204).send();
    } else {
      res.status(404).json({ message: 'Customization not found' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Error deleting customization', error: error.message });
  }
};

================
File: src/controllers/cateringOrderFeesController.js
================
const { CateringOrderFees } = require('../models');

exports.getAllFees = async (req, res) => {
  try {
    const fees = await CateringOrderFees.findAll();
    res.json(fees);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching catering order fees', error: error.message });
  }
};

exports.createFee = async (req, res) => {
  try {
    const newFee = await CateringOrderFees.create(req.body);
    res.status(201).json(newFee);
  } catch (error) {
    res.status(400).json({ message: 'Error creating catering order fee', error: error.message });
  }
};

exports.getFee = async (req, res) => {
  try {
    const fee = await CateringOrderFees.findByPk(req.params.id);
    if (fee) {
      res.json(fee);
    } else {
      res.status(404).json({ message: 'Catering order fee not found' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Error fetching catering order fee', error: error.message });
  }
};

exports.updateFee = async (req, res) => {
  try {
    const [updated] = await CateringOrderFees.update(req.body, {
      where: { id: req.params.id }
    });
    if (updated) {
      const updatedFee = await CateringOrderFees.findByPk(req.params.id);
      res.json(updatedFee);
    } else {
      res.status(404).json({ message: 'Catering order fee not found' });
    }
  } catch (error) {
    res.status(400).json({ message: 'Error updating catering order fee', error: error.message });
  }
};

exports.deleteFee = async (req, res) => {
  try {
    const deleted = await CateringOrderFees.destroy({
      where: { id: req.params.id }
    });
    if (deleted) {
      res.status(204).send();
    } else {
      res.status(404).json({ message: 'Catering order fee not found' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Error deleting catering order fee', error: error.message });
  }
};

================
File: src/controllers/cateringOrderItemController.js
================
const { CateringOrderItem } = require('../models');

exports.getAllItems = async (req, res) => {
  try {
    const items = await CateringOrderItem.findAll();
    res.json(items);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching catering order items', error: error.message });
  }
};

exports.createItem = async (req, res) => {
  try {
    const newItem = await CateringOrderItem.create(req.body);
    res.status(201).json(newItem);
  } catch (error) {
    res.status(400).json({ message: 'Error creating catering order item', error: error.message });
  }
};

exports.getItem = async (req, res) => {
  try {
    const item = await CateringOrderItem.findByPk(req.params.id);
    if (item) {
      res.json(item);
    } else {
      res.status(404).json({ message: 'Catering order item not found' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Error fetching catering order item', error: error.message });
  }
};

exports.updateItem = async (req, res) => {
  try {
    const [updated] = await CateringOrderItem.update(req.body, {
      where: { id: req.params.id }
    });
    if (updated) {
      const updatedItem = await CateringOrderItem.findByPk(req.params.id);
      res.json(updatedItem);
    } else {
      res.status(404).json({ message: 'Catering order item not found' });
    }
  } catch (error) {
    res.status(400).json({ message: 'Error updating catering order item', error: error.message });
  }
};

exports.deleteItem = async (req, res) => {
  try {
    const deleted = await CateringOrderItem.destroy({
      where: { id: req.params.id }
    });
    if (deleted) {
      res.status(204).send();
    } else {
      res.status(404).json({ message: 'Catering order item not found' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Error deleting catering order item', error: error.message });
  }
};

================
File: src/controllers/cateringOrderLocationController.js
================
const { CateringOrderLocation } = require('../models');

exports.getAllLocations = async (req, res) => {
  try {
    const locations = await CateringOrderLocation.findAll();
    res.json(locations);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching catering order locations', error: error.message });
  }
};

exports.createLocation = async (req, res) => {
  try {
    const newLocation = await CateringOrderLocation.create(req.body);
    res.status(201).json(newLocation);
  } catch (error) {
    res.status(400).json({ message: 'Error creating catering order location', error: error.message });
  }
};

exports.getLocation = async (req, res) => {
  try {
    const location = await CateringOrderLocation.findByPk(req.params.id);
    if (location) {
      res.json(location);
    } else {
      res.status(404).json({ message: 'Catering order location not found' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Error fetching catering order location', error: error.message });
  }
};

exports.updateLocation = async (req, res) => {
  try {
    const [updated] = await CateringOrderLocation.update(req.body, {
      where: { id: req.params.id }
    });
    if (updated) {
      const updatedLocation = await CateringOrderLocation.findByPk(req.params.id);
      res.json(updatedLocation);
    } else {
      res.status(404).json({ message: 'Catering order location not found' });
    }
  } catch (error) {
    res.status(400).json({ message: 'Error updating catering order location', error: error.message });
  }
};

exports.deleteLocation = async (req, res) => {
  try {
    const deleted = await CateringOrderLocation.destroy({
      where: { id: req.params.id }
    });
    if (deleted) {
      res.status(204).send();
    } else {
      res.status(404).json({ message: 'Catering order location not found' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Error deleting catering order location', error: error.message });
  }
};

================
File: src/controllers/cateringOrderModifierController.js
================
const { CateringOrderModifier } = require('../models');

exports.getAllModifiers = async (req, res) => {
  try {
    const modifiers = await CateringOrderModifier.findAll();
    res.json(modifiers);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching catering order modifiers', error: error.message });
  }
};

exports.createModifier = async (req, res) => {
  try {
    const newModifier = await CateringOrderModifier.create(req.body);
    res.status(201).json(newModifier);
  } catch (error) {
    res.status(400).json({ message: 'Error creating catering order modifier', error: error.message });
  }
};

exports.getModifier = async (req, res) => {
  try {
    const modifier = await CateringOrderModifier.findByPk(req.params.id);
    if (modifier) {
      res.json(modifier);
    } else {
      res.status(404).json({ message: 'Catering order modifier not found' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Error fetching catering order modifier', error: error.message });
  }
};

exports.updateModifier = async (req, res) => {
  try {
    const [updated] = await CateringOrderModifier.update(req.body, {
      where: { id: req.params.id }
    });
    if (updated) {
      const updatedModifier = await CateringOrderModifier.findByPk(req.params.id);
      res.json(updatedModifier);
    } else {
      res.status(404).json({ message: 'Catering order modifier not found' });
    }
  } catch (error) {
    res.status(400).json({ message: 'Error updating catering order modifier', error: error.message });
  }
};

exports.deleteModifier = async (req, res) => {
  try {
    const deleted = await CateringOrderModifier.destroy({
      where: { id: req.params.id }
    });
    if (deleted) {
      res.status(204).send();
    } else {
      res.status(404).json({ message: 'Catering order modifier not found' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Error deleting catering order modifier', error: error.message });
  }
};

================
File: src/controllers/cateringSettingsController.js
================
const { CateringSettings } = require('../models');

exports.getSettings = async (req, res) => {
  try {
    const settings = await CateringSettings.findOne({ where: { locationId: req.user.locationId } });
    if (settings) {
      res.json(settings);
    } else {
      res.status(404).json({ message: 'Catering settings not found' });
    }
  } catch (error) {
    res.status(500).json({ message: 'Error fetching catering settings', error: error.message });
  }
};

exports.updateSettings = async (req, res) => {
  try {
    const [updated] = await CateringSettings.update(req.body, {
      where: { locationId: req.user.locationId }
    });
    if (updated) {
      const updatedSettings = await CateringSettings.findOne({ where: { locationId: req.user.locationId } });
      res.json(updatedSettings);
    } else {
      res.status(404).json({ message: 'Catering settings not found' });
    }
  } catch (error) {
    res.status(400).json({ message: 'Error updating catering settings', error: error.message });
  }
};

================
File: src/controllers/checkoutController.js
================
const OrderHistory = require('../models/OrderHistory');
const Order = require('../models/Order');
const axios = require('axios');
const Guest = require('../models/Guest');
const LocationMenuOverride = require('../models/LocationMenuOverride');
const { calculateServiceFees, calculateDiscounts } = require('../utils/pricingUtils');
const checkoutService = require('../services/checkoutService');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const checkout = async (req, res) => {
  const { items, paymentMethod, guestId, locationId } = req.body;

  try {
    let totalCurrencyPrice = 0;
    let totalPointsPrice = 0;
    const orderDetails = [];

    for (const item of items) {
      const locationOverride = await LocationMenuOverride.findOne({
        where: { menuItemId: item.menuItemId, locationId },
      });

      if (!locationOverride) {
        return res.status(400).json({ message: `Item ${item.menuItemId} not available for this location.` });
      }

      let price = locationOverride.price;
      if (paymentMethod === 'currency') {
        const { finalPrice, serviceFees } = calculateServiceFees(price, locationOverride, locationId);
        price = finalPrice;
        totalCurrencyPrice += price * item.quantity;
        orderDetails.push({ ...item, price, serviceFees });
      } else if (paymentMethod === 'points') {
        totalPointsPrice += locationOverride.pointsPrice * item.quantity;
        orderDetails.push({ ...item, price: locationOverride.pointsPrice });
      }
    }

    const guest = await Guest.findByPk(guestId);
    const discount = calculateDiscounts(guest.loyaltyTier, totalCurrencyPrice);
    totalCurrencyPrice -= discount;

    const posOrderData = {
      guestId,
      locationId,
      items: orderDetails,
      paymentMethod,
      totalCurrencyPrice,
      totalPointsPrice,
    };

    const posResponse = await sendOrderToPOS(posOrderData);
    if (!posResponse.approved) {
      return res.status(400).json({ message: 'Order could not be approved by the POS system.' });
    }

    const order = await Order.create({
      guestId,
      locationId,
      paymentMethod,
      totalAmount: paymentMethod === 'currency' ? totalCurrencyPrice : totalPointsPrice,
    });

    await OrderHistory.create({
      orderId: order.id,
      guestId,
      locationId,
      paymentMethod,
      totalAmount: paymentMethod === 'currency' ? totalCurrencyPrice : totalPointsPrice,
      orderDetails,
      action: 'Order Placed',
    });

    res.json({
      totalCurrencyPrice,
      totalPointsPrice,
      message: 'Checkout and order processed successfully.',
    });
  } catch (error) {
    res.status(500).json({ message: 'Error during checkout', error });
  }
};

async function sendOrderToPOS(orderData) {
  try {
    const response = await axios.post('https://pos-system.com/api/orders', orderData);
    return response.data;
  } catch (error) {
    console.error('Error communicating with POS system:', error);
    return { approved: false };
  }
}

const initializeCheckout = async (req, res, next) => {
  try {
    const checkout = await checkoutService.initializeCheckout(req.body, req.user.clientId);
    res.status(200).json(checkout);
  } catch (error) {
    logger.error('Error initializing checkout:', error);
    next(new AppError('Error initializing checkout', 500));
  }
};

const processPayment = async (req, res, next) => {
  try {
    const result = await checkoutService.processPayment(req.body, req.user.clientId);
    res.status(200).json(result);
  } catch (error) {
    logger.error('Error processing payment:', error);
    next(new AppError('Error processing payment', 500));
  }
};

const confirmOrder = async (req, res, next) => {
  try {
    const order = await checkoutService.confirmOrder(req.body, req.user.clientId);
    res.status(200).json(order);
  } catch (error) {
    logger.error('Error confirming order:', error);
    next(new AppError('Error confirming order', 500));
  }
};

const getCheckoutStatus = async (req, res, next) => {
  try {
    const status = await checkoutService.getCheckoutStatus(req.params.checkoutId, req.user.clientId);
    res.status(200).json(status);
  } catch (error) {
    logger.error(`Error fetching checkout status for ${req.params.checkoutId}:`, error);
    next(new AppError('Error fetching checkout status', 500));
  }
};

const applyCoupon = async (req, res, next) => {
  try {
    const result = await checkoutService.applyCoupon(req.body.checkoutId, req.body.couponCode, req.user.clientId);
    res.status(200).json(result);
  } catch (error) {
    logger.error('Error applying coupon:', error);
    next(new AppError('Error applying coupon', 500));
  }
};

const removeCoupon = async (req, res, next) => {
  try {
    const result = await checkoutService.removeCoupon(req.body.checkoutId, req.user.clientId);
    res.status(200).json(result);
  } catch (error) {
    logger.error('Error removing coupon:', error);
    next(new AppError('Error removing coupon', 500));
  }
};

const updateShippingAddress = async (req, res, next) => {
  try {
    const result = await checkoutService.updateShippingAddress(req.body.checkoutId, req.body.address, req.user.clientId);
    res.status(200).json(result);
  } catch (error) {
    logger.error('Error updating shipping address:', error);
    next(new AppError('Error updating shipping address', 500));
  }
};

const getPaymentMethods = async (req, res, next) => {
  try {
    const methods = await checkoutService.getPaymentMethods(req.user.clientId);
    res.status(200).json(methods);
  } catch (error) {
    logger.error('Error fetching payment methods:', error);
    next(new AppError('Error fetching payment methods', 500));
  }
};

module.exports = {
  checkout,
  initializeCheckout,
  processPayment,
  confirmOrder,
  getCheckoutStatus,
  applyCoupon,
  removeCoupon,
  updateShippingAddress,
  getPaymentMethods
};

================
File: src/controllers/clientBrandingController.js
================
const { Request, Response } = require 'express';
const { getClientBranding, updateClientBranding } = require '../services/clientBrandingService';
const { AppError } = require '../utils/errorHandler';

const getClientBrandingController = async (req, res) => {
  try {
    const clientId = req.user.clientId; // Assuming you have middleware that sets the user and clientId
    const branding = await getClientBranding(clientId);
    res.status(200).json(branding);
  } catch (error) {
    if (error instanceof AppError) {
      res.status(error.statusCode).json({ message.message });
    } else {
      res.status(500).json({ message: 'Error fetching client branding' });
    }
  }
};

const updateClientBrandingController = async (req, res) => {
  try {
    const clientId = req.user.clientId;
    const updatedBranding = await updateClientBranding(clientId, req.body);
    res.status(200).json(updatedBranding);
  } catch (error) {
    if (error instanceof AppError) {
      res.status(error.statusCode).json({ message.message });
    } else {
      res.status(500).json({ message: 'Error updating client branding' });
    }
  }
};

================
File: src/controllers/clientController.js
================
const clientService = require('../services/clientService');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const getAllClients = async (req, res, next) => {
  try {
    const clients = await clientService.getAllClients();
    res.status(200).json(clients);
  } catch (error) {
    logger.error('Error fetching all clients:', error);
    next(new AppError('Error fetching clients', 500));
  }
};

const getClientById = async (req, res, next) => {
  try {
    const client = await clientService.getClientById(req.params.id);
    if (!client) {
      return next(new AppError('Client not found', 404));
    }
    res.status(200).json(client);
  } catch (error) {
    logger.error(`Error fetching client ${req.params.id}:`, error);
    next(new AppError('Error fetching client', 500));
  }
};

const createClient = async (req, res, next) => {
  try {
    const newClient = await clientService.createClient(req.body);
    logger.info(`New client created: ${newClient.id}`);
    res.status(201).json(newClient);
  } catch (error) {
    logger.error('Error creating client:', error);
    next(new AppError('Error creating client', 500));
  }
};

const updateClient = async (req, res, next) => {
  try {
    const updatedClient = await clientService.updateClient(req.params.id, req.body);
    if (!updatedClient) {
      return next(new AppError('Client not found', 404));
    }
    logger.info(`Client updated: ${req.params.id}`);
    res.status(200).json(updatedClient);
  } catch (error) {
    logger.error(`Error updating client ${req.params.id}:`, error);
    next(new AppError('Error updating client', 500));
  }
};

const deleteClient = async (req, res, next) => {
  try {
    const result = await clientService.deleteClient(req.params.id);
    if (!result) {
      return next(new AppError('Client not found', 404));
    }
    logger.info(`Client deleted: ${req.params.id}`);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting client ${req.params.id}:`, error);
    next(new AppError('Error deleting client', 500));
  }
};

const getClientSettings = async (req, res, next) => {
  try {
    const settings = await clientService.getClientSettings(req.params.id);
    if (!settings) {
      return next(new AppError('Client settings not found', 404));
    }
    res.status(200).json(settings);
  } catch (error) {
    logger.error(`Error fetching settings for client ${req.params.id}:`, error);
    next(new AppError('Error fetching client settings', 500));
  }
};

const updateClientSettings = async (req, res, next) => {
  try {
    const updatedSettings = await clientService.updateClientSettings(req.params.id, req.body);
    if (!updatedSettings) {
      return next(new AppError('Client settings not found', 404));
    }
    logger.info(`Settings updated for client: ${req.params.id}`);
    res.status(200).json(updatedSettings);
  } catch (error) {
    logger.error(`Error updating settings for client ${req.params.id}:`, error);
    next(new AppError('Error updating client settings', 500));
  }
};

module.exports = {
  getAllClients,
  getClientById,
  createClient,
  updateClient,
  deleteClient,
  getClientSettings,
  updateClientSettings
};

================
File: src/controllers/clientLocationsController.js
================
const { Client, Location } = require('../models');

exports.getClientLocations = async (req, res) => {
  try {
    const { clientId } = req.params;
    const client = await Client.findByPk(clientId, {
      include: [{
        model: Location,
        attributes: ['id', 'name', 'address', 'city', 'state', 'zipCode', 'phoneNumber', 'email', 'latitude', 'longitude']
      }]
    });

    if (!client) {
      return res.status(404).json({ message: 'Client not found' });
    }

    res.json(client.Locations);
  } catch (error) {
    console.error('Error fetching client locations:', error);
    res.status(500).json({ message: 'Error fetching client locations', error: error.message });
  }
};

================
File: src/controllers/clientPreferencesController.js
================
const { ClientPreferences } = require('../models');
const logger = require('../services/logger');

exports.getAllClientPreferences = async (req, res) => {
  try {
    const preferences = await ClientPreferences.findAll();
    res.status(200).json(preferences);
  } catch (error) {
    logger.error(`Error fetching client preferences: ${error.message}`);
    res.status(500).json({ message: 'Error fetching client preferences', error });
  }
};

exports.getClientPreferenceById = async (req, res) => {
  try {
    const preference = await ClientPreferences.findByPk(req.params.id);
    if (!preference) return res.status(404).json({ message: 'Client preference not found' });
    res.status(200).json(preference);
  } catch (error) {
    logger.error(`Error fetching client preference by ID (${req.params.id}): ${error.message}`);
    res.status(500).json({ message: 'Error fetching client preference', error });
  }
};

exports.createClientPreference = async (req, res) => {
  try {
    const newPreference = await ClientPreferences.create(req.body);
    logger.info(`Client preference created: ${newPreference.id}`);
    res.status(201).json(newPreference);
  } catch (error) {
    logger.error(`Error creating client preference: ${error.message}`);
    res.status(500).json({ message: 'Error creating client preference', error });
  }
};

exports.updateClientPreference = async (req, res) => {
  try {
    const [updated] = await ClientPreferences.update(req.body, { where: { id: req.params.id } });
    if (!updated) return res.status(404).json({ message: 'Client preference not found' });

    const updatedPreference = await ClientPreferences.findByPk(req.params.id);
    logger.info(`Client preference updated: ${req.params.id}`);
    res.status(200).json(updatedPreference);
  } catch (error) {
    logger.error(`Error updating client preference: ${error.message}`);
    res.status(500).json({ message: 'Error updating client preference', error });
  }
};

exports.deleteClientPreference = async (req, res) => {
  try {
    const deleted = await ClientPreferences.destroy({ where: { id: req.params.id } });
    if (!deleted) return res.status(404).json({ message: 'Client preference not found' });

    logger.info(`Client preference deleted: ${req.params.id}`);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting client preference: ${error.message}`);
    res.status(500).json({ message: 'Error deleting client preference', error });
  }
};

================
File: src/controllers/clientProfileController.js
================
const db = require('../models');

// Fetch all client profiles
exports.getClientProfiles = async (req, res) => {
  try {
    const profiles = await db.ClientProfile.findAll();
    res.status(200).json(profiles);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching client profiles', error });
  }
};

// Create a new client profile
exports.createClientProfile = async (req, res) => {
  try {
    const profile = await db.ClientProfile.create(req.body);
    res.status(201).json(profile);
  } catch (error) {
    res.status(500).json({ message: 'Error creating client profile', error });
  }
};

// Update a client profile
exports.updateClientProfile = async (req, res) => {
  try {
    const profile = await db.ClientProfile.update(req.body, { where: { id: req.params.id } });
    res.status(200).json(profile);
  } catch (error) {
    res.status(500).json({ message: 'Error updating client profile', error });
  }
};

// Delete a client profile
exports.deleteClientProfile = async (req, res) => {
  try {
    await db.ClientProfile.destroy({ where: { id: req.params.id } });
    res.status(204).json();
  } catch (error) {
    res.status(500).json({ message: 'Error deleting client profile', error });
  }
};

================
File: src/controllers/clientSettingsController.js
================
const { Request, Response } = require 'express';
const { ClientSettings, Location } = require '../models';

const updateGlobalTwoFactorSetting = async (req, res) => {
  try {
    const { twoFactorRequired } = req.body;
    const clientId = req.user.clientId;

    await ClientSettings.update({ twoFactorRequired }, { where: { clientId } });

    res.json({ message: 'Global 2FA setting updated successfully' });
  } catch (error) {
    res.status(500).json({ message: 'Error updating global 2FA setting' });
  }
};

const updateLocationTwoFactorException = async (req, res) => {
  try {
    const { locationId, twoFactorException } = req.body;
    const clientId = req.user.clientId;

    const location = await Location.findOne({ where: { id, clientId } });
    if (!location) {
      return res.status(404).json({ message: 'Location not found' });
    }

    await location.update({ twoFactorException });

    res.json({ message: 'Location 2FA exception updated successfully' });
  } catch (error) {
    res.status(500).json({ message: 'Error updating location 2FA exception' });
  }
};

const updateGlobalPaymentGateways = async (req, res) => {
  try {
    const { defaultPaymentGateways } = req.body;
    const clientId = req.user.clientId;

    await ClientSettings.update({ defaultPaymentGateways }, { where: { clientId } });

    res.json({ message: 'Global payment gateway settings updated successfully' });
  } catch (error) {
    res.status(500).json({ message: 'Error updating global payment gateway settings' });
  }
};

const updateLocationPaymentGatewayExceptions = async (req, res) => {
  try {
    const { locationId, paymentGatewayExceptions } = req.body;
    const clientId = req.user.clientId;

    const location = await Location.findOne({ where: { id, clientId } });
    if (!location) {
      return res.status(404).json({ message: 'Location not found' });
    }

    await location.update({ paymentGatewayExceptions });

    res.json({ message: 'Location payment gateway exceptions updated successfully' });
  } catch (error) {
    res.status(500).json({ message: 'Error updating location payment gateway exceptions' });
  }
};

================
File: src/controllers/commissaryKitchenController.js
================
const commissaryKitchenService = require('../services/commissaryKitchenService');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const getAllCommissaryKitchens = async (req, res, next) => {
  try {
    const kitchens = await commissaryKitchenService.getAllCommissaryKitchens(req.user.clientId);
    res.status(200).json(kitchens);
  } catch (error) {
    logger.error('Error fetching commissary kitchens:', error);
    next(new AppError('Error fetching commissary kitchens', 500));
  }
};

const getCommissaryKitchenById = async (req, res, next) => {
  try {
    const kitchen = await commissaryKitchenService.getCommissaryKitchenById(req.params.id, req.user.clientId);
    if (!kitchen) {
      return next(new AppError('Commissary kitchen not found', 404));
    }
    res.status(200).json(kitchen);
  } catch (error) {
    logger.error(`Error fetching commissary kitchen ${req.params.id}:`, error);
    next(error);
  }
};

const createCommissaryKitchen = async (req, res, next) => {
  try {
    const newKitchen = await commissaryKitchenService.createCommissaryKitchen(req.body, req.user.clientId);
    res.status(201).json(newKitchen);
  } catch (error) {
    logger.error('Error creating commissary kitchen:', error);
    next(error);
  }
};

const updateCommissaryKitchen = async (req, res, next) => {
  try {
    const updatedKitchen = await commissaryKitchenService.updateCommissaryKitchen(req.params.id, req.body, req.user.clientId);
    if (!updatedKitchen) {
      return next(new AppError('Commissary kitchen not found', 404));
    }
    res.status(200).json(updatedKitchen);
  } catch (error) {
    logger.error(`Error updating commissary kitchen ${req.params.id}:`, error);
    next(error);
  }
};

const deleteCommissaryKitchen = async (req, res, next) => {
  try {
    const result = await commissaryKitchenService.deleteCommissaryKitchen(req.params.id, req.user.clientId);
    if (!result) {
      return next(new AppError('Commissary kitchen not found', 404));
    }
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting commissary kitchen ${req.params.id}:`, error);
    next(error);
  }
};

const getCommissaryKitchenInventory = async (req, res, next) => {
  try {
    const inventory = await commissaryKitchenService.getCommissaryKitchenInventory(req.params.id, req.user.clientId);
    res.status(200).json(inventory);
  } catch (error) {
    logger.error(`Error fetching inventory for commissary kitchen ${req.params.id}:`, error);
    next(error);
  }
};

const updateCommissaryKitchenInventory = async (req, res, next) => {
  try {
    const updatedInventory = await commissaryKitchenService.updateCommissaryKitchenInventory(req.params.id, req.body, req.user.clientId);
    res.status(200).json(updatedInventory);
  } catch (error) {
    logger.error(`Error updating inventory for commissary kitchen ${req.params.id}:`, error);
    next(error);
  }
};

module.exports = {
  getAllCommissaryKitchens,
  getCommissaryKitchenById,
  createCommissaryKitchen,
  updateCommissaryKitchen,
  deleteCommissaryKitchen,
  getCommissaryKitchenInventory,
  updateCommissaryKitchenInventory
};

================
File: src/controllers/commissaryLocationController.js
================
const { CommissaryLocation } = require('../models');
const logger = require('../services/logger');

exports.getAllCommissaryLocations = async (req, res) => {
  try {
    const locations = await CommissaryLocation.findAll();
    res.status(200).json(locations);
  } catch (error) {
    logger.error(`Error fetching commissary locations: ${error.message}`);
    res.status(500).json({ message: 'Error fetching commissary locations', error });
  }
};

exports.getCommissaryLocationById = async (req, res) => {
  try {
    const location = await CommissaryLocation.findByPk(req.params.id);
    if (!location) return res.status(404).json({ message: 'Commissary location not found' });
    res.status(200).json(location);
  } catch (error) {
    logger.error(`Error fetching commissary location by ID (${req.params.id}): ${error.message}`);
    res.status(500).json({ message: 'Error fetching commissary location', error });
  }
};

exports.createCommissaryLocation = async (req, res) => {
  try {
    const newLocation = await CommissaryLocation.create(req.body);
    logger.info(`Commissary location created: ${newLocation.id}`);
    res.status(201).json(newLocation);
  } catch (error) {
    logger.error(`Error creating commissary location: ${error.message}`);
    res.status(500).json({ message: 'Error creating commissary location', error });
  }
};

exports.updateCommissaryLocation = async (req, res) => {
  try {
    const [updated] = await CommissaryLocation.update(req.body, { where: { id: req.params.id } });
    if (!updated) return res.status(404).json({ message: 'Commissary location not found' });

    const updatedLocation = await CommissaryLocation.findByPk(req.params.id);
    logger.info(`Commissary location updated: ${req.params.id}`);
    res.status(200).json(updatedLocation);
  } catch (error) {
    logger.error(`Error updating commissary location: ${error.message}`);
    res.status(500).json({ message: 'Error updating commissary location', error });
  }
};

exports.deleteCommissaryLocation = async (req, res) => {
  try {
    const deleted = await CommissaryLocation.destroy({ where: { id: req.params.id } });
    if (!deleted) return res.status(404).json({ message: 'Commissary location not found' });

    logger.info(`Commissary location deleted: ${req.params.id}`);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting commissary location: ${error.message}`);
    res.status(500).json({ message: 'Error deleting commissary location', error });
  }
};

================
File: src/controllers/corePosProfileController.js
================
const corePosProfileService = require('../services/corePosProfileService');

class CorePosProfileController {
  async getAll(req, res) {
    try {
      const profiles = await corePosProfileService.getAll();
      res.json(profiles);
    } catch (error) {
      res.status(500).json({ message: 'Error fetching profiles', error });
    }
  }

  async getById(req, res) {
    try {
      const profile = await corePosProfileService.getById(req.params.id);
      if (profile) {
        res.json(profile);
      } else {
        res.status(404).json({ message: 'Profile not found' });
      }
    } catch (error) {
      res.status(500).json({ message: 'Error fetching profile', error });
    }
  }

  async create(req, res) {
    try {
      const profile = await corePosProfileService.create(req.body);
      res.status(201).json(profile);
    } catch (error) {
      res.status(400).json({ message: 'Error creating profile', error });
    }
  }

  async update(req, res) {
    try {
      const profile = await corePosProfileService.update(req.params.id, req.body);
      if (profile) {
        res.json(profile);
      } else {
        res.status(404).json({ message: 'Profile not found' });
      }
    } catch (error) {
      res.status(400).json({ message: 'Error updating profile', error });
    }
  }

  async delete(req, res) {
    try {
      await corePosProfileService.delete(req.params.id);
      res.status(204).send();
    } catch (error) {
      res.status(400).json({ message: 'Error deleting profile', error });
    }
  }

  async syncLocation(req, res) {
    try {
      await corePosProfileService.syncLocation(req.params.id);
      res.status(200).json({ message: 'Sync initiated successfully' });
    } catch (error) {
      res.status(400).json({ message: 'Error initiating sync', error });
    }
  }
}

module.exports = new CorePosProfileController();

================
File: src/controllers/coreposProfilesController.js
================
const { CorePOSProfile } = require('../models');
const logger = require('../services/logger');

exports.getAllCorePOSProfiles = async (req, res) => {
  try {
    const profiles = await CorePOSProfile.findAll();
    res.status(200).json(profiles);
  } catch (error) {
    logger.error(`Error fetching CorePOS profiles: ${error.message}`);
    res.status(500).json({ message: 'Error fetching CorePOS profiles', error });
  }
};

exports.getCorePOSProfileById = async (req, res) => {
  try {
    const profile = await CorePOSProfile.findByPk(req.params.id);
    if (!profile) return res.status(404).json({ message: 'CorePOS profile not found' });
    res.status(200).json(profile);
  } catch (error) {
    logger.error(`Error fetching CorePOS profile by ID (${req.params.id}): ${error.message}`);
    res.status(500).json({ message: 'Error fetching CorePOS profile', error });
  }
};

exports.createCorePOSProfile = async (req, res) => {
  try {
    const newProfile = await CorePOSProfile.create(req.body);
    logger.info(`CorePOS profile created: ${newProfile.id}`);
    res.status(201).json(newProfile);
  } catch (error) {
    logger.error(`Error creating CorePOS profile: ${error.message}`);
    res.status(500).json({ message: 'Error creating CorePOS profile', error });
  }
};

exports.updateCorePOSProfile = async (req, res) => {
  try {
    const [updated] = await CorePOSProfile.update(req.body, { where: { id: req.params.id } });
    if (!updated) return res.status(404).json({ message: 'CorePOS profile not found' });

    const updatedProfile = await CorePOSProfile.findByPk(req.params.id);
    logger.info(`CorePOS profile updated: ${req.params.id}`);
    res.status(200).json(updatedProfile);
  } catch (error) {
    logger.error(`Error updating CorePOS profile: ${error.message}`);
    res.status(500).json({ message: 'Error updating CorePOS profile', error });
  }
};

exports.deleteCorePOSProfile = async (req, res) => {
  try {
    const deleted = await CorePOSProfile.destroy({ where: { id: req.params.id } });
    if (!deleted) return res.status(404).json({ message: 'CorePOS profile not found' });

    logger.info(`CorePOS profile deleted: ${req.params.id}`);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting CorePOS profile: ${error.message}`);
    res.status(500).json({ message: 'Error deleting CorePOS profile', error });
  }
};

================
File: src/controllers/dashboardController.js
================
const { Client, Order, MenuItem, User } = require('../models');
const { redisClient } = require('../config/redis');

exports.getDashboardData = async (req, res) => {
  const { clientId } = req.params;
  const { page = 1, limit = 10 } = req.query;
  const offset = (page - 1) * limit;

  try {
    const data = await DashboardData.findAndCountAll({
      where: { clientId },
      limit: parseInt(limit),
      offset: parseInt(offset),
    });

    res.json({
      data: data.rows,
      totalPages: Math.ceil(data.count / limit),
      currentPage: page,
    });
  } catch (error) {
    console.error('Error fetching dashboard data:', error);
    res.status(500).json({ message: 'Error fetching dashboard data' });
  }
};

exports.getGlobalDashboardData = async (req, res) => {
  try {
    const cacheKey = 'dashboard:global';
    
    const cachedData = await redisClient.get(cacheKey);
    if (cachedData) {
      return res.json(JSON.parse(cachedData));
    }

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const [totalRevenue, totalOrders, activeUsers, newCustomers, topSellingItems, totalClients] = await Promise.all([
      Order.sum('total', { where: { createdAt: { [Op.gte]: today } } }),
      Order.count({ where: { createdAt: { [Op.gte]: today } } }),
      User.count({ where: { lastLoginDate: { [Op.gte]: today } } }),
      User.count({ where: { createdAt: { [Op.gte]: today } } }),
      MenuItem.findAll({
        attributes: ['name', [sequelize.fn('COUNT', sequelize.col('orderItems.id')), 'orderCount']],
        include: [{
          model: OrderItem,
          attributes: [],
          where: { createdAt: { [Op.gte]: today } }
        }],
        group: ['MenuItem.id'],
        order: [[sequelize.literal('orderCount'), 'DESC']],
        limit: 5
      }),
      Client.count()
    ]);

    const averageOrderValue = totalOrders > 0 ? totalRevenue / totalOrders : 0;

    const dashboardData = {
      totalRevenue,
      totalOrders,
      averageOrderValue,
      activeUsers,
      newCustomers,
      topSellingItems: topSellingItems.map(item => item.name),
      totalClients
    };

    await redisClient.setex(cacheKey, 300, JSON.stringify(dashboardData)); // Cache for 5 minutes

    res.json(dashboardData);
  } catch (error) {
    console.error('Error fetching global dashboard data:', error);
    res.status(500).json({ message: 'Error fetching global dashboard data' });
  }
};

================
File: src/controllers/dataWallController.js
================
const DataWall = require('../models/DataWall');

exports.createDataWall = async (req, res) => {
  const { name, accessLevel, locationId, reportId, permissions } = req.body;

  try {
    if (!req.user.locations.includes(locationId)) {
      return res.status(403).json({ message: 'Access denied to this location.' });
    }

    const dataWall = await DataWall.create({
      name,
      accessLevel,
      locationId,
      reportId,
      permissions,
    });

    res.status(201).json(dataWall);
  } catch (error) {
    res.status(500).json({ message: 'Error creating data wall', error });
  }
};

exports.getDataWallsByLocation = async (req, res) => {
  const { locationId } = req.params;

  try {
    if (!req.user.locations.includes(locationId)) {
      return res.status(403).json({ message: 'Access denied to this location.' });
    }

    const dataWalls = await DataWall.findAll({ where: { locationId } });
    res.json(dataWalls);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching data walls', error });
  }
};

================
File: src/controllers/deliveryDriverController.js
================
const deliveryDriverService = require('../services/deliveryDriverService');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const getAllDeliveryDrivers = async (req, res, next) => {
  try {
    const drivers = await deliveryDriverService.getAllDeliveryDrivers(req.user.clientId);
    res.status(200).json(drivers);
  } catch (error) {
    logger.error('Error fetching delivery drivers:', error);
    next(new AppError('Error fetching delivery drivers', 500));
  }
};

const getDeliveryDriverById = async (req, res, next) => {
  try {
    const driver = await deliveryDriverService.getDeliveryDriverById(req.params.id, req.user.clientId);
    if (!driver) {
      return next(new AppError('Delivery driver not found', 404));
    }
    res.status(200).json(driver);
  } catch (error) {
    logger.error(`Error fetching delivery driver ${req.params.id}:`, error);
    next(error);
  }
};

const createDeliveryDriver = async (req, res, next) => {
  try {
    const newDriver = await deliveryDriverService.createDeliveryDriver(req.body, req.user.clientId);
    res.status(201).json(newDriver);
  } catch (error) {
    logger.error('Error creating delivery driver:', error);
    next(error);
  }
};

const updateDeliveryDriver = async (req, res, next) => {
  try {
    const updatedDriver = await deliveryDriverService.updateDeliveryDriver(req.params.id, req.body, req.user.clientId);
    if (!updatedDriver) {
      return next(new AppError('Delivery driver not found', 404));
    }
    res.status(200).json(updatedDriver);
  } catch (error) {
    logger.error(`Error updating delivery driver ${req.params.id}:`, error);
    next(error);
  }
};

const deleteDeliveryDriver = async (req, res, next) => {
  try {
    const result = await deliveryDriverService.deleteDeliveryDriver(req.params.id, req.user.clientId);
    if (!result) {
      return next(new AppError('Delivery driver not found', 404));
    }
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting delivery driver ${req.params.id}:`, error);
    next(error);
  }
};

const getActiveDeliveries = async (req, res, next) => {
  try {
    const activeDeliveries = await deliveryDriverService.getActiveDeliveries(req.params.id, req.user.clientId);
    res.status(200).json(activeDeliveries);
  } catch (error) {
    logger.error(`Error fetching active deliveries for driver ${req.params.id}:`, error);
    next(error);
  }
};

const updateDeliveryStatus = async (req, res, next) => {
  try {
    const updatedDelivery = await deliveryDriverService.updateDeliveryStatus(req.params.id, req.params.deliveryId, req.body.status, req.user.clientId);
    if (!updatedDelivery) {
      return next(new AppError('Delivery not found', 404));
    }
    res.status(200).json(updatedDelivery);
  } catch (error) {
    logger.error(`Error updating delivery status for delivery ${req.params.deliveryId}:`, error);
    next(error);
  }
};

module.exports = {
  getAllDeliveryDrivers,
  getDeliveryDriverById,
  createDeliveryDriver,
  updateDeliveryDriver,
  deleteDeliveryDriver,
  getActiveDeliveries,
  updateDeliveryStatus
};

================
File: src/controllers/discountController.js
================
const discountService = require('../services/discountService');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const getAllDiscounts = async (req, res, next) => {
  try {
    const discounts = await discountService.getAllDiscounts(req.user.clientId);
    res.status(200).json(discounts);
  } catch (error) {
    logger.error('Error fetching discounts:', error);
    next(new AppError('Error fetching discounts', 500));
  }
};

const getDiscountById = async (req, res, next) => {
  try {
    const discount = await discountService.getDiscountById(req.params.id, req.user.clientId);
    if (!discount) {
      return next(new AppError('Discount not found', 404));
    }
    res.status(200).json(discount);
  } catch (error) {
    logger.error(`Error fetching discount ${req.params.id}:`, error);
    next(error);
  }
};

const createDiscount = async (req, res, next) => {
  try {
    const { name, type, value, conditions, locationId, isGlobal, maxUsesPerGuest } = req.body;

    if (!name || !type || !value) {
      return next(new AppError('Name, type, and value are required fields.', 422));
    }

    const newDiscount = await discountService.createDiscount({
      name,
      type,
      value,
      conditions,
      locationId,
      isGlobal,
      maxUsesPerGuest,
      status: 'active',
      clientId: req.user.clientId
    });

    logger.info(`Discount ${newDiscount.name} created by User ${req.user.id} at IP ${req.ip}`);
    res.status(201).json(newDiscount);
  } catch (error) {
    logger.error(`Error creating discount: ${error.message}`, { userId: req.user.id, ip: req.ip });
    next(new AppError('Failed to create discount', 500));
  }
};

const updateDiscount = async (req, res, next) => {
  try {
    const updatedDiscount = await discountService.updateDiscount(req.params.id, req.body, req.user.clientId);
    if (!updatedDiscount) {
      return next(new AppError('Discount not found', 404));
    }
    res.status(200).json(updatedDiscount);
  } catch (error) {
    logger.error(`Error updating discount ${req.params.id}:`, error);
    next(error);
  }
};

const deleteDiscount = async (req, res, next) => {
  try {
    const result = await discountService.deleteDiscount(req.params.id, req.user.clientId);
    if (!result) {
      return next(new AppError('Discount not found', 404));
    }
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting discount ${req.params.id}:`, error);
    next(error);
  }
};

const getDiscountsByLocation = async (req, res, next) => {
  try {
    const { locationId } = req.params;
    const discounts = await discountService.getDiscountsByLocation(locationId, req.user.clientId);
    logger.info(`Discounts retrieved by User ${req.user.id} for Location ${locationId}`);
    res.status(200).json(discounts);
  } catch (error) {
    logger.error(`Error retrieving discounts for Location ${req.params.locationId}: ${error.message}`, { userId: req.user.id, ip: req.ip });
    next(new AppError('Failed to retrieve discounts', 500));
  }
};

module.exports = {
  getAllDiscounts,
  getDiscountById,
  createDiscount,
  updateDiscount,
  deleteDiscount,
  getDiscountsByLocation
};

================
File: src/controllers/discountItemController.js
================
const { DiscountItem } = require('../models');
const logger = require('../services/logger');

exports.getAllDiscountItems = async (req, res) => {
  try {
    const discountItems = await DiscountItem.findAll();
    res.status(200).json(discountItems);
  } catch (error) {
    logger.error(`Error fetching discount items: ${error.message}`);
    res.status(500).json({ message: 'Error fetching discount items', error });
  }
};

exports.getDiscountItemById = async (req, res) => {
  try {
    const discountItem = await DiscountItem.findByPk(req.params.id);
    if (!discountItem) return res.status(404).json({ message: 'Discount item not found' });
    res.status(200).json(discountItem);
  } catch (error) {
    logger.error(`Error fetching discount item by ID (${req.params.id}): ${error.message}`);
    res.status(500).json({ message: 'Error fetching discount item', error });
  }
};

exports.createDiscountItem = async (req, res) => {
  try {
    const newDiscountItem = await DiscountItem.create(req.body);
    logger.info(`Discount item created: ${newDiscountItem.id}`);
    res.status(201).json(newDiscountItem);
  } catch (error) {
    logger.error(`Error creating discount item: ${error.message}`);
    res.status(500).json({ message: 'Error creating discount item', error });
  }
};

exports.updateDiscountItem = async (req, res) => {
  try {
    const [updated] = await DiscountItem.update(req.body, { where: { id: req.params.id } });
    if (!updated) return res.status(404).json({ message: 'Discount item not found' });

    const updatedDiscountItem = await DiscountItem.findByPk(req.params.id);
    logger.info(`Discount item updated: ${req.params.id}`);
    res.status(200).json(updatedDiscountItem);
  } catch (error) {
    logger.error(`Error updating discount item: ${error.message}`);
    res.status(500).json({ message: 'Error updating discount item', error });
  }
};

exports.deleteDiscountItem = async (req, res) => {
  try {
    const deleted = await DiscountItem.destroy({ where: { id: req.params.id } });
    if (!deleted) return res.status(404).json({ message: 'Discount item not found' });

    logger.info(`Discount item deleted: ${req.params.id}`);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting discount item: ${error.message}`);
    res.status(500).json({ message: 'Error deleting discount item', error });
  }
};

================
File: src/controllers/discountsController.js
================
const Discount = require('../models/Discount');

exports.applyDiscount = async (req, res) => {
  const { discountCode } = req.body;

  try {
    const discount = await Discount.findOne({ where: { code: discountCode } });

    if (!discount || !discount.isActive) {
      return res.status(400).json({ message: 'Invalid or inactive discount code.' });
    }

    res.json({ message: 'Discount applied successfully.', discount });
  } catch (error) {
    res.status(500).json({ message: 'Error applying discount', error });
  }
};

================
File: src/controllers/driverLocationsController.js
================
const { DriverLocation } = require('../models');
const logger = require('../services/logger');

exports.getAllDriverLocations = async (req, res) => {
  try {
    const locations = await DriverLocation.findAll();
    res.status(200).json(locations);
  } catch (error) {
    logger.error(`Error fetching driver locations: ${error.message}`);
    res.status(500).json({ message: 'Error fetching driver locations', error });
  }
};

exports.getDriverLocationById = async (req, res) => {
  try {
    const location = await DriverLocation.findByPk(req.params.id);
    if (!location) return res.status(404).json({ message: 'Driver location not found' });
    res.status(200).json(location);
  } catch (error) {
    logger.error(`Error fetching driver location by ID (${req.params.id}): ${error.message}`);
    res.status(500).json({ message: 'Error fetching driver location', error });
  }
};

exports.createDriverLocation = async (req, res) => {
  try {
    const newLocation = await DriverLocation.create(req.body);
    logger.info(`Driver location created: ${newLocation.id}`);
    res.status(201).json(newLocation);
  } catch (error) {
    logger.error(`Error creating driver location: ${error.message}`);
    res.status(500).json({ message: 'Error creating driver location', error });
  }
};

exports.updateDriverLocation = async (req, res) => {
  try {
    const [updated] = await DriverLocation.update(req.body, { where: { id: req.params.id } });
    if (!updated) return res.status(404).json({ message: 'Driver location not found' });

    const updatedLocation = await DriverLocation.findByPk(req.params.id);
    logger.info(`Driver location updated: ${req.params.id}`);
    res.status(200).json(updatedLocation);
  } catch (error) {
    logger.error(`Error updating driver location: ${error.message}`);
    res.status(500).json({ message: 'Error updating driver location', error });
  }
};

exports.deleteDriverLocation = async (req, res) => {
  try {
    const deleted = await DriverLocation.destroy({ where: { id: req.params.id } });
    if (!deleted) return res.status(404).json({ message: 'Driver location not found' });

    logger.info(`Driver location deleted: ${req.params.id}`);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting driver location: ${error.message}`);
    res.status(500).json({ message: 'Error deleting driver location', error });
  }
};

================
File: src/controllers/dropoffScheduleController.js
================
const { DropoffSchedule } = require('../models');
const logger = require('../services/logger');

exports.getAllDropoffSchedules = async (req, res) => {
  try {
    const schedules = await DropoffSchedule.findAll();
    res.status(200).json(schedules);
  } catch (error) {
    logger.error(`Error fetching drop-off schedules: ${error.message}`);
    res.status(500).json({ message: 'Error fetching drop-off schedules', error });
  }
};

exports.getDropoffScheduleById = async (req, res) => {
  try {
    const schedule = await DropoffSchedule.findByPk(req.params.id);
    if (!schedule) return res.status(404).json({ message: 'Drop-off schedule not found' });
    res.status(200).json(schedule);
  } catch (error) {
    logger.error(`Error fetching drop-off schedule by ID (${req.params.id}): ${error.message}`);
    res.status(500).json({ message: 'Error fetching drop-off schedule', error });
  }
};

exports.createDropoffSchedule = async (req, res) => {
  try {
    const newSchedule = await DropoffSchedule.create(req.body);
    logger.info(`Drop-off schedule created: ${newSchedule.id}`);
    res.status(201).json(newSchedule);
  } catch (error) {
    logger.error(`Error creating drop-off schedule: ${error.message}`);
    res.status(500).json({ message: 'Error creating drop-off schedule', error });
  }
};

exports.updateDropoffSchedule = async (req, res) => {
  try {
    const [updated] = await DropoffSchedule.update(req.body, { where: { id: req.params.id } });
    if (!updated) return res.status(404).json({ message: 'Drop-off schedule not found' });

    const updatedSchedule = await DropoffSchedule.findByPk(req.params.id);
    logger.info(`Drop-off schedule updated: ${req.params.id}`);
    res.status(200).json(updatedSchedule);
  } catch (error) {
    logger.error(`Error updating drop-off schedule: ${error.message}`);
    res.status(500).json({ message: 'Error updating drop-off schedule', error });
  }
};

exports.deleteDropoffSchedule = async (req, res) => {
  try {
    const deleted = await DropoffSchedule.destroy({ where: { id: req.params.id } });
    if (!deleted) return res.status(404).json({ message: 'Drop-off schedule not found' });

    logger.info(`Drop-off schedule deleted: ${req.params.id}`);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting drop-off schedule: ${error.message}`);
    res.status(500).json({ message: 'Error deleting drop-off schedule', error });
  }
};

================
File: src/controllers/dropOffSpotController.js
================
const db = require('../models');
const logger = require('../services/logger');

// Create a new drop-off spot
exports.createDropOffSpot = async (req, res) => {
  try {
    const { locationId } = req.params;
    const spotDetails = req.body;

    const location = await db.Location.findByPk(locationId);
    if (!location) {
      return res.status(404).json({ message: 'Location not found' });
    }

    const newDropOffSpot = await db.DropOffSpot.create({
      ...spotDetails,
      locationId,
    });

    logger.info(`Drop-off spot created for location ID ${locationId}`);
    res.status(201).json(newDropOffSpot);
  } catch (error) {
    logger.error(`Error creating drop-off spot: ${error.message}`);
    res.status(500).json({ message: 'Error creating drop-off spot', error });
  }
};

// Update an existing drop-off spot
exports.updateDropOffSpot = async (req, res) => {
  try {
    const { spotId } = req.params;
    const spotDetails = req.body;

    const dropOffSpot = await db.DropOffSpot.findByPk(spotId);
    if (!dropOffSpot) {
      return res.status(404).json({ message: 'Drop-off spot not found' });
    }

    await dropOffSpot.update(spotDetails);

    logger.info(`Drop-off spot updated: ID ${spotId}`);
    res.status(200).json(dropOffSpot);
  } catch (error) {
    logger.error(`Error updating drop-off spot: ${error.message}`);
    res.status(500).json({ message: 'Error updating drop-off spot', error });
  }
};

// Fetch all drop-off spots for a location
exports.getDropOffSpots = async (req, res) => {
  try {
    const { locationId } = req.params;

    const dropOffSpots = await db.DropOffSpot.findAll({ where: { locationId } });

    res.status(200).json(dropOffSpots);
  } catch (error) {
    logger.error(`Error fetching drop-off spots: ${error.message}`);
    res.status(500).json({ message: 'Error fetching drop-off spots', error });
  }
};

// Fetch a single drop-off spot by ID
exports.getDropOffSpotById = async (req, res) => {
  try {
    const { spotId } = req.params;

    const dropOffSpot = await db.DropOffSpot.findByPk(spotId);
    if (!dropOffSpot) {
      return res.status(404).json({ message: 'Drop-off spot not found' });
    }

    res.status(200).json(dropOffSpot);
  } catch (error) {
    logger.error(`Error fetching drop-off spot: ${error.message}`);
    res.status(500).json({ message: 'Error fetching drop-off spot', error });
  }
};

// Delete a drop-off spot
exports.deleteDropOffSpot = async (req, res) => {
  try {
    const { spotId } = req.params;

    const dropOffSpot = await db.DropOffSpot.findByPk(spotId);
    if (!dropOffSpot) {
      return res.status(404).json({ message: 'Drop-off spot not found' });
    }

    await dropOffSpot.destroy();

    logger.info(`Drop-off spot deleted: ID ${spotId}`);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting drop-off spot: ${error.message}`);
    res.status(500).json({ message: 'Error deleting drop-off spot', error });
  }
};

================
File: src/controllers/featureManagementController.js
================
const featureManagementService = require('../services/featureManagementService');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const getClientFeatures = async (req, res, next) => {
  try {
    const features = await featureManagementService.getClientFeatures(req.params.clientId);
    res.status(200).json(features);
  } catch (error) {
    logger.error(`Error fetching features for client ${req.params.clientId}:`, error);
    next(new AppError('Error fetching client features', 500));
  }
};

const updateClientFeatures = async (req, res, next) => {
  try {
    const updatedFeatures = await featureManagementService.updateClientFeatures(req.params.clientId, req.body);
    res.status(200).json(updatedFeatures);
  } catch (error) {
    logger.error(`Error updating features for client ${req.params.clientId}:`, error);
    next(new AppError('Error updating client features', 500));
  }
};

const getAllAvailableFeatures = async (req, res, next) => {
  try {
    const features = await featureManagementService.getAllAvailableFeatures();
    res.status(200).json(features);
  } catch (error) {
    logger.error('Error fetching all available features:', error);
    next(new AppError('Error fetching available features', 500));
  }
};

const createFeature = async (req, res, next) => {
  try {
    const newFeature = await featureManagementService.createFeature(req.body);
    res.status(201).json(newFeature);
  } catch (error) {
    logger.error('Error creating new feature:', error);
    next(new AppError('Error creating feature', 500));
  }
};

const updateFeature = async (req, res, next) => {
  try {
    const updatedFeature = await featureManagementService.updateFeature(req.params.featureId, req.body);
    res.status(200).json(updatedFeature);
  } catch (error) {
    logger.error(`Error updating feature ${req.params.featureId}:`, error);
    next(new AppError('Error updating feature', 500));
  }
};

const deleteFeature = async (req, res, next) => {
  try {
    await featureManagementService.deleteFeature(req.params.featureId);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting feature ${req.params.featureId}:`, error);
    next(new AppError('Error deleting feature', 500));
  }
};

module.exports = {
  getClientFeatures,
  updateClientFeatures,
  getAllAvailableFeatures,
  createFeature,
  updateFeature,
  deleteFeature
};

================
File: src/controllers/globalMenuController.js
================
const { GlobalMenu } = require('../models');
const logger = require('../services/logger');

exports.getAllGlobalMenus = async (req, res) => {
  try {
    const menus = await GlobalMenu.findAll();
    res.status(200).json(menus);
  } catch (error) {
    logger.error(`Error fetching global menus: ${error.message}`);
    res.status(500).json({ message: 'Error fetching global menus', error });
  }
};

exports.getGlobalMenuById = async (req, res) => {
  try {
    const menu = await GlobalMenu.findByPk(req.params.id);
    if (!menu) return res.status(404).json({ message: 'Global menu not found' });
    res.status(200).json(menu);
  } catch (error) {
    logger.error(`Error fetching global menu by ID (${req.params.id}): ${error.message}`);
    res.status(500).json({ message: 'Error fetching global menu', error });
  }
};

exports.createGlobalMenu = async (req, res) => {
  try {
    const newMenu = await GlobalMenu.create(req.body);
    logger.info(`Global menu created: ${newMenu.id}`);
    res.status(201).json(newMenu);
  } catch (error) {
    logger.error(`Error creating global menu: ${error.message}`);
    res.status(500).json({ message: 'Error creating global menu', error });
  }
};

exports.updateGlobalMenu = async (req, res) => {
  try {
    const [updated] = await GlobalMenu.update(req.body, { where: { id: req.params.id } });
    if (!updated) return res.status(404).json({ message: 'Global menu not found' });

    const updatedMenu = await GlobalMenu.findByPk(req.params.id);
    logger.info(`Global menu updated: ${req.params.id}`);
    res.status(200).json(updatedMenu);
  } catch (error) {
    logger.error(`Error updating global menu: ${error.message}`);
    res.status(500).json({ message: 'Error updating global menu', error });
  }
};

exports.deleteGlobalMenu = async (req, res) => {
  try {
    const deleted = await GlobalMenu.destroy({ where: { id: req.params.id } });
    if (!deleted) return res.status(404).json({ message: 'Global menu not found' });

    logger.info(`Global menu deleted: ${req.params.id}`);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting global menu: ${error.message}`);
    res.status(500).json({ message: 'Error deleting global menu', error });
  }
};

================
File: src/controllers/globalSettingController.js
================
const { GlobalSetting } = require('../models');
const logger = require('../services/logger');

exports.getAllGlobalSettings = async (req, res) => {
  try {
    const settings = await GlobalSetting.findAll();
    res.status(200).json(settings);
  } catch (error) {
    logger.error(`Error fetching global settings: ${error.message}`);
    res.status(500).json({ message: 'Error fetching global settings', error });
  }
};

exports.getGlobalSettingById = async (req, res) => {
  try {
    const setting = await GlobalSetting.findByPk(req.params.id);
    if (!setting) return res.status(404).json({ message: 'Global setting not found' });
    res.status(200).json(setting);
  } catch (error) {
    logger.error(`Error fetching global setting by ID (${req.params.id}): ${error.message}`);
    res.status(500).json({ message: 'Error fetching global setting', error });
  }
};

exports.createGlobalSetting = async (req, res) => {
  try {
    const newSetting = await GlobalSetting.create(req.body);
    logger.info(`Global setting created: ${newSetting.id}`);
    res.status(201).json(newSetting);
  } catch (error) {
    logger.error(`Error creating global setting: ${error.message}`);
    res.status(500).json({ message: 'Error creating global setting', error });
  }
};

exports.updateGlobalSetting = async (req, res) => {
  try {
    const [updated] = await GlobalSetting.update(req.body, { where: { id: req.params.id } });
    if (!updated) return res.status(404).json({ message: 'Global setting not found' });

    const updatedSetting = await GlobalSetting.findByPk(req.params.id);
    logger.info(`Global setting updated: ${req.params.id}`);
    res.status(200).json(updatedSetting);
  } catch (error) {
    logger.error(`Error updating global setting: ${error.message}`);
    res.status(500).json({ message: 'Error updating global setting', error });
  }
};

exports.deleteGlobalSetting = async (req, res) => {
  try {
    const deleted = await GlobalSetting.destroy({ where: { id: req.params.id } });
    if (!deleted) return res.status(404).json({ message: 'Global setting not found' });

    logger.info(`Global setting deleted: ${req.params.id}`);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting global setting: ${error.message}`);
    res.status(500).json({ message: 'Error deleting global setting', error });
  }
};

================
File: src/controllers/guestController.js
================
const { Request, Response } = require ('express');
const { getMenuItems, checkInventory } = require ('../services/menuService');
const { createOrder } = require('../services/orderService');
const { calculatePrepTime, formatEstimatedTime } = require('../services/orderPrepService');
const guestService = require('../services/guestService');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const getMenuController = async (req, res) => {
  try {
    const { locationId } = req.params;
    const menuItems = await getMenuItems(parseInt(locationId));
    res.status(200).json(menuItems);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching menu items' });
  }
};

const checkInventoryController = async (req, res) => {
  try {
    const { items } = req.body;
    const inventoryStatus = await checkInventory(items);
    res.status(200).json(inventoryStatus);
  } catch (error) {
    res.status(500).json({ message: 'Error checking inventory' });
  }
};

const createOrderController = async (req, res) => {
  try {
    const orderData = req.body;
    const newOrder = await createOrder(orderData);
    res.status(201).json(newOrder);
  } catch (error) {
    res.status(500).json({ message: 'Error creating order' });
  }
};

const getEstimatedPrepTimeController = async (req, res) => {
  try {
    const { items, locationId } = req.body;
    const prepTime = await calculatePrepTime({ items, locationId });
    const estimatedTime = formatEstimatedTime(prepTime);
    res.status(200).json({ estimatedTime });
  } catch (error) {
    res.status(500).json({ message: 'Error calculating estimated prep time' });
  }
};

const getAllGuests = async (req, res, next) => {
  try {
    const guests = await guestService.getAllGuests(req.user.clientId);
    res.status(200).json(guests);
  } catch (error) {
    logger.error('Error fetching all guests:', error);
    next(new AppError('Failed to fetch guests', 500));
  }
};

const getGuestById = async (req, res, next) => {
  try {
    const guest = await guestService.getGuestById(req.params.id, req.user.clientId);
    if (!guest) {
      return next(new AppError('Guest not found', 404));
    }
    res.status(200).json(guest);
  } catch (error) {
    logger.error(`Error fetching guest ${req.params.id}:`, error);
    next(error);
  }
};

const createGuest = async (req, res, next) => {
  try {
    const newGuest = await guestService.createGuest(req.body, req.user.clientId);
    res.status(201).json(newGuest);
  } catch (error) {
    logger.error('Error creating guest:', error);
    next(error);
  }
};

const updateGuest = async (req, res, next) => {
  try {
    const updatedGuest = await guestService.updateGuest(req.params.id, req.body, req.user.clientId);
    if (!updatedGuest) {
      return next(new AppError('Guest not found', 404));
    }
    res.status(200).json(updatedGuest);
  } catch (error) {
    logger.error(`Error updating guest ${req.params.id}:`, error);
    next(error);
  }
};

const deleteGuest = async (req, res, next) => {
  try {
    const result = await guestService.deleteGuest(req.params.id, req.user.clientId);
    if (!result) {
      return next(new AppError('Guest not found', 404));
    }
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting guest ${req.params.id}:`, error);
    next(error);
  }
};

module.exports = {
  getAllGuests,
  getGuestById,
  createGuest,
  updateGuest,
  deleteGuest
};

================
File: src/controllers/guestDiscountsController.js
================
const { GuestDiscount } = require('../models');
const logger = require('../services/logger');

exports.getAllGuestDiscounts = async (req, res) => {
  try {
    const discounts = await GuestDiscount.findAll();
    res.status(200).json(discounts);
  } catch (error) {
    logger.error(`Error fetching guest discounts: ${error.message}`);
    res.status(500).json({ message: 'Error fetching guest discounts', error });
  }
};

exports.getGuestDiscountById = async (req, res) => {
  try {
    const discount = await GuestDiscount.findByPk(req.params.id);
    if (!discount) return res.status(404).json({ message: 'Guest discount not found' });
    res.status(200).json(discount);
  } catch (error) {
    logger.error(`Error fetching guest discount by ID (${req.params.id}): ${error.message}`);
    res.status(500).json({ message: 'Error fetching guest discount', error });
  }
};

exports.createGuestDiscount = async (req, res) => {
  try {
    const newDiscount = await GuestDiscount.create(req.body);
    logger.info(`Guest discount created: ${newDiscount.id}`);
    res.status(201).json(newDiscount);
  } catch (error) {
    logger.error(`Error creating guest discount: ${error.message}`);
    res.status(500).json({ message: 'Error creating guest discount', error });
  }
};

exports.updateGuestDiscount = async (req, res) => {
  try {
    const [updated] = await GuestDiscount.update(req.body, { where: { id: req.params.id } });
    if (!updated) return res.status(404).json({ message: 'Guest discount not found' });

    const updatedDiscount = await GuestDiscount.findByPk(req.params.id);
    logger.info(`Guest discount updated: ${req.params.id}`);
    res.status(200).json(updatedDiscount);
  } catch (error) {
    logger.error(`Error updating guest discount: ${error.message}`);
    res.status(500).json({ message: 'Error updating guest discount', error });
  }
};

exports.deleteGuestDiscount = async (req, res) => {
  try {
    const deleted = await GuestDiscount.destroy({ where: { id: req.params.id } });
    if (!deleted) return res.status(404).json({ message: 'Guest discount not found' });

    logger.info(`Guest discount deleted: ${req.params.id}`);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting guest discount: ${error.message}`);
    res.status(500).json({ message: 'Error deleting guest discount', error });
  }
};

================
File: src/controllers/guestLoyaltyProgramController.js
================
const { GuestLoyaltyProgram } = require('../models');
const logger = require('../services/logger');

exports.getAllLoyaltyPrograms = async (req, res) => {
  try {
    const programs = await GuestLoyaltyProgram.findAll();
    res.status(200).json(programs);
  } catch (error) {
    logger.error(`Error fetching loyalty programs: ${error.message}`);
    res.status(500).json({ message: 'Error fetching loyalty programs', error });
  }
};

exports.getLoyaltyProgramById = async (req, res) => {
  try {
    const program = await GuestLoyaltyProgram.findByPk(req.params.id);
    if (!program) return res.status(404).json({ message: 'Loyalty program not found' });
    res.status(200).json(program);
  } catch (error) {
    logger.error(`Error fetching loyalty program by ID (${req.params.id}): ${error.message}`);
    res.status(500).json({ message: 'Error fetching loyalty program', error });
  }
};

exports.createLoyaltyProgram = async (req, res) => {
  try {
    const newProgram = await GuestLoyaltyProgram.create(req.body);
    logger.info(`Loyalty program created: ${newProgram.id}`);
    res.status(201).json(newProgram);
  } catch (error) {
    logger.error(`Error creating loyalty program: ${error.message}`);
    res.status(500).json({ message: 'Error creating loyalty program', error });
  }
};

exports.updateLoyaltyProgram = async (req, res) => {
  try {
    const [updated] = await GuestLoyaltyProgram.update(req.body, { where: { id: req.params.id } });
    if (!updated) return res.status(404).json({ message: 'Loyalty program not found' });

    const updatedProgram = await GuestLoyaltyProgram.findByPk(req.params.id);
    logger.info(`Loyalty program updated: ${req.params.id}`);
    res.status(200).json(updatedProgram);
  } catch (error) {
    logger.error(`Error updating loyalty program: ${error.message}`);
    res.status(500).json({ message: 'Error updating loyalty program', error });
  }
};

exports.deleteLoyaltyProgram = async (req, res) => {
  try {
    const deleted = await GuestLoyaltyProgram.destroy({ where: { id: req.params.id } });
    if (!deleted) return res.status(404).json({ message: 'Loyalty program not found' });

    logger.info(`Loyalty program deleted: ${req.params.id}`);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting loyalty program: ${error.message}`);
    res.status(500).json({ message: 'Error deleting loyalty program', error });
  }
};

================
File: src/controllers/guestProfileController.js
================
const { GuestProfile } = require('../models');
const logger = require('../services/logger');

exports.getAllGuestProfiles = async (req, res) => {
  try {
    const profiles = await GuestProfile.findAll();
    res.status(200).json(profiles);
  } catch (error) {
    logger.error(`Error fetching guest profiles: ${error.message}`);
    res.status(500).json({ message: 'Error fetching guest profiles', error });
  }
};

exports.getGuestProfileById = async (req, res) => {
  try {
    const profile = await GuestProfile.findByPk(req.params.id);
    if (!profile) return res.status(404).json({ message: 'Guest profile not found' });
    res.status(200).json(profile);
  } catch (error) {
    logger.error(`Error fetching guest profile by ID (${req.params.id}): ${error.message}`);
    res.status(500).json({ message: 'Error fetching guest profile', error });
  }
};

exports.createGuestProfile = async (req, res) => {
  try {
    const newProfile = await GuestProfile.create(req.body);
    logger.info(`Guest profile created: ${newProfile.id}`);
    res.status(201).json(newProfile);
  } catch (error) {
    logger.error(`Error creating guest profile: ${error.message}`);
    res.status(500).json({ message: 'Error creating guest profile', error });
  }
};

exports.updateGuestProfile = async (req, res) => {
  try {
    const [updated] = await GuestProfile.update(req.body, { where: { id: req.params.id } });
    if (!updated) return res.status(404).json({ message: 'Guest profile not found' });

    const updatedProfile = await GuestProfile.findByPk(req.params.id);
    logger.info(`Guest profile updated: ${req.params.id}`);
    res.status(200).json(updatedProfile);
  } catch (error) {
    logger.error(`Error updating guest profile: ${error.message}`);
    res.status(500).json({ message: 'Error updating guest profile', error });
  }
};

exports.deleteGuestProfile = async (req, res) => {
  try {
    const deleted = await GuestProfile.destroy({ where: { id: req.params.id } });
    if (!deleted) return res.status(404).json({ message: 'Guest profile not found' });

    logger.info(`Guest profile deleted: ${req.params.id}`);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting guest profile: ${error.message}`);
    res.status(500).json({ message: 'Error deleting guest profile', error });
  }
};

================
File: src/controllers/guestRewardsController.js
================
const { GuestReward } = require('../models');
const logger = require('../services/logger');

exports.getAllGuestRewards = async (req, res) => {
  try {
    const rewards = await GuestReward.findAll();
    res.status(200).json(rewards);
  } catch (error) {
    logger.error(`Error fetching guest rewards: ${error.message}`);
    res.status(500).json({ message: 'Error fetching guest rewards', error });
  }
};

exports.getGuestRewardById = async (req, res) => {
  try {
    const reward = await GuestReward.findByPk(req.params.id);
    if (!reward) return res.status(404).json({ message: 'Guest reward not found' });
    res.status(200).json(reward);
  } catch (error) {
    logger.error(`Error fetching guest reward by ID (${req.params.id}): ${error.message}`);
    res.status(500).json({ message: 'Error fetching guest reward', error });
  }
};

exports.createGuestReward = async (req, res) => {
  try {
    const newReward = await GuestReward.create(req.body);
    logger.info(`Guest reward created: ${newReward.id}`);
    res.status(201).json(newReward);
  } catch (error) {
    logger.error(`Error creating guest reward: ${error.message}`);
    res.status(500).json({ message: 'Error creating guest reward', error });
  }
};

exports.updateGuestReward = async (req, res) => {
  try {
    const [updated] = await GuestReward.update(req.body, { where: { id: req.params.id } });
    if (!updated) return res.status(404).json({ message: 'Guest reward not found' });

    const updatedReward = await GuestReward.findByPk(req.params.id);
    logger.info(`Guest reward updated: ${req.params.id}`);
    res.status(200).json(updatedReward);
  } catch (error) {
    logger.error(`Error updating guest reward: ${error.message}`);
    res.status(500).json({ message: 'Error updating guest reward', error });
  }
};

exports.deleteGuestReward = async (req, res) => {
  try {
    const deleted = await GuestReward.destroy({ where: { id: req.params.id } });
    if (!deleted) return res.status(404).json({ message: 'Guest reward not found' });

    logger.info(`Guest reward deleted: ${req.params.id}`);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting guest reward: ${error.message}`);
    res.status(500).json({ message: 'Error deleting guest reward', error });
  }
};

================
File: src/controllers/houseAccountController.js
================
const HouseAccount = require('../models/HouseAccount');
const HouseAccountUser = require('../models/HouseAccountUser');
const houseAccountService = require('../services/houseAccountService');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

exports.getHouseAccountsByClient = async (req, res, next) => {
  try {
    const accounts = await houseAccountService.getHouseAccountsByClient(req.params.clientId);
    res.status(200).json(accounts);
  } catch (error) {
    logger.error(`Error fetching house accounts for client ${req.params.clientId}:`, error);
    next(new AppError('Error fetching house accounts', 500));
  }
};

exports.getHouseAccountById = async (req, res, next) => {
  try {
    const account = await houseAccountService.getHouseAccountById(req.params.id);
    if (!account) {
      return next(new AppError('House account not found', 404));
    }
    res.status(200).json(account);
  } catch (error) {
    logger.error(`Error fetching house account ${req.params.id}:`, error);
    next(error);
  }
};

exports.createHouseAccount = async (req, res, next) => {
  try {
    const newAccount = await houseAccountService.createHouseAccount(req.body);
    res.status(201).json(newAccount);
  } catch (error) {
    logger.error('Error creating house account:', error);
    next(error);
  }
};

exports.updateHouseAccount = async (req, res, next) => {
  try {
    const updatedAccount = await houseAccountService.updateHouseAccount(req.params.id, req.body);
    if (!updatedAccount) {
      return next(new AppError('House account not found', 404));
    }
    res.status(200).json(updatedAccount);
  } catch (error) {
    logger.error(`Error updating house account ${req.params.id}:`, error);
    next(error);
  }
};

exports.deleteHouseAccount = async (req, res, next) => {
  try {
    const result = await houseAccountService.deleteHouseAccount(req.params.id);
    if (!result) {
      return next(new AppError('House account not found', 404));
    }
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting house account ${req.params.id}:`, error);
    next(error);
  }
};

exports.addFunds = async (req, res, next) => {
  try {
    const updatedAccount = await houseAccountService.addFunds(req.params.id, req.body.amount);
    res.status(200).json(updatedAccount);
  } catch (error) {
    logger.error(`Error adding funds to house account ${req.params.id}:`, error);
    next(error);
  }
};

exports.deductFunds = async (req, res, next) => {
  try {
    const updatedAccount = await houseAccountService.deductFunds(req.params.id, req.body.amount);
    res.status(200).json(updatedAccount);
  } catch (error) {
    logger.error(`Error deducting funds from house account ${req.params.id}:`, error);
    next(error);
  }
};

exports.getTransactionHistory = async (req, res, next) => {
  try {
    const transactions = await houseAccountService.getTransactionHistory(req.params.id);
    res.status(200).json(transactions);
  } catch (error) {
    logger.error(`Error fetching transaction history for house account ${req.params.id}:`, error);
    next(error);
  }
};

================
File: src/controllers/houseAccountLocationsController.js
================
const { HouseAccountLocation } = require('../models');
const logger = require('../services/logger');

exports.getAllHouseAccountLocations = async (req, res) => {
  try {
    const locations = await HouseAccountLocation.findAll();
    res.status(200).json(locations);
  } catch (error) {
    logger.error(`Error fetching house account locations: ${error.message}`);
    res.status(500).json({ message: 'Error fetching house account locations', error });
  }
};

exports.getHouseAccountLocationById = async (req, res) => {
  try {
    const location = await HouseAccountLocation.findByPk(req.params.id);
    if (!location) return res.status(404).json({ message: 'House account location not found' });
    res.status(200).json(location);
  } catch (error) {
    logger.error(`Error fetching house account location by ID (${req.params.id}): ${error.message}`);
    res.status(500).json({ message: 'Error fetching house account location', error });
  }
};

exports.createHouseAccountLocation = async (req, res) => {
  try {
    const newLocation = await HouseAccountLocation.create(req.body);
    logger.info(`House account location created: ${newLocation.id}`);
    res.status(201).json(newLocation);
  } catch (error) {
    logger.error(`Error creating house account location: ${error.message}`);
    res.status(500).json({ message: 'Error creating house account location', error });
  }
};

exports.updateHouseAccountLocation = async (req, res) => {
  try {
    const [updated] = await HouseAccountLocation.update(req.body, { where: { id: req.params.id } });
    if (!updated) return res.status(404).json({ message: 'House account location not found' });

    const updatedLocation = await HouseAccountLocation.findByPk(req.params.id);
    logger.info(`House account location updated: ${req.params.id}`);
    res.status(200).json(updatedLocation);
  } catch (error) {
    logger.error(`Error updating house account location: ${error.message}`);
    res.status(500).json({ message: 'Error updating house account location', error });
  }
};

exports.deleteHouseAccountLocation = async (req, res) => {
  try {
    const deleted = await HouseAccountLocation.destroy({ where: { id: req.params.id } });
    if (!deleted) return res.status(404).json({ message: 'House account location not found' });

    logger.info(`House account location deleted: ${req.params.id}`);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting house account location: ${error.message}`);
    res.status(500).json({ message: 'Error deleting house account location', error });
  }
};

================
File: src/controllers/houseAccountUserController.js
================
const { HouseAccountUser } = require('../models');
const logger = require('../services/logger');

exports.getAllHouseAccountUsers = async (req, res) => {
  try {
    const users = await HouseAccountUser.findAll();
    res.status(200).json(users);
  } catch (error) {
    logger.error(`Error fetching house account users: ${error.message}`);
    res.status(500).json({ message: 'Error fetching house account users', error });
  }
};

exports.getHouseAccountUserById = async (req, res) => {
  try {
    const user = await HouseAccountUser.findByPk(req.params.id);
    if (!user) return res.status(404).json({ message: 'House account user not found' });
    res.status(200).json(user);
  } catch (error) {
    logger.error(`Error fetching house account user by ID (${req.params.id}): ${error.message}`);
    res.status(500).json({ message: 'Error fetching house account user', error });
  }
};

exports.createHouseAccountUser = async (req, res) => {
  try {
    const newUser = await HouseAccountUser.create(req.body);
    logger.info(`House account user created: ${newUser.id}`);
    res.status(201).json(newUser);
  } catch (error) {
    logger.error(`Error creating house account user: ${error.message}`);
    res.status(500).json({ message: 'Error creating house account user', error });
  }
};

exports.updateHouseAccountUser = async (req, res) => {
  try {
    const [updated] = await HouseAccountUser.update(req.body, { where: { id: req.params.id } });
    if (!updated) return res.status(404).json({ message: 'House account user not found' });

    const updatedUser = await HouseAccountUser.findByPk(req.params.id);
    logger.info(`House account user updated: ${req.params.id}`);
    res.status(200).json(updatedUser);
  } catch (error) {
    logger.error(`Error updating house account user: ${error.message}`);
    res.status(500).json({ message: 'Error updating house account user', error });
  }
};

exports.deleteHouseAccountUser = async (req, res) => {
  try {
    const deleted = await HouseAccountUser.destroy({ where: { id: req.params.id } });
    if (!deleted) return res.status(404).json({ message: 'House account user not found' });

    logger.info(`House account user deleted: ${req.params.id}`);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting house account user: ${error.message}`);
    res.status(500).json({ message: 'Error deleting house account user', error });
  }
};

================
File: src/controllers/inventoryController.js
================
const inventoryService = require('../services/inventoryService');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const getInventory = async (req, res, next) => {
  try {
    const inventory = await inventoryService.getInventoryItems();
    res.json(inventory);
  } catch (error) {
    logger.error('Error fetching inventory:', error);
    next(new AppError('Error fetching inventory', 500));
  }
};

const getInventoryItemById = async (req, res, next) => {
  try {
    const item = await inventoryService.getInventoryItemById(req.params.id);
    if (!item) {
      return next(new AppError('Inventory item not found', 404));
    }
    res.json(item);
  } catch (error) {
    logger.error(`Error fetching inventory item ${req.params.id}:`, error);
    next(new AppError('Error fetching inventory item', 500));
  }
};

const addInventoryItem = async (req, res, next) => {
  try {
    const newItem = await inventoryService.createInventoryItem(req.body);
    res.status(201).json(newItem);
  } catch (error) {
    logger.error('Error adding inventory item:', error);
    next(new AppError('Error adding inventory item', 500));
  }
};

const updateInventory = async (req, res, next) => {
  try {
    const updatedItem = await inventoryService.updateInventoryItem(req.params.id, req.body);
    res.json(updatedItem);
  } catch (error) {
    logger.error(`Error updating inventory item ${req.params.id}:`, error);
    next(new AppError('Error updating inventory item', 500));
  }
};

const removeInventoryItem = async (req, res, next) => {
  try {
    await inventoryService.deleteInventoryItem(req.params.id);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error removing inventory item ${req.params.id}:`, error);
    next(new AppError('Error removing inventory item', 500));
  }
};

const updateInventoryQuantity = async (req, res, next) => {
  try {
    const updatedItem = await inventoryService.updateInventoryQuantity(req.params.id, req.body.quantity);
    res.json(updatedItem);
  } catch (error) {
    logger.error(`Error updating inventory quantity for item ${req.params.id}:`, error);
    next(new AppError('Error updating inventory quantity', 500));
  }
};

module.exports = {
  getInventory,
  getInventoryItemById,
  addInventoryItem,
  updateInventory,
  removeInventoryItem,
  updateInventoryQuantity
};

================
File: src/controllers/invoiceController.js
================
const invoiceService = require('../services/invoiceService');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

exports.generateInvoice = async (req, res, next) => {
  try {
    const invoice = await invoiceService.generateInvoice(req.body);
    res.status(201).json(invoice);
  } catch (error) {
    logger.error('Error generating invoice:', error);
    next(new AppError('Failed to generate invoice', 500));
  }
};

exports.getInvoiceById = async (req, res, next) => {
  try {
    const invoice = await invoiceService.getInvoiceById(req.params.id);
    if (!invoice) {
      return next(new AppError('Invoice not found', 404));
    }
    res.status(200).json(invoice);
  } catch (error) {
    logger.error(`Error fetching invoice ${req.params.id}:`, error);
    next(error);
  }
};

exports.getClientInvoices = async (req, res, next) => {
  try {
    const invoices = await invoiceService.getClientInvoices(req.params.clientId);
    res.status(200).json(invoices);
  } catch (error) {
    logger.error(`Error fetching invoices for client ${req.params.clientId}:`, error);
    next(error);
  }
};

exports.updateInvoice = async (req, res, next) => {
  try {
    const updatedInvoice = await invoiceService.updateInvoice(req.params.id, req.body);
    if (!updatedInvoice) {
      return next(new AppError('Invoice not found', 404));
    }
    res.status(200).json(updatedInvoice);
  } catch (error) {
    logger.error(`Error updating invoice ${req.params.id}:`, error);
    next(error);
  }
};

exports.deleteInvoice = async (req, res, next) => {
  try {
    const result = await invoiceService.deleteInvoice(req.params.id);
    if (!result) {
      return next(new AppError('Invoice not found', 404));
    }
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting invoice ${req.params.id}:`, error);
    next(error);
  }
};

================
File: src/controllers/itemModifierController.js
================
const { ItemModifier } = require('../models');
const logger = require('../services/logger');

exports.getAllItemModifiers = async (req, res) => {
  try {
    const modifiers = await ItemModifier.findAll();
    res.status(200).json(modifiers);
  } catch (error) {
    logger.error(`Error fetching item modifiers: ${error.message}`);
    res.status(500).json({ message: 'Error fetching item modifiers', error });
  }
};

exports.getItemModifierById = async (req, res) => {
  try {
    const modifier = await ItemModifier.findByPk(req.params.id);
    if (!modifier) return res.status(404).json({ message: 'Item modifier not found' });
    res.status(200).json(modifier);
  } catch (error) {
    logger.error(`Error fetching item modifier by ID (${req.params.id}): ${error.message}`);
    res.status(500).json({ message: 'Error fetching item modifier', error });
  }
};

exports.createItemModifier = async (req, res) => {
  try {
    const newModifier = await ItemModifier.create(req.body);
    logger.info(`Item modifier created: ${newModifier.id}`);
    res.status(201).json(newModifier);
  } catch (error) {
    logger.error(`Error creating item modifier: ${error.message}`);
    res.status(500).json({ message: 'Error creating item modifier', error });
  }
};

exports.updateItemModifier = async (req, res) => {
  try {
    const [updated] = await ItemModifier.update(req.body, { where: { id: req.params.id } });
    if (!updated) return res.status(404).json({ message: 'Item modifier not found' });

    const updatedModifier = await ItemModifier.findByPk(req.params.id);
    logger.info(`Item modifier updated: ${req.params.id}`);
    res.status(200).json(updatedModifier);
  } catch (error) {
    logger.error(`Error updating item modifier: ${error.message}`);
    res.status(500).json({ message: 'Error updating item modifier', error });
  }
};

exports.deleteItemModifier = async (req, res) => {
  try {
    const deleted = await ItemModifier.destroy({ where: { id: req.params.id } });
    if (!deleted) return res.status(404).json({ message: 'Item modifier not found' });

    logger.info(`Item modifier deleted: ${req.params.id}`);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting item modifier: ${error.message}`);
    res.status(500).json({ message: 'Error deleting item modifier', error });
  }
};

================
File: src/controllers/itemReviewController.js
================
const { ItemReview } = require('../models');
const logger = require('../services/logger');

exports.getAllItemReviews = async (req, res) => {
  try {
    const reviews = await ItemReview.findAll();
    res.status(200).json(reviews);
  } catch (error) {
    logger.error(`Error fetching item reviews: ${error.message}`);
    res.status(500).json({ message: 'Error fetching item reviews', error });
  }
};

exports.getItemReviewById = async (req, res) => {
  try {
    const review = await ItemReview.findByPk(req.params.id);
    if (!review) return res.status(404).json({ message: 'Item review not found' });
    res.status(200).json(review);
  } catch (error) {
    logger.error(`Error fetching item review by ID (${req.params.id}): ${error.message}`);
    res.status(500).json({ message: 'Error fetching item review', error });
  }
};

exports.createItemReview = async (req, res) => {
  try {
    const newReview = await ItemReview.create(req.body);
    logger.info(`Item review created: ${newReview.id}`);
    res.status(201).json(newReview);
  } catch (error) {
    logger.error(`Error creating item review: ${error.message}`);
    res.status(500).json({ message: 'Error creating item review', error });
  }
};

exports.updateItemReview = async (req, res) => {
  try {
    const [updated] = await ItemReview.update(req.body, { where: { id: req.params.id } });
    if (!updated) return res.status(404).json({ message: 'Item review not found' });

    const updatedReview = await ItemReview.findByPk(req.params.id);
    logger.info(`Item review updated: ${req.params.id}`);
    res.status(200).json(updatedReview);
  } catch (error) {
    logger.error(`Error updating item review: ${error.message}`);
    res.status(500).json({ message: 'Error updating item review', error });
  }
};

exports.deleteItemReview = async (req, res) => {
  try {
    const deleted = await ItemReview.destroy({ where: { id: req.params.id } });
    if (!deleted) return res.status(404).json({ message: 'Item review not found' });

    logger.info(`Item review deleted: ${req.params.id}`);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting item review: ${error.message}`);
    res.status(500).json({ message: 'Error deleting item review', error });
  }
};

================
File: src/controllers/locationCard.js
================
const LocationCard = require('../models/LocationCard');
const logger = require('../services/logger');

exports.getLocationCard = async (req, res) => {
  try {
    const { locationId } = req.params;
    const locationCard = await LocationCard.findByPk(locationId);

    if (!locationCard) {
      return res.status(404).json({ message: 'Location card not found' });
    }

    res.status(200).json(locationCard);
  } catch (error) {
    logger.error(`Error fetching location card: ${error.message}`);
    res.status(500).json({ message: 'Error fetching location card', error: error.message });
  }
};

exports.updateLocationCard = async (req, res) => {
  try {
    const { locationId } = req.params;
    const updateData = req.body;

    const locationCard = await LocationCard.findByPk(locationId);

    if (!locationCard) {
      return res.status(404).json({ message: 'Location card not found' });
    }

    await locationCard.update(updateData);

    res.status(200).json(locationCard);
  } catch (error) {
    logger.error(`Error updating location card: ${error.message}`);
    res.status(500).json({ message: 'Error updating location card', error: error.message });
  }
};

module.exports = exports;

================
File: src/controllers/locationController.js
================
const { Location } = require('../models');
const locationService = require('../services/locationService');
const { AppError } = require('../utils/errorHandler');

const getLocationsController = async (req, res) => {
  try {
    const locations = await locationService.getLocations();
    res.json(locations);
  } catch (error) {
    console.error('Error fetching locations:', error);
    res.status(500).json({ message: 'Error fetching locations' });
  }
};

const createLocationController = async (req, res) => {
  try {
    const location = await locationService.createLocation(req.body);
    res.status(201).json(location);
  } catch (error) {
    console.error('Error creating location:', error);
    if (error instanceof AppError) {
      res.status(error.statusCode).json({ message: error.message });
    } else {
      res.status(500).json({ message: 'Error creating location' });
    }
  }
};

const changeLocationStatusController = async (req, res) => {
  try {
    const { locationId, isOpen } = req.body;
    const updatedLocation = await locationService.updateLocationStatus(locationId, isOpen);
    res.status(200).json(updatedLocation);
  } catch (error) {
    console.error('Error updating location status:', error);
    res.status(500).json({ message: 'Error updating location status' });
  }
};

const getAllLocationsController = async (req, res) => {
  try {
    const locations = await locationService.getLocations();
    res.status(200).json(locations);
  } catch (error) {
    console.error('Error fetching locations:', error);
    res.status(500).json({ message: 'Error fetching locations' });
  }
};

const getLocationProfilesController = async (req, res) => {
  try {
    const profiles = await locationService.getLocationProfiles();
    res.status(200).json(profiles);
  } catch (error) {
    console.error('Error fetching location profiles:', error);
    res.status(500).json({ message: 'Error fetching location profiles' });
  }
};

module.exports = {
  getLocationsController,
  createLocationController,
  changeLocationStatusController,
  getAllLocationsController,
  getLocationProfilesController
};

================
File: src/controllers/locationController.ts
================
import { Request, Response } from 'express';
import { Location } from '../models/Location';
import { updateLocationStatus, getLocations } from '../services/locationService';
import { AppError } from '../utils/errorHandler';

export const getLocations = async (req: Request, res: Response) => {
  try {
    const locations = await Location.find();
    res.json(locations);
  } catch (error) {
    logger.error('Error fetching locations:', error);
    res.status(500).json({ message: 'Error fetching locations' });
  }
};

export const createLocation = async (req: Request, res: Response) => {
  try {
    const location = new Location(req.body);
    await location.save();
    res.status(201).json(location);
  } catch (error) {
    logger.error('Error creating location:', error);
    res.status(500).json({ message: 'Error creating location' });
  }
};

export const changeLocationStatus = async (req: Request, res: Response) => {
  try {
    const { locationId, isOpen } = req.body;
    const updatedLocation = await updateLocationStatus(locationId, isOpen);
    res.status(200).json(updatedLocation);
  } catch (error) {
    res.status(500).json({ message: 'Error updating location status', error });
  }
};

export const getAllLocations = async (req: Request, res: Response) => {
  try {
    const locations = await getLocations();
    res.status(200).json(locations);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching locations', error });
  }
};

// Implement other CRUD operations...

export const createLocationController = async (req: Request, res: Response) => {
  try {
    const locationData = req.body;
    const newLocation = await createLocation(locationData);
    res.status(201).json(newLocation);
  } catch (error) {
    if (error instanceof AppError) {
      res.status(error.statusCode).json({ message: error.message });
    } else {
      res.status(500).json({ message: 'Error creating location' });
    }
  }
};

export const getLocationsController = async (req: Request, res: Response) => {
  try {
    const locations = await getLocations();
    res.status(200).json(locations);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching locations' });
  }
};

export const getLocationProfilesController = async (req: Request, res: Response) => {
  try {
    const profiles = await getLocationProfiles();
    res.status(200).json(profiles);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching location profiles' });
  }
};

================
File: src/controllers/locationMenuGroupController.js
================
const { LocationMenuGroup } = require('../models');
const logger = require('../services/logger');

exports.getAllLocationMenuGroups = async (req, res) => {
  try {
    const menuGroups = await LocationMenuGroup.findAll();
    res.status(200).json(menuGroups);
  } catch (error) {
    logger.error(`Error fetching location menu groups: ${error.message}`);
    res.status(500).json({ message: 'Error fetching location menu groups', error });
  }
};

exports.getLocationMenuGroupById = async (req, res) => {
  try {
    const menuGroup = await LocationMenuGroup.findByPk(req.params.id);
    if (!menuGroup) return res.status(404).json({ message: 'Location menu group not found' });
    res.status(200).json(menuGroup);
  } catch (error) {
    logger.error(`Error fetching location menu group by ID (${req.params.id}): ${error.message}`);
    res.status(500).json({ message: 'Error fetching location menu group', error });
  }
};

exports.createLocationMenuGroup = async (req, res) => {
  try {
    const newMenuGroup = await LocationMenuGroup.create(req.body);
    logger.info(`Location menu group created: ${newMenuGroup.id}`);
    res.status(201).json(newMenuGroup);
  } catch (error) {
    logger.error(`Error creating location menu group: ${error.message}`);
    res.status(500).json({ message: 'Error creating location menu group', error });
  }
};

exports.updateLocationMenuGroup = async (req, res) => {
  try {
    const [updated] = await LocationMenuGroup.update(req.body, { where: { id: req.params.id } });
    if (!updated) return res.status(404).json({ message: 'Location menu group not found' });

    const updatedMenuGroup = await LocationMenuGroup.findByPk(req.params.id);
    logger.info(`Location menu group updated: ${req.params.id}`);
    res.status(200).json(updatedMenuGroup);
  } catch (error) {
    logger.error(`Error updating location menu group: ${error.message}`);
    res.status(500).json({ message: 'Error updating location menu group', error });
  }
};

exports.deleteLocationMenuGroup = async (req, res) => {
  try {
    const deleted = await LocationMenuGroup.destroy({ where: { id: req.params.id } });
    if (!deleted) return res.status(404).json({ message: 'Location menu group not found' });

    logger.info(`Location menu group deleted: ${req.params.id}`);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting location menu group: ${error.message}`);
    res.status(500).json({ message: 'Error deleting location menu group', error });
  }
};

================
File: src/controllers/locationPosProfileController.js
================
const { LocationPosProfile } = require('../models');
const logger = require('../services/logger');

exports.getAllLocationPosProfiles = async (req, res) => {
  try {
    const posProfiles = await LocationPosProfile.findAll();
    res.status(200).json(posProfiles);
  } catch (error) {
    logger.error(`Error fetching location POS profiles: ${error.message}`);
    res.status(500).json({ message: 'Error fetching location POS profiles', error });
  }
};

exports.getLocationPosProfileById = async (req, res) => {
  try {
    const posProfile = await LocationPosProfile.findByPk(req.params.id);
    if (!posProfile) return res.status(404).json({ message: 'Location POS profile not found' });
    res.status(200).json(posProfile);
  } catch (error) {
    logger.error(`Error fetching location POS profile by ID (${req.params.id}): ${error.message}`);
    res.status(500).json({ message: 'Error fetching location POS profile', error });
  }
};

exports.createLocationPosProfile = async (req, res) => {
  try {
    const newPosProfile = await LocationPosProfile.create(req.body);
    logger.info(`Location POS profile created: ${newPosProfile.id}`);
    res.status(201).json(newPosProfile);
  } catch (error) {
    logger.error(`Error creating location POS profile: ${error.message}`);
    res.status(500).json({ message: 'Error creating location POS profile', error });
  }
};

exports.updateLocationPosProfile = async (req, res) => {
  try {
    const [updated] = await LocationPosProfile.update(req.body, { where: { id: req.params.id } });
    if (!updated) return res.status(404).json({ message: 'Location POS profile not found' });

    const updatedPosProfile = await LocationPosProfile.findByPk(req.params.id);
    logger.info(`Location POS profile updated: ${req.params.id}`);
    res.status(200).json(updatedPosProfile);
  } catch (error) {
    logger.error(`Error updating location POS profile: ${error.message}`);
    res.status(500).json({ message: 'Error updating location POS profile', error });
  }
};

exports.deleteLocationPosProfile = async (req, res) => {
  try {
    const deleted = await LocationPosProfile.destroy({ where: { id: req.params.id } });
    if (!deleted) return res.status(404).json({ message: 'Location POS profile not found' });

    logger.info(`Location POS profile deleted: ${req.params.id}`);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting location POS profile: ${error.message}`);
    res.status(500).json({ message: 'Error deleting location POS profile', error });
  }
};

================
File: src/controllers/locationService.js
================
const db = require('../models');

class LocationService {
  // Create a new location
  async createLocation(clientId, locationDetails) {
    const client = await db.Client.findByPk(clientId);
    if (!client) {
      throw new Error('Client not found');
    }

    const location = await db.Location.create({
      ...locationDetails,
      clientId,
    });

    // Setup any default configurations or settings needed for the new location
    await this.setupDefaultLocationSettings(location);

    return location;
  }

  // Setup default settings for a new location
  async setupDefaultLocationSettings(location) {
    // Example: Setup default hours for the new location
    if (!location.hours) {
      location.hours = '9 AM - 5 PM'; // Default hours setup
      await location.save();
    }
    // Placeholder for further default settings logic
  }

  // Update location details
  async updateLocation(locationId, locationDetails) {
    const location = await db.Location.findByPk(locationId);
    if (!location) {
      throw new Error('Location not found');
    }

    return await location.update(locationDetails);
  }

  // Fetch all locations for a client
  async getLocations(clientId) {
    return await db.Location.findAll({ where: { clientId } });
  }

  // Fetch a single location by ID
  async getLocationById(locationId) {
    return await db.Location.findByPk(locationId);
  }

  // Delete a location
  async deleteLocation(locationId) {
    const location = await db.Location.findByPk(locationId);
    if (!location) {
      throw new Error('Location not found');
    }

    return await location.destroy();
  }

  // Create a drop-off spot for a location
  async createDropOffSpot(locationId, spotDetails) {
    const location = await db.Location.findByPk(locationId);
    if (!location) {
      throw new Error('Location not found');
    }

    return await db.DropOffSpot.create({
      ...spotDetails,
      locationId,
    });
  }

  // Fetch all drop-off spots for a location
  async getDropOffSpots(locationId) {
    return await db.DropOffSpot.findAll({ where: { locationId } });
  }

  // Update drop-off spot details
  async updateDropOffSpot(spotId, spotDetails) {
    const dropOffSpot = await db.DropOffSpot.findByPk(spotId);
    if (!dropOffSpot) {
      throw new Error('Drop-off spot not found');
    }

    return await dropOffSpot.update(spotDetails);
  }

  // Delete a drop-off spot
  async deleteDropOffSpot(spotId) {
    const dropOffSpot = await db.DropOffSpot.findByPk(spotId);
    if (!dropOffSpot) {
      throw new Error('Drop-off spot not found');
    }

    return await dropOffSpot.destroy();
  }
}

module.exports = new LocationService();

================
File: src/controllers/locationTaxConfigController.js
================
const { LocationTaxConfig } = require('../models');
const logger = require('../services/logger');

exports.getAllLocationTaxConfigs = async (req, res) => {
  try {
    const taxConfigs = await LocationTaxConfig.findAll();
    res.status(200).json(taxConfigs);
  } catch (error) {
    logger.error(`Error fetching location tax configs: ${error.message}`);
    res.status(500).json({ message: 'Error fetching location tax configs', error });
  }
};

exports.getLocationTaxConfigById = async (req, res) => {
  try {
    const taxConfig = await LocationTaxConfig.findByPk(req.params.id);
    if (!taxConfig) return res.status(404).json({ message: 'Location tax config not found' });
    res.status(200).json(taxConfig);
  } catch (error) {
    logger.error(`Error fetching location tax config by ID (${req.params.id}): ${error.message}`);
    res.status(500).json({ message: 'Error fetching location tax config', error });
  }
};

exports.createLocationTaxConfig = async (req, res) => {
  try {
    const newTaxConfig = await LocationTaxConfig.create(req.body);
    logger.info(`Location tax config created: ${newTaxConfig.id}`);
    res.status(201).json(newTaxConfig);
  } catch (error) {
    logger.error(`Error creating location tax config: ${error.message}`);
    res.status(500).json({ message: 'Error creating location tax config', error });
  }
};

exports.updateLocationTaxConfig = async (req, res) => {
  try {
    const [updated] = await LocationTaxConfig.update(req.body, { where: { id: req.params.id } });
    if (!updated) return res.status(404).json({ message: 'Location tax config not found' });

    const updatedTaxConfig = await LocationTaxConfig.findByPk(req.params.id);
    logger.info(`Location tax config updated: ${req.params.id}`);
    res.status(200).json(updatedTaxConfig);
  } catch (error) {
    logger.error(`Error updating location tax config: ${error.message}`);
    res.status(500).json({ message: 'Error updating location tax config', error });
  }
};

exports.deleteLocationTaxConfig = async (req, res) => {
  try {
    const deleted = await LocationTaxConfig.destroy({ where: { id: req.params.id } });
    if (!deleted) return res.status(404).json({ message: 'Location tax config not found' });

    logger.info(`Location tax config deleted: ${req.params.id}`);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting location tax config: ${error.message}`);
    res.status(500).json({ message: 'Error deleting location tax config', error });
  }
};

================
File: src/controllers/loyaltyChallengeController.js
================
exports.getGuestChallengeProgress = async (req, res) => {
  try {
    const { guestId } = req.params;
    const progress = await LoyaltyChallengeProgress.findAll({
      where: { guestId },
      include: [{ model: LoyaltyChallenge, where: { status: 'active' } }]
    });
    res.json(progress);
  } catch (error) {
    console.error('Error fetching guest challenge progress:', error);
    res.status(500).json({ message: 'Error fetching guest challenge progress' });
  }
};

================
File: src/controllers/loyaltyController.js
================
const LoyaltyReward = require('../models/LoyaltyReward');
const Wallet = require('../models/Wallet');
const moment = require('moment');
const Guest = require('../models/Guest');
const loyaltyService = require('../services/loyaltyService');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

exports.applyLoyaltyReward = async (req, res) => {
  try {
    const { orderId, loyaltyRewardId } = req.body;
    const reward = await LoyaltyReward.findByPk(loyaltyRewardId);
    const wallet = await Wallet.findOne({ where: { guestId: req.user.id } });

    if (!reward || reward.walletId !== wallet.id) {
      return res.status(400).json({ message: 'Loyalty reward not available.' });
    }

    const now = new Date();
    if (reward.expirationDate && now > reward.expirationDate) {
      return res.status(400).json({ message: 'This reward has expired.' });
    }

    if (reward.cooldownPeriod) {
      const lastUsed = reward.lastUsedAt;
      if (lastUsed && now - lastUsed < reward.cooldownPeriod * 60 * 60 * 1000) {
        return res.status(400).json({ message: `This reward is on cooldown. Try again later.` });
      }
    }

    // Apply reward logic here (e.g., adjusting order totals)
    // For demonstration, we'll just update the lastUsedAt
    reward.lastUsedAt = now;
    await reward.save();

    return res.status(200).json({ 
      message: 'Loyalty reward applied successfully.', 
      orderId, 
      rewardId: loyaltyRewardId,
      appliedAt: now
    });
  } catch (error) {
    return res.status(500).json({ message: error.message });
  }
};

exports.resetLoyaltyProgress = async (req, res) => {
  try {
    const { guestId } = req.params;
    const { resetOption } = req.body;
    const guest = await Guest.findByPk(guestId);

    if (!guest) {
      return res.status(404).json({ message: 'Guest not found.' });
    }

    const now = moment();
    let resetDate;
    if (resetOption === 'calendar_year') {
      resetDate = moment().startOf('year');
    } else if (resetOption === 'signup_anniversary') {
      resetDate = moment(guest.createdAt).add(1, 'year').startOf('day');
    } else {
      return res.status(400).json({ message: 'Invalid reset option.', providedOption: resetOption });
    }

    if (now.isAfter(resetDate)) {
      const oldPoints = guest.loyaltyPoints;
      guest.loyaltyPoints = 0;
      await guest.save();
      return res.status(200).json({ 
        message: 'Loyalty progress has been reset.',
        guestId,
        oldPoints,
        newPoints: 0,
        resetDate: resetDate.toDate(),
        resetOption
      });
    } else {
      return res.status(400).json({ 
        message: 'Loyalty reset is not yet applicable.',
        guestId,
        currentPoints: guest.loyaltyPoints,
        nextResetDate: resetDate.toDate(),
        resetOption
      });
    }
  } catch (error) {
    return res.status(500).json({ message: error.message });
  }
};

exports.getLoyaltyProgram = async (req, res, next) => {
  try {
    const program = await loyaltyService.getLoyaltyProgram(req.params.clientId);
    res.status(200).json(program);
  } catch (error) {
    logger.error(`Error fetching loyalty program for client ${req.params.clientId}:`, error);
    next(new AppError('Error fetching loyalty program', 500));
  }
};

exports.createOrUpdateLoyaltyProgram = async (req, res, next) => {
  try {
    const program = await loyaltyService.createOrUpdateLoyaltyProgram(req.body);
    res.status(201).json(program);
  } catch (error) {
    logger.error('Error creating/updating loyalty program:', error);
    next(new AppError('Error creating/updating loyalty program', 500));
  }
};

exports.getCustomerPoints = async (req, res, next) => {
  try {
    const points = await loyaltyService.getCustomerPoints(req.params.customerId);
    res.status(200).json({ points });
  } catch (error) {
    logger.error(`Error fetching points for customer ${req.params.customerId}:`, error);
    next(new AppError('Error fetching customer points', 500));
  }
};

exports.addLoyaltyPoints = async (req, res, next) => {
  try {
    const { customerId, points } = req.body;
    const updatedPoints = await loyaltyService.addLoyaltyPoints(customerId, points);
    res.status(200).json({ updatedPoints });
  } catch (error) {
    logger.error('Error adding loyalty points:', error);
    next(new AppError('Error adding loyalty points', 500));
  }
};

exports.redeemLoyaltyPoints = async (req, res, next) => {
  try {
    const { customerId, points, rewardId } = req.body;
    const result = await loyaltyService.redeemLoyaltyPoints(customerId, points, rewardId);
    res.status(200).json(result);
  } catch (error) {
    logger.error('Error redeeming loyalty points:', error);
    next(new AppError('Error redeeming loyalty points', 500));
  }
};

exports.getLoyaltyTiers = async (req, res, next) => {
  try {
    const tiers = await loyaltyService.getLoyaltyTiers(req.params.clientId);
    res.status(200).json(tiers);
  } catch (error) {
    logger.error(`Error fetching loyalty tiers for client ${req.params.clientId}:`, error);
    next(new AppError('Error fetching loyalty tiers', 500));
  }
};

exports.createLoyaltyTier = async (req, res, next) => {
  try {
    const newTier = await loyaltyService.createLoyaltyTier(req.body);
    res.status(201).json(newTier);
  } catch (error) {
    logger.error('Error creating loyalty tier:', error);
    next(new AppError('Error creating loyalty tier', 500));
  }
};

exports.updateLoyaltyTier = async (req, res, next) => {
  try {
    const updatedTier = await loyaltyService.updateLoyaltyTier(req.params.tierId, req.body);
    res.status(200).json(updatedTier);
  } catch (error) {
    logger.error(`Error updating loyalty tier ${req.params.tierId}:`, error);
    next(new AppError('Error updating loyalty tier', 500));
  }
};

exports.deleteLoyaltyTier = async (req, res, next) => {
  try {
    await loyaltyService.deleteLoyaltyTier(req.params.tierId);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting loyalty tier ${req.params.tierId}:`, error);
    next(new AppError('Error deleting loyalty tier', 500));
  }
};

exports.getLoyaltyRewards = async (req, res, next) => {
  try {
    const rewards = await loyaltyService.getLoyaltyRewards(req.params.clientId);
    res.status(200).json(rewards);
  } catch (error) {
    logger.error(`Error fetching loyalty rewards for client ${req.params.clientId}:`, error);
    next(new AppError('Error fetching loyalty rewards', 500));
  }
};

exports.createLoyaltyReward = async (req, res, next) => {
  try {
    const newReward = await loyaltyService.createLoyaltyReward(req.body);
    res.status(201).json(newReward);
  } catch (error) {
    logger.error('Error creating loyalty reward:', error);
    next(new AppError('Error creating loyalty reward', 500));
  }
};

exports.updateLoyaltyReward = async (req, res, next) => {
  try {
    const updatedReward = await loyaltyService.updateLoyaltyReward(req.params.rewardId, req.body);
    res.status(200).json(updatedReward);
  } catch (error) {
    logger.error(`Error updating loyalty reward ${req.params.rewardId}:`, error);
    next(new AppError('Error updating loyalty reward', 500));
  }
};

exports.deleteLoyaltyReward = async (req, res, next) => {
  try {
    await loyaltyService.deleteLoyaltyReward(req.params.rewardId);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting loyalty reward ${req.params.rewardId}:`, error);
    next(new AppError('Error deleting loyalty reward', 500));
  }
};

================
File: src/controllers/loyaltyWalletController.js
================
const Guest = require('../models/Guest');
const LoyaltyReward = require('../models/LoyaltyReward'); // Assuming you have a LoyaltyReward model

exports.getWallet = async (req, res) => {
  const { guestId } = req.params;

  try {
    const guest = await Guest.findByPk(guestId);

    if (!guest) return res.status(404).json({ message: 'Guest not found.' });

    res.json({
      points: guest.loyaltyPoints,
      tier: guest.loyaltyTier,
      rewards: guest.rewardsWallet,
    });
  } catch (error) {
    res.status(500).json({ message: 'Error fetching wallet data', error });
  }
};

exports.addPoints = async (req, res) => {
  const { guestId, points } = req.body;

  try {
    const guest = await Guest.findByPk(guestId);

    if (!guest) return res.status(404).json({ message: 'Guest not found.' });

    guest.loyaltyPoints += points;
    await guest.save();

    res.json({ message: 'Points added successfully.', points: guest.loyaltyPoints });
  } catch (error) {
    res.status(500).json({ message: 'Error adding points', error });
  }
};

exports.redeemReward = async (req, res) => {
  const { guestId, rewardId } = req.body;

  try {
    const guest = await Guest.findByPk(guestId);
    const reward = await LoyaltyReward.findByPk(rewardId); // Use reward

    if (!guest) return res.status(404).json({ message: 'Guest not found.' });

    if (!reward || reward.walletId !== guest.walletId) {
      return res.status(400).json({ message: 'Reward not found in wallet.' });
    }

    // Logic to redeem the reward (e.g., deduct points, apply discount, etc.)
    reward.isRedeemed = true; // Example logic
    await reward.save();

    res.json({ message: 'Reward redeemed successfully.', reward });
  } catch (error) {
    res.status(500).json({ message: 'Error redeeming reward', error });
  }
};

================
File: src/controllers/marketingController.js
================
const analyticsService = require('../services/analyticsService');

// Generate A/B Test Report
exports.getABTestReport = async (req, res) => {
  try {
    const { testId } = req.params;
    const performance = await analyticsService.calculateABTestPerformance(testId);

    if (!performance) {
      return res.status(404).json({ message: 'A/B Test data not found.' });
    }

    res.status(200).json(performance);
  } catch (error) {
    console.error(`Error generating A/B Test report: ${error.message}`);
    res.status(500).json({ message: 'Error generating A/B Test report', error });
  }
};

// Generate Discount Performance Report
exports.getDiscountPerformance = async (req, res) => {
  try {
    const { discountId } = req.params;
    const performance = await analyticsService.calculateDiscountPerformance(discountId);

    if (!performance) {
      return res.status(404).json({ message: 'Discount performance data not found.' });
    }

    res.status(200).json(performance);
  } catch (error) {
    console.error(`Error generating discount report: ${error.message}`);
    res.status(500).json({ message: 'Error generating discount report', error });
  }
};

// Additional marketing-related methods can be added here as needed.

================
File: src/controllers/menuController.js
================
const db = require('../models');
const menuService = require('../services/menuService');
const logger = require('../services/logger');
const syncEngine = require('../services/posSyncService');

const getMenus = async (req, res) => {
  try {
    const menus = await menuService.getMenus(req.user.clientId);
    res.status(200).json(menus);
  } catch (error) {
    logger.error(`Error fetching menus for client ID ${req.user.clientId}: ${error.message}`);
    res.status(500).json({ message: 'Error fetching menus', error: error.message });
  }
};

const getMenuById = async (req, res) => {
  try {
    const menu = await menuService.getMenuById(req.params.id, req.user.clientId);
    if (!menu) {
      return res.status(404).json({ message: 'Menu not found or unauthorized access' });
    }
    res.status(200).json(menu);
  } catch (error) {
    logger.error(`Error fetching menu ID ${req.params.id}: ${error.message}`);
    res.status(500).json({ message: 'Error fetching menu', error: error.message });
  }
};

const createMenu = async (req, res) => {
  const transaction = await db.sequelize.transaction();
  try {
    const menu = await menuService.createMenu(req.body, req.user.clientId, transaction);
    await syncEngine.syncMenus(req.body.locationId, transaction);
    await transaction.commit();
    logger.info(`Menu created and synced for client ID ${req.user.clientId}`);
    res.status(201).json(menu);
  } catch (error) {
    await transaction.rollback();
    logger.error(`Error creating menu: ${error.message}`);
    res.status(500).json({ message: 'Error creating menu', error: error.message });
  }
};

const updateMenu = async (req, res) => {
  const transaction = await db.sequelize.transaction();
  try {
    const menu = await menuService.updateMenu(req.params.id, req.body, req.user.clientId, transaction);
    await syncEngine.syncMenus(req.body.locationId, transaction);
    await transaction.commit();
    logger.info(`Menu ID ${req.params.id} updated and synced for client ID ${req.user.clientId}`);
    res.status(200).json(menu);
  } catch (error) {
    await transaction.rollback();
    logger.error(`Error updating menu ID ${req.params.id}: ${error.message}`);
    res.status(500).json({ message: 'Error updating menu', error: error.message });
  }
};

const deleteMenu = async (req, res) => {
  const transaction = await db.sequelize.transaction();
  try {
    await menuService.deleteMenu(req.params.id, req.user.clientId, transaction);
    await syncEngine.syncMenus(req.body.locationId, transaction);
    await transaction.commit();
    logger.info(`Menu ID ${req.params.id} deleted and synced for client ID ${req.user.clientId}`);
    res.status(204).send();
  } catch (error) {
    await transaction.rollback();
    logger.error(`Error deleting menu ID ${req.params.id}: ${error.message}`);
    res.status(500).json({ message: 'Error deleting menu', error: error.message });
  }
};

const upsertMenuItem = async (req, res) => {
  const transaction = await db.sequelize.transaction();
  try {
    const menuItem = await menuService.upsertMenuItem(req.body, req.user.clientId, transaction);

    if (req.body.isABTest) {
      await menuService.createABTest(req.body, req.user.clientId, transaction);
    }

    await syncEngine.syncMenuItems(req.body.locationId, transaction);
    await transaction.commit();
    res.status(200).json(menuItem);
  } catch (error) {
    await transaction.rollback();
    logger.error(`Error upserting menu item: ${error.message}`);
    res.status(500).json({ message: 'Error adding/updating menu item', error: error.message });
  }
};

module.exports = {
  getMenus,
  getMenuById,
  createMenu,
  updateMenu,
  deleteMenu,
  upsertMenuItem
};

================
File: src/controllers/menuItemController.js
================
const { Request, Response } = require 'express';
const { getMenuItemsByLocation } = require '../services/menuItemService';
const { AppError } = require '../utils/errorHandler';

const getMenuItems = async (req, res) => {
  try {
    const { locationId } = req.params;
    const menuItems = await getMenuItemsByLocation(locationId);
    res.status(200).json(menuItems);
  } catch (error) {
    if (error instanceof AppError) {
      res.status(error.statusCode).json({ message.message });
    } else {
      res.status(500).json({ message: 'Error fetching menu items' });
    }
  }
};

================
File: src/controllers/menuService.js
================
const db = require('../models');
const logger = require('../services/logger');

class MenuService {
  async getMenusByLocation(locationId) {
    try {
      const menus = await db.Menu.findAll({
        where: { locationId },
        include: [
          { model: db.MenuGroup, include: [{ model: db.MenuItem }] },
        ],
      });

      return menus;
    } catch (error) {
      logger.error(`Error fetching menus for location ${locationId}:`, error);
      throw error;
    }
  }

  async updateMenu(menuId, menuData) {
    try {
      const updatedMenu = await db.Menu.update(menuData, {
        where: { id: menuId },
        returning: true,
        plain: true,
      });

      return updatedMenu[1]; // Returning the updated instance
    } catch (error) {
      logger.error(`Error updating menu with ID ${menuId}:`, error);
      throw error;
    }
  }

  async deleteMenu(menuId) {
    try {
      await db.Menu.destroy({
        where: { id: menuId },
      });

      logger.info(`Menu with ID ${menuId} deleted successfully`);
    } catch (error) {
      logger.error(`Error deleting menu with ID ${menuId}:`, error);
      throw error;
    }
  }

  async syncMenuWithProvider(locationId, provider) {
    try {
      const menus = await this.getMenusByLocation(locationId);

      // Assuming PosSyncService handles sending menus to the provider
      const PosSyncService = require('./posSyncService');
      await PosSyncService.syncMenus({ menus, provider });

      logger.info(`Menus synced with provider ${provider} for location ${locationId}`);
    } catch (error) {
      logger.error(`Error syncing menus for location ${locationId} with provider ${provider}:`, error);
      throw error;
    }
  }
}

module.exports = new MenuService();

================
File: src/controllers/notificationController.js
================
const NotificationService = require('../services/notificationService');
const logger = require('../services/logger');

// Send a notification (email/SMS) based on type
exports.sendNotification = async (req, res) => {
  try {
    const { recipient, message, notificationType } = req.body;

    await NotificationService.sendNotification(recipient, message, notificationType);

    res.status(200).json({ message: `Notification sent to ${recipient}` });
  } catch (error) {
    logger.error(`Error sending notification: ${error.message}`);
    res.status(500).json({ message: 'Error sending notification', error });
  }
};

================
File: src/controllers/orderController.js
================
const { Order, Location, MenuItem } = require('../models');
const orderService = require('../services/orderService');
const logger = require('../utils/logger');
const Order = require('../models/Order');
const OrderItem = require('../models/OrderItem');
const Modifier = require('../models/Modifier');

class OrderController {
  static async cancelOrder(req, res) {
    // Existing implementation
  }

  static async getOrderHistory(req, res) {
    // Existing implementation
  }

  static async createOrder(req, res) {
    try {
      const { clientId, customerId, items, total, status } = req.body;
      const order = await Order.create({ clientId, customerId, total, status });

      for (const item of items) {
        const orderItem = await OrderItem.create({ ...item, orderId: order.id });
        if (item.modifiers) {
          for (const modifier of item.modifiers) {
            await Modifier.create({ ...modifier, orderItemId: orderItem.id });
          }
        }
      }

      res.status(201).json(order);
    } catch (error) {
      logger.error(`Error creating order: ${error.message}`);
      res.status(500).json({ message: 'Error creating order', error: error.message });
    }
  }

  static async getOrderDetails(req, res) {
    try {
      const order = await orderService.getOrderById(req.params.orderId);
      if (!order) {
        return res.status(404).json({ message: 'Order not found' });
      }
      res.status(200).json(order);
    } catch (error) {
      logger.error(`Error fetching order details: ${error.message}`);
      res.status(500).json({ message: 'Error fetching order details', error: error.message });
    }
  }

  static async updateOrderStatus(req, res) {
    try {
      const updatedOrder = await orderService.updateOrderStatus(req.params.orderId, req.body.status);
      res.status(200).json(updatedOrder);
    } catch (error) {
      logger.error(`Error updating order status: ${error.message}`);
      res.status(500).json({ message: 'Error updating order status', error: error.message });
    }
  }

  static async getOrder(req, res) {
    try {
      const { id } = req.params;
      const order = await Order.findByPk(id, {
        include: [{ model: OrderItem, include: [Modifier] }]
      });
      if (!order) {
        return res.status(404).json({ error: 'Order not found' });
      }
      res.json(order);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }
}

module.exports = {
  cancelOrder: OrderController.cancelOrder,
  getOrderHistory: OrderController.getOrderHistory,
  createOrder: OrderController.createOrder,
  getOrderDetails: OrderController.getOrderDetails,
  updateOrderStatus: OrderController.updateOrderStatus,
  getOrder: OrderController.getOrder
};

================
File: src/controllers/orderHistoryController.js
================
const OrderHistory = require('../models/OrderHistory');
const Order = require('../models/Order');
const Guest = require('../models/Guest');

exports.getOrderHistoryByGuest = async (req, res) => {
  const { guestId } = req.params;

  try {
    const orders = await OrderHistory.findAll({
      where: { guestId },
      include: [
        {
          model: Order,
          attributes: ['id', 'totalPrice', 'createdAt'],
        },
        {
          model: Guest,
          attributes: ['firstName', 'lastName', 'email'],
        },
      ],
    });
    res.json(orders);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching order history', error });
  }
};

================
File: src/controllers/orderProviderController.js
================
const { Request, Response } = require 'express';
const *  = require '../services/orderProviderService';
const { AppError } = require '../utils/errorHandler';

const createOrderProviderController = async (req, res) => {
  try {
    const { locationId } = req.params;
    const newProvider = await orderProviderService.createOrderProvider(parseInt(locationId), req.body);
    res.status(201).json(newProvider);
  } catch (error) {
    if (error instanceof AppError) {
      res.status(error.statusCode).json({ message.message });
    } else {
      res.status(500).json({ message: 'Error creating order provider' });
    }
  }
};

const updateOrderProviderController = async (req, res) => {
  try {
    const updatedProvider = await orderProviderService.updateOrderProvider(parseInt(req.params.id), req.body);
    res.status(200).json(updatedProvider);
  } catch (error) {
    if (error instanceof AppError) {
      res.status(error.statusCode).json({ message.message });
    } else {
      res.status(500).json({ message: 'Error updating order provider' });
    }
  }
};

const getOrderProvidersController = async (req, res) => {
  try {
    const providers = await orderProviderService.getOrderProviders(parseInt(req.params.locationId));
    res.status(200).json(providers);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching order providers' });
  }
};

const deleteOrderProviderController = async (req, res) => {
  try {
    await orderProviderService.deleteOrderProvider(parseInt(req.params.id));
    res.status(204).send();
  } catch (error) {
    if (error instanceof AppError) {
      res.status(error.statusCode).json({ message.message });
    } else {
      res.status(500).json({ message: 'Error deleting order provider' });
    }
  }
};

const handleIncomingOrderController = async (req, res) => {
  try {
    const { providerId } = req.params;
    const orderData = req.body;
    const processedOrder = await orderProviderService.processIncomingOrder(parseInt(providerId), orderData);
    res.status(200).json(processedOrder);
  } catch (error) {
    if (error instanceof AppError) {
      res.status(error.statusCode).json({ message.message });
    } else {
      res.status(500).json({ message: 'Error processing incoming order' });
    }
  }
};

const createLocationMenuController = async (req, res) => {
  try {
    const { locationId } = req.params;
    const newMenu = await orderProviderService.createLocationMenu(parseInt(locationId), req.body);
    res.status(201).json(newMenu);
  } catch (error) {
    if (error instanceof AppError) {
      res.status(error.statusCode).json({ message.message });
    } else {
      res.status(500).json({ message: 'Error creating location menu' });
    }
  }
};

// ... add other controllers for updateLocationMenu, getLocationMenus, deleteLocationMenu

================
File: src/controllers/paymentController.js
================
const { Request, Response } = require ('express');
const { getAvailablePaymentGateways } = require ('../services/paymentService');

const getAvailablePaymentGatewaysForOrder = async (req, res) => {
  try {
    const { orderId } = req.params;
    const order = await Order.findByPk(orderId);
    if (!order) {
      return res.status(404).json({ message: 'Order not found' });
    }

    const availableGateways = await getAvailablePaymentGateways(order.clientId, order.locationId);
    res.json({ availableGateways });
  } catch (error) {
    res.status(500).json({ message: 'Error fetching available payment gateways' });
  }
};

const paymentService = require('../services/paymentService');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

exports.processPayment = async (req, res, next) => {
  try {
    const { orderId, amount, gateway, paymentDetails } = req.body;
    const payment = await paymentService.processPayment(orderId, amount, gateway, paymentDetails);
    res.status(200).json(payment);
  } catch (error) {
    logger.error('Error processing payment:', error);
    next(new AppError('Payment processing failed', 500));
  }
};

exports.getPaymentById = async (req, res, next) => {
  try {
    const payment = await paymentService.getPaymentById(req.params.id);
    res.status(200).json(payment);
  } catch (error) {
    logger.error(`Error fetching payment ${req.params.id}:`, error);
    next(error);
  }
};

exports.refundPayment = async (req, res, next) => {
  try {
    const { paymentId, amount } = req.body;
    const refund = await paymentService.refundPayment(paymentId, amount);
    res.status(200).json(refund);
  } catch (error) {
    logger.error('Error processing refund:', error);
    next(new AppError('Refund processing failed', 500));
  }
};

exports.getPaymentMethods = async (req, res, next) => {
  try {
    const methods = await paymentService.getPaymentMethods(req.params.clientId);
    res.status(200).json(methods);
  } catch (error) {
    logger.error(`Error fetching payment methods for client ${req.params.clientId}:`, error);
    next(error);
  }
};

exports.addPaymentMethod = async (req, res, next) => {
  try {
    const newMethod = await paymentService.addPaymentMethod(req.body);
    res.status(201).json(newMethod);
  } catch (error) {
    logger.error('Error adding payment method:', error);
    next(error);
  }
};

exports.updatePaymentMethod = async (req, res, next) => {
  try {
    const updatedMethod = await paymentService.updatePaymentMethod(req.params.methodId, req.body);
    res.status(200).json(updatedMethod);
  } catch (error) {
    logger.error(`Error updating payment method ${req.params.methodId}:`, error);
    next(error);
  }
};

exports.deletePaymentMethod = async (req, res, next) => {
  try {
    await paymentService.deletePaymentMethod(req.params.methodId);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting payment method ${req.params.methodId}:`, error);
    next(error);
  }
};

================
File: src/controllers/permissionController.js
================
const Permission = require('../models/Permission');
const { createAuditLog } = require('../services/auditLogService');

exports.createPermission = async (req, res) => {
  try {
    const permission = await Permission.create(req.body);
    await createAuditLog('Permission Created', { permission: permission.name }, req.user.id);
    res.status(201).json(permission);
  } catch (error) {
    res.status(500).json({ message: 'Error creating permission', error });
  }
};

exports.getAllPermissions = async (req, res) => {
  try {
    const permissions = await Permission.findAll();
    res.json(permissions);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching permissions', error });
  }
};

exports.updatePermission = async (req, res) => {
  try {
    const permission = await Permission.findByPk(req.params.id);
    if (!permission) return res.status(404).json({ message: 'Permission not found' });

    await permission.update(req.body);
    await createAuditLog('Permission Updated', { permission: permission.name }, req.user.id);
    res.json(permission);
  } catch (error) {
    res.status(500).json({ message: 'Error updating permission', error });
  }
};

exports.deletePermission = async (req, res) => {
  try {
    const permission = await Permission.findByPk(req.params.id);
    if (!permission) return res.status(404).json({ message: 'Permission not found' });

    await permission.destroy();
    await createAuditLog('Permission Deleted', { permission: permission.name }, req.user.id);
    res.json({ message: 'Permission deleted successfully' });
  } catch (error) {
    res.status(500).json({ message: 'Error deleting permission', error });
  }
};

================
File: src/controllers/posAlertController.js
================
const { Request, Response } = require 'express';
const { POSAlert } = require '../models/POSAlert';
const { createPOSAlert, getPOSAlerts } = require '../services/posAlertService';

const createAlert = async (req, res) => {
  try {
    const alert = await createPOSAlert(req.body);
    res.status(201).json(alert);
  } catch (error) {
    res.status(500).json({ message: 'Error creating POS alert', error });
  }
};

const getAlerts = async (req, res) => {
  try {
    const alerts = await getPOSAlerts();
    res.status(200).json(alerts);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching POS alerts', error });
  }
};

================
File: src/controllers/posController.js
================
const posService = require('../services/posService');
const logger = require('../utils/logger');
const { AppError } = require('../utils/errorHandler');
const { validationResult } = require('express-validator');

const handleErrors = (req, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return next(new AppError('Validation error', 400, errors.array()));
  }
};

const createProfile = async (req, res, next) => {
  try {
    handleErrors(req, next);
    const profile = await posService.createProfile(req.body);
    logger.info(`POS profile created: ${profile.id}`);
    res.status(201).json(profile);
  } catch (error) {
    logger.error('Error creating POS profile:', error);
    next(new AppError('Error creating POS profile', 500));
  }
};

const getProfile = async (req, res, next) => {
  try {
    const profile = await posService.getProfile(req.params.id);
    if (!profile) {
      return next(new AppError('POS profile not found', 404));
    }
    res.json(profile);
  } catch (error) {
    logger.error(`Error fetching POS profile ${req.params.id}:`, error);
    next(new AppError('Error fetching POS profile', 500));
  }
};

const updateProfile = async (req, res, next) => {
  try {
    handleErrors(req, next);
    const updatedProfile = await posService.updateProfile(req.params.id, req.body);
    logger.info(`POS profile updated: ${req.params.id}`);
    res.json(updatedProfile);
  } catch (error) {
    logger.error(`Error updating POS profile ${req.params.id}:`, error);
    next(new AppError('Error updating POS profile', 500));
  }
};

const deleteProfile = async (req, res, next) => {
  try {
    await posService.deleteProfile(req.params.id);
    logger.info(`POS profile deleted: ${req.params.id}`);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting POS profile ${req.params.id}:`, error);
    next(new AppError('Error deleting POS profile', 500));
  }
};

const syncData = async (req, res, next) => {
  try {
    handleErrors(req, next);
    const result = await posService.syncData(req.body);
    logger.info('POS data synced successfully');
    res.json(result);
  } catch (error) {
    logger.error('Error syncing POS data:', error);
    next(new AppError('Error syncing POS data', 500));
  }
};

const getStatus = async (req, res, next) => {
  try {
    const status = await posService.getStatus(req.params.id);
    res.json(status);
  } catch (error) {
    logger.error(`Error fetching POS status ${req.params.id}:`, error);
    next(new AppError('Error fetching POS status', 500));
  }
};

module.exports = {
  createProfile,
  getProfile,
  updateProfile,
  deleteProfile,
  syncData,
  getStatus
};

================
File: src/controllers/PosController.js
================
const PosService = require('../services/PosService');

class PosController {
  static async createProfile(req, res) {
    try {
      const profile = await PosService.createProfile(req.body);
      return res.status(201).json(profile);
    } catch (error) {
      return res.status(500).json({ message: error.message });
    }
  }

  static async getAllProfiles(req, res) {
    try {
      const profiles = await PosService.getAllProfiles();
      return res.status(200).json(profiles);
    } catch (error) {
      return res.status(500).json({ message: error.message });
    }
  }

  static async getProfileById(req, res) {
    try {
      const profile = await PosService.getProfileById(req.params.id);
      if (profile) {
        return res.status(200).json(profile);
      }
      return res.status(404).json({ message: 'Profile not found' });
    } catch (error) {
      return res.status(500).json({ message: error.message });
    }
  }

  static async updateProfile(req, res) {
    try {
      const profile = await PosService.updateProfile(req.params.id, req.body);
      return res.status(200).json(profile);
    } catch (error) {
      return res.status(500).json({ message: error.message });
    }
  }

  static async deleteProfile(req, res) {
    try {
      const success = await PosService.deleteProfile(req.params.id);
      if (success) {
        return res.status(204).send();
      }
      return res.status(404).json({ message: 'Profile not found' });
    } catch (error) {
      return res.status(500).json({ message: error.message });
    }
  }
}

module.exports = PosController;

================
File: src/controllers/posIntegrationController.js
================
const PosProfile = require('../models/PosProfile');
const PosSyncService = require('../services/posSyncService');

// Controller for syncing menus
exports.syncMenus = async (req, res) => {
  try {
    const posProfile = await PosProfile.findByPk(req.body.posProfileId);

    if (!posProfile) {
      return res.status(404).json({ message: 'POS Profile not found' });
    }

    const syncResult = await PosSyncService.syncMenus(posProfile);

    res.json(syncResult);
  } catch (error) {
    res.status(500).json({ message: 'Error syncing menus', error });
  }
};

// Controller for syncing orders
exports.syncOrders = async (req, res) => {
  try {
    const posProfile = await PosProfile.findByPk(req.body.posProfileId);

    if (!posProfile) {
      return res.status(404).json({ message: 'POS Profile not found' });
    }

    const syncResult = await PosSyncService.syncOrders(posProfile);

    res.json(syncResult);
  } catch (error) {
    res.status(500).json({ message: 'Error syncing orders', error });
  }
};

// Controller for syncing inventory
exports.syncInventory = async (req, res) => {
  try {
    const posProfile = await PosProfile.findByPk(req.body.posProfileId);

    if (!posProfile) {
      return res.status(404).json({ message: 'POS Profile not found' });
    }

    const syncResult = await PosSyncService.syncInventory(posProfile);

    res.json(syncResult);
  } catch (error) {
    res.status(500).json({ message: 'Error syncing inventory', error });
  }
};

// Controller for syncing tax rates (if applicable for the POS system)
exports.syncTaxRates = async (req, res) => {
  try {
    const posProfile = await PosProfile.findByPk(req.body.posProfileId);

    if (!posProfile) {
      return res.status(404).json({ message: 'POS Profile not found' });
    }

    const syncResult = await PosSyncService.syncTaxRates(posProfile);

    res.json(syncResult);
  } catch (error) {
    res.status(500).json({ message: 'Error syncing tax rates', error });
  }
};

================
File: src/controllers/posIntegrationErrorLogController.js
================
const PosIntegrationSettings = require('../models/PosIntegrationSettings');

// Get all POS integration settings
exports.getAllSettings = async (req, res) => {
    try {
        const settings = await PosIntegrationSettings.findAll();
        res.json(settings);
    } catch (error) {
        res.status(500).json({ message: 'Error fetching POS integration settings', error });
    }
};

// Create new POS integration settings
exports.createSettings = async (req, res) => {
    try {
        const newSettings = await PosIntegrationSettings.create(req.body);
        res.status(201).json(newSettings);
    } catch (error) {
        res.status(400).json({ message: 'Error creating POS integration settings', error });
    }
};

// Get POS integration settings by ID
exports.getSettingsById = async (req, res) => {
    try {
        const settings = await PosIntegrationSettings.findByPk(req.params.id);
        if (settings) {
            res.json(settings);
        } else {
            res.status(404).json({ message: 'POS integration settings not found' });
        }
    } catch (error) {
        res.status(500).json({ message: 'Error fetching POS integration settings', error });
    }
};

// Update POS integration settings by ID
exports.updateSettings = async (req, res) => {
    try {
        const [updated] = await PosIntegrationSettings.update(req.body, {
            where: { id: req.params.id }
        });
        if (updated) {
            const updatedSettings = await PosIntegrationSettings.findByPk(req.params.id);
            res.json(updatedSettings);
        } else {
            res.status(404).json({ message: 'POS integration settings not found' });
        }
    } catch (error) {
        res.status(400).json({ message: 'Error updating POS integration settings', error });
    }
};

// Delete POS integration settings by ID
exports.deleteSettings = async (req, res) => {
    try {
        const deleted = await PosIntegrationSettings.destroy({
            where: { id: req.params.id }
        });
        if (deleted) {
            res.status(204).send();
        } else {
            res.status(404).json({ message: 'POS integration settings not found' });
        }
    } catch (error) {
        res.status(500).json({ message: 'Error deleting POS integration settings', error });
    }
};

================
File: src/controllers/posIntegrationMappingController.js
================
const PosIntegrationMapping = require('../models/PosIntegrationMapping');

// Get all POS integration mappings
exports.getAllMappings = async (req, res) => {
    try {
        const mappings = await PosIntegrationMapping.findAll();
        res.json(mappings);
    } catch (error) {
        res.status(500).json({ message: 'Error fetching POS integration mappings', error });
    }
};

// Create a new POS integration mapping
exports.createMapping = async (req, res) => {
    try {
        const newMapping = await PosIntegrationMapping.create(req.body);
        res.status(201).json(newMapping);
    } catch (error) {
        res.status(400).json({ message: 'Error creating POS integration mapping', error });
    }
};

// Get a single POS integration mapping by ID
exports.getMappingById = async (req, res) => {
    try {
        const mapping = await PosIntegrationMapping.findByPk(req.params.id);
        if (mapping) {
            res.json(mapping);
        } else {
            res.status(404).json({ message: 'POS integration mapping not found' });
        }
    } catch (error) {
        res.status(500).json({ message: 'Error fetching POS integration mapping', error });
    }
};

// Update a POS integration mapping by ID
exports.updateMapping = async (req, res) => {
    try {
        const [updated] = await PosIntegrationMapping.update(req.body, {
            where: { id: req.params.id }
        });
        if (updated) {
            const updatedMapping = await PosIntegrationMapping.findByPk(req.params.id);
            res.json(updatedMapping);
        } else {
            res.status(404).json({ message: 'POS integration mapping not found' });
        }
    } catch (error) {
        res.status(400).json({ message: 'Error updating POS integration mapping', error });
    }
};

// Delete a POS integration mapping by ID
exports.deleteMapping = async (req, res) => {
    try {
        const deleted = await PosIntegrationMapping.destroy({
            where: { id: req.params.id }
        });
        if (deleted) {
            res.status(204).send();
        } else {
            res.status(404).json({ message: 'POS integration mapping not found' });
        }
    } catch (error) {
        res.status(500).json({ message: 'Error deleting POS integration mapping', error });
    }
};

================
File: src/controllers/posIntegrationSettingsController.js
================
const { PosIntegrationSettings } = require('../models');

// Get all POS integration settings
exports.getAllPosIntegrationSettings = async (req, res) => {
    try {
        const settings = await PosIntegrationSettings.findAll();
        res.json(settings);
    } catch (error) {
        res.status(500).json({ message: 'Error fetching POS integration settings', error: error.message });
    }
};

// Get a specific POS integration setting by ID
exports.getPosIntegrationSettingById = async (req, res) => {
    try {
        const setting = await PosIntegrationSettings.findByPk(req.params.id);
        if (!setting) {
            return res.status(404).json({ message: 'POS integration setting not found' });
        }
        res.json(setting);
    } catch (error) {
        res.status(500).json({ message: 'Error fetching POS integration setting', error: error.message });
    }
};

// Create a new POS integration setting
exports.createPosIntegrationSetting = async (req, res) => {
    try {
        const newSetting = await PosIntegrationSettings.create(req.body);
        res.status(201).json(newSetting);
    } catch (error) {
        res.status(400).json({ message: 'Error creating POS integration setting', error: error.message });
    }
};

// Update an existing POS integration setting
exports.updatePosIntegrationSetting = async (req, res) => {
    try {
        const [updated] = await PosIntegrationSettings.update(req.body, {
            where: { id: req.params.id }
        });
        if (!updated) {
            return res.status(404).json({ message: 'POS integration setting not found' });
        }
        const updatedSetting = await PosIntegrationSettings.findByPk(req.params.id);
        res.json(updatedSetting);
    } catch (error) {
        res.status(400).json({ message: 'Error updating POS integration setting', error: error.message });
    }
};

// Delete a POS integration setting
exports.deletePosIntegrationSetting = async (req, res) => {
    try {
        const deleted = await PosIntegrationSettings.destroy({
            where: { id: req.params.id }
        });
        if (!deleted) {
            return res.status(404).json({ message: 'POS integration setting not found' });
        }
        res.status(204).send();
    } catch (error) {
        res.status(500).json({ message: 'Error deleting POS integration setting', error: error.message });
    }
};

================
File: src/controllers/posProfileController.js
================
const posSyncService = require('../services/posSyncService');
const db = require('../models');
const logger = require('../services/logger');

// Create a Core POS profile (Admin Only)
exports.createCorePosProfile = async (req, res) => {
  try {
    if (req.user.role !== 'Admin') {
      return res.status(403).json({ message: 'Access denied' });
    }

    const coreProfileData = req.body;
    const newCoreProfile = await db.CorePOSProfile.create(coreProfileData);

    logger.info(`Core POS profile created: ${newCoreProfile.profileName}`);
    res.status(201).json(newCoreProfile);
  } catch (error) {
    logger.error(`Error creating Core POS profile: ${error.message}`);
    res.status(500).json({ message: 'Error creating Core POS profile', error });
  }
};

// Fetch Core POS profiles (Admin Only)
exports.getCorePosProfiles = async (req, res) => {
  try {
    if (req.user.role !== 'Admin') {
      return res.status(403).json({ message: 'Access denied' });
    }

    const profiles = await db.CorePOSProfile.findAll();
    res.status(200).json(profiles);
  } catch (error) {
    logger.error(`Error fetching Core POS profiles: ${error.message}`);
    res.status(500).json({ message: 'Error fetching Core POS profiles', error });
  }
};

// Create a Location-specific POS profile
exports.createLocationPosProfile = async (req, res) => {
  try {
    const { locationId } = req.params;
    const profileData = req.body;

    const location = await db.Location.findByPk(locationId);
    if (!location) {
      return res.status(404).json({ message: 'Location not found' });
    }

    const coreProfile = await db.CorePOSProfile.findByPk(profileData.coreProfileId);
    if (!coreProfile) {
      return res.status(404).json({ message: 'Core POS Profile not found' });
    }

    const newLocationProfile = await db.LocationPOSProfile.create({
      ...profileData,
      locationId,
      coreProfileId: coreProfile.id,
    });

    logger.info(`Location POS profile created for location ID ${locationId}`);
    res.status(201).json(newLocationProfile);
  } catch (error) {
    logger.error(`Error creating Location POS profile: ${error.message}`);
    res.status(500).json({ message: 'Error creating Location POS profile', error });
  }
};

// Update a Location-specific POS profile
exports.updateLocationPosProfile = async (req, res) => {
  try {
    const { profileId } = req.params;
    const profileData = req.body;

    const locationProfile = await db.LocationPOSProfile.findByPk(profileId);
    if (!locationProfile) {
      return res.status(404).json({ message: 'Location POS profile not found' });
    }

    await locationProfile.update(profileData);

    logger.info(`Location POS profile updated: ID ${profileId}`);
    res.status(200).json(locationProfile);
  } catch (error) {
    logger.error(`Error updating Location POS profile: ${error.message}`);
    res.status(500).json({ message: 'Error updating Location POS profile', error });
  }
};

// Fetch a Location-specific POS profile by ID
exports.getLocationPosProfileById = async (req, res) => {
  try {
    const { profileId } = req.params;
    const locationProfile = await db.LocationPOSProfile.findByPk(profileId);

    if (!locationProfile) {
      return res.status(404).json({ message: 'Location POS profile not found' });
    }

    res.status(200).json(locationProfile);
  } catch (error) {
    logger.error(`Error fetching Location POS profile: ${error.message}`);
    res.status(500).json({ message: 'Error fetching Location POS profile', error });
  }
};

// Sync POS data based on Location Profile settings
exports.syncPosData = async (req, res) => {
  try {
    const { profileId } = req.params;
    const locationProfile = await db.LocationPOSProfile.findByPk(profileId);
    if (!locationProfile) {
      return res.status(404).json({ message: 'Location POS profile not found' });
    }

    const coreProfile = await db.CorePOSProfile.findByPk(locationProfile.coreProfileId);
    if (!coreProfile) {
      return res.status(404).json({ message: 'Core POS profile not found' });
    }

    await posSyncService.syncMenus(locationProfile, coreProfile);
    await posSyncService.syncInventory(locationProfile, coreProfile);

    logger.info(`POS sync triggered for location profile ID ${profileId}`);
    res.status(200).json({ message: 'POS data synced successfully' });
  } catch (error) {
    logger.error(`Error syncing POS data: ${error.message}`);
    res.status(500).json({ message: 'Error syncing POS data', error });
  }
};

================
File: src/controllers/posSettingsController.js
================
const { Request, Response } = require 'express';
const { getPOSSettings, updatePOSSettings } = require '../services/posSettingsService';
const { AppError } = require '../utils/errorHandler';

const getPOSSettingsController = async (req, res) => {
  try {
    const clientId = req.user.clientId;
    const settings = await getPOSSettings(clientId);
    res.status(200).json(settings);
  } catch (error) {
    if (error instanceof AppError) {
      res.status(error.statusCode).json({ message.message });
    } else {
      res.status(500).json({ message: 'Error fetching POS settings' });
    }
  }
};

const updatePOSSettingsController = async (req, res) => {
  try {
    const clientId = req.user.clientId;
    const { modifierSendMethod } = req.body;
    const updatedSettings = await updatePOSSettings(clientId, { modifierSendMethod });
    res.status(200).json(updatedSettings);
  } catch (error) {
    if (error instanceof AppError) {
      res.status(error.statusCode).json({ message.message });
    } else {
      res.status(500).json({ message: 'Error updating POS settings' });
    }
  }
};

================
File: src/controllers/posSyncController.js
================
const PosProfile = require('../models/LocationPOSProfile');
const PosSyncService = require('../services/posSyncService');

// Controller for syncing menus
exports.syncMenus = async (req, res) => {
  try {
    const posProfile = await PosProfile.findByPk(req.body.posProfileId);

    if (!posProfile) {
      return res.status(404).json({ message: 'Location POS Profile not found' });
    }

    const syncResult = await PosSyncService.syncMenus(posProfile);

    res.json(syncResult);
  } catch (error) {
    res.status(500).json({ message: 'Error syncing menus', error });
  }
};

// Controller for syncing orders
exports.syncOrders = async (req, res) => {
  try {
    const posProfile = await PosProfile.findByPk(req.body.posProfileId);

    if (!posProfile) {
      return res.status(404).json({ message: 'Location POS Profile not found' });
    }

    const syncResult = await PosSyncService.syncOrders(posProfile);

    res.json(syncResult);
  } catch (error) {
    res.status(500).json({ message: 'Error syncing orders', error });
  }
};

// Controller for syncing inventory
exports.syncInventory = async (req, res) => {
  try {
    const posProfile = await PosProfile.findByPk(req.body.posProfileId);

    if (!posProfile) {
      return res.status(404).json({ message: 'Location POS Profile not found' });
    }

    const syncResult = await PosSyncService.syncInventory(posProfile);

    res.json(syncResult);
  } catch (error) {
    res.status(500).json({ message: 'Error syncing inventory', error });
  }
};

================
File: src/controllers/posSyncService.js
================
const db = require('../models');
const axios = require('axios');
const logger = require('./logger');
const { applyRoundingIfNeeded } = require('../utils/pricingUtils');

class PosSyncService {
  async syncMenus(locationProfile, coreProfile) {
    try {
      const menuData = await db.Menu.findAll({
        where: { locationId: locationProfile.locationId },
        include: [
          { model: db.MenuGroup, include: [{ model: db.MenuItem, include: [db.Modifier] }] },
        ],
      });

      const formattedMenuData = menuData.map((menu) => ({
        name: menu.name,
        groups: menu.MenuGroups.map((group) => ({
          name: group.name,
          items: group.MenuItems.map((item) => ({
            name: item.name,
            price: applyRoundingIfNeeded(item.basePrice, locationProfile.roundingOption),
            modifiers: item.Modifiers.map((modifier) => ({
              name: modifier.name,
              price: applyRoundingIfNeeded(modifier.price, locationProfile.roundingOption),
            })),
          })),
        })),
      }));

      const response = await axios.post(`${coreProfile.apiBaseUrl}/menus`, formattedMenuData, {
        headers: {
          Authorization: `Bearer ${coreProfile.clientSecret}`,
          'Content-Type': coreProfile.contentType || 'application/json',
        },
      });

      if (response.status === 200) {
        logger.info(`Menu sync successful for location ${locationProfile.locationId}`);
      } else {
        logger.error(`Menu sync failed: ${response.data.message}`);
      }
    } catch (error) {
      logger.error(`Error syncing menus: ${error.message}`);
      throw error;
    }
  }

  async syncInventory(locationProfile, coreProfile) {
    try {
      const inventory = await db.Inventory.findAll({
        where: { locationId: locationProfile.locationId },
        attributes: ['itemName', 'quantity', 'sku'],
      });

      const formattedInventory = inventory.map((item) => ({
        itemName: item.itemName,
        quantity: item.quantity,
        sku: item.sku,
      }));

      const response = await axios.post(`${coreProfile.apiBaseUrl}/inventory`, formattedInventory, {
        headers: {
          Authorization: `Bearer ${coreProfile.clientSecret}`,
          'Content-Type': coreProfile.contentType || 'application/json',
        },
      });

      if (response.status === 200) {
        logger.info(`Inventory sync successful for location ${locationProfile.locationId}`);
      } else {
        logger.error(`Inventory sync failed: ${response.data.message}`);
      }
    } catch (error) {
      logger.error(`Error syncing inventory: ${error.message}`);
      throw error;
    }
  }

  // Additional logic for syncing orders, etc.
}

module.exports = new PosSyncService();

================
File: src/controllers/providerController.js
================
const providerService = require('../services/providerService');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

// Fetch all providers for a client
exports.getAllProviders = async (req, res, next) => {
  try {
    const providers = await providerService.getAllProviders(req.user.clientId);
    res.status(200).json(providers);
  } catch (error) {
    logger.error('Error fetching all providers:', error);
    next(new AppError('Failed to fetch providers', 500));
  }
};

// Get a provider by ID
exports.getProviderById = async (req, res, next) => {
  try {
    const provider = await providerService.getProviderById(req.params.id);
    if (!provider) {
      return next(new AppError('Provider not found', 404));
    }
    res.status(200).json(provider);
  } catch (error) {
    logger.error(`Error fetching provider ${req.params.id}:`, error);
    next(error);
  }
};

// Create a new provider
exports.createProvider = async (req, res, next) => {
  try {
    const newProvider = await providerService.createProvider(req.body);
    res.status(201).json(newProvider);
  } catch (error) {
    logger.error('Error creating provider:', error);
    next(error);
  }
};

// Update an existing provider
exports.updateProvider = async (req, res, next) => {
  try {
    const updatedProvider = await providerService.updateProvider(req.params.id, req.body);
    if (!updatedProvider) {
      return next(new AppError('Provider not found', 404));
    }
    res.status(200).json(updatedProvider);
  } catch (error) {
    logger.error(`Error updating provider ${req.params.id}:`, error);
    next(error);
  }
};

// Delete a provider
exports.deleteProvider = async (req, res, next) => {
  try {
    const result = await providerService.deleteProvider(req.params.id);
    if (!result) {
      return next(new AppError('Provider not found', 404));
    }
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting provider ${req.params.id}:`, error);
    next(error);
  }
};

// Sync provider-specific data
exports.syncProviderData = async (req, res, next) => {
  try {
    await providerService.syncProviderData(req.params.id);
    res.status(200).json({ message: 'Provider data synced successfully' });
  } catch (error) {
    logger.error(`Error syncing provider data (ID: ${req.params.id}):`, error);
    next(new AppError('Error syncing provider data', 500));
  }
};

// Get provider settings
exports.getProviderSettings = async (req, res, next) => {
  try {
    const settings = await providerService.getProviderSettings(req.params.id);
    res.status(200).json(settings);
  } catch (error) {
    logger.error(`Error fetching settings for provider ${req.params.id}:`, error);
    next(error);
  }
};

// Update provider settings
exports.updateProviderSettings = async (req, res, next) => {
  try {
    const updatedSettings = await providerService.updateProviderSettings(req.params.id, req.body);
    res.status(200).json(updatedSettings);
  } catch (error) {
    logger.error(`Error updating settings for provider ${req.params.id}:`, error);
    next(error);
  }
};

// Get provider integrations
exports.getProviderIntegrations = async (req, res, next) => {
  try {
    const integrations = await providerService.getProviderIntegrations(req.params.id);
    res.status(200).json(integrations);
  } catch (error) {
    logger.error(`Error fetching integrations for provider ${req.params.id}:`, error);
    next(error);
  }
};

// Add provider integration
exports.addProviderIntegration = async (req, res, next) => {
  try {
    const newIntegration = await providerService.addProviderIntegration(req.params.id, req.body);
    res.status(201).json(newIntegration);
  } catch (error) {
    logger.error(`Error adding integration for provider ${req.params.id}:`, error);
    next(error);
  }
};

// Update provider integration
exports.updateProviderIntegration = async (req, res, next) => {
  try {
    const updatedIntegration = await providerService.updateProviderIntegration(req.params.id, req.params.integrationId, req.body);
    res.status(200).json(updatedIntegration);
  } catch (error) {
    logger.error(`Error updating integration ${req.params.integrationId} for provider ${req.params.id}:`, error);
    next(error);
  }
};

// Delete provider integration
exports.deleteProviderIntegration = async (req, res, next) => {
  try {
    await providerService.deleteProviderIntegration(req.params.id, req.params.integrationId);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting integration ${req.params.integrationId} for provider ${req.params.id}:`, error);
    next(error);
  }
};

================
File: src/controllers/qrCodeController.js
================
const QRCode = require('qrcode');
const Guest = require('../models/Guest');

// Endpoint to generate QR code for scan-to-pay or scan-for-loyalty
exports.generateQRCode = async (req, res) => {
  const { guestId, actionType } = req.body; // actionType could be "pay" or "loyalty"

  try {
    const guest = await Guest.findByPk(guestId);

    if (!guest) {
      return res.status(404).json({ message: 'Guest not found.' });
    }

    // Generate QR code data
    const qrData = {
      guestId: guest.id,
      actionType,
      timestamp: new Date().toISOString(),
    };

    const qrCodeImage = await QRCode.toDataURL(JSON.stringify(qrData));

    res.json({ qrCode: qrCodeImage });
  } catch (error) {
    res.status(500).json({ message: 'Error generating QR code', error });
  }
};

================
File: src/controllers/refundController.js
================
const Refund = require('../models/Refund');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

// Process a refund
exports.processRefund = async (req, res, next) => {
    try {
        const newRefund = await Refund.create(req.body);
        logger.info(`Refund processed successfully: ${newRefund.id}`);
        res.status(201).json(newRefund);
    } catch (error) {
        logger.error('Error processing refund:', error);
        next(new AppError('Failed to process refund', 500));
    }
};

// Get a single refund by ID
exports.getRefundById = async (req, res, next) => {
    try {
        const refund = await Refund.findByPk(req.params.id);
        if (!refund) {
            return next(new AppError('Refund not found', 404));
        }
        res.status(200).json(refund);
    } catch (error) {
        logger.error(`Error fetching refund ${req.params.id}:`, error);
        next(error);
    }
};

// Get all refunds for a specific order
exports.getRefundsByOrder = async (req, res, next) => {
    try {
        const refunds = await Refund.findAll({ where: { orderId: req.params.orderId } });
        res.status(200).json(refunds);
    } catch (error) {
        logger.error(`Error fetching refunds for order ${req.params.orderId}:`, error);
        next(error);
    }
};

// Update the status of a refund
exports.updateRefundStatus = async (req, res, next) => {
    try {
        const [updated] = await Refund.update(
            { status: req.body.status },
            { where: { id: req.params.id } }
        );
        if (!updated) {
            return next(new AppError('Refund not found', 404));
        }
        const updatedRefund = await Refund.findByPk(req.params.id);
        res.status(200).json(updatedRefund);
    } catch (error) {
        logger.error(`Error updating refund status ${req.params.id}:`, error);
        next(error);
    }
};

// Cancel a refund
exports.cancelRefund = async (req, res, next) => {
    try {
        const refund = await Refund.findByPk(req.params.id);
        if (!refund) {
            return next(new AppError('Refund not found', 404));
        }
        if (refund.status === 'cancelled') {
            return next(new AppError('Refund is already cancelled', 400));
        }
        refund.status = 'cancelled';
        await refund.save();
        res.status(200).json(refund);
    } catch (error) {
        logger.error(`Error cancelling refund ${req.params.id}:`, error);
        next(error);
    }
};

================
File: src/controllers/reportController.js
================
const reportService = require('../services/reportService');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

exports.generateReport = async (req, res, next) => {
  try {
    const report = await reportService.generateReport(req.body);
    res.status(201).json(report);
  } catch (error) {
    logger.error('Error generating report:', error);
    next(new AppError('Failed to generate report', 500));
  }
};

exports.getReportById = async (req, res, next) => {
  try {
    const report = await reportService.getReportById(req.params.id);
    if (!report) {
      return next(new AppError('Report not found', 404));
    }
    res.status(200).json(report);
  } catch (error) {
    logger.error(`Error fetching report ${req.params.id}:`, error);
    next(error);
  }
};

exports.getClientReports = async (req, res, next) => {
  try {
    const reports = await reportService.getClientReports(req.params.clientId);
    res.status(200).json(reports);
  } catch (error) {
    logger.error(`Error fetching reports for client ${req.params.clientId}:`, error);
    next(error);
  }
};

exports.updateReport = async (req, res, next) => {
  try {
    const updatedReport = await reportService.updateReport(req.params.id, req.body);
    if (!updatedReport) {
      return next(new AppError('Report not found', 404));
    }
    res.status(200).json(updatedReport);
  } catch (error) {
    logger.error(`Error updating report ${req.params.id}:`, error);
    next(error);
  }
};

exports.deleteReport = async (req, res, next) => {
  try {
    const result = await reportService.deleteReport(req.params.id);
    if (!result) {
      return next(new AppError('Report not found', 404));
    }
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting report ${req.params.id}:`, error);
    next(error);
  }
};

================
File: src/controllers/reviewController.js
================
const reviewService = require('../services/reviewService');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

exports.createReview = async (req, res, next) => {
  try {
    const newReview = await reviewService.createReview(req.body);
    res.status(201).json(newReview);
  } catch (error) {
    logger.error('Error creating review:', error);
    next(new AppError('Failed to create review', 500));
  }
};

exports.getReviewsForMenuItem = async (req, res, next) => {
  try {
    const reviews = await reviewService.getReviewsForMenuItem(req.params.menuItemId);
    res.status(200).json(reviews);
  } catch (error) {
    logger.error(`Error fetching reviews for menu item ${req.params.menuItemId}:`, error);
    next(error);
  }
};

exports.getReviewById = async (req, res, next) => {
  try {
    const review = await reviewService.getReviewById(req.params.id);
    if (!review) {
      return next(new AppError('Review not found', 404));
    }
    res.status(200).json(review);
  } catch (error) {
    logger.error(`Error fetching review ${req.params.id}:`, error);
    next(error);
  }
};

exports.updateReview = async (req, res, next) => {
  try {
    const updatedReview = await reviewService.updateReview(req.params.id, req.body);
    res.status(200).json(updatedReview);
  } catch (error) {
    logger.error(`Error updating review ${req.params.id}:`, error);
    next(error);
  }
};

exports.deleteReview = async (req, res, next) => {
  try {
    await reviewService.deleteReview(req.params.id);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting review ${req.params.id}:`, error);
    next(error);
  }
};

exports.getAverageRatingForMenuItem = async (req, res, next) => {
  try {
    const averageRating = await reviewService.getAverageRatingForMenuItem(req.params.menuItemId);
    res.status(200).json({ averageRating });
  } catch (error) {
    logger.error(`Error fetching average rating for menu item ${req.params.menuItemId}:`, error);
    next(error);
  }
};

================
File: src/controllers/rewardController.js
================
const RewardSchedule = require('../models/RewardSchedule');
const Guest = require('../models/Guest');

exports.checkAndTriggerRewards = async () => {
  const today = new Date().toISOString().slice(0, 10);

  // Find all rewards scheduled for today
  const rewards = await RewardSchedule.findAll({ where: { scheduleDate: today } });

  for (const reward of rewards) {
    // Trigger the reward based on its type
    switch (reward.rewardType) {
      case 'birthday':
        console.log(`Triggering birthday reward for Guest ${reward.guestId}:`, reward.rewardConfig);
        break;
      case 'anniversary':
        console.log(`Triggering anniversary reward for Guest ${reward.guestId}:`, reward.rewardConfig);
        break;
      case 'monthly_item':
        console.log(`Triggering monthly item reward for Guest ${reward.guestId}:`, reward.rewardConfig);
        break;
      default:
        console.log(`Unknown reward type for Guest ${reward.guestId}:`, reward.rewardType);
    }
  }
};

// Function to create or update a reward schedule for a guest
exports.createOrUpdateRewardSchedule = async (req, res) => {
  const { guestId, rewardType, description, rewardConfig, recurringType } = req.body;

  try {
    const guest = await Guest.findByPk(guestId);
    if (!guest) return res.status(404).json({ message: 'Guest not found' });

    let scheduleDate;

    switch (rewardType) {
      case 'birthday':
        scheduleDate = guest.birthday;
        break;
      case 'anniversary':
        scheduleDate = guest.signUpDate;
        break;
      default:
        scheduleDate = new Date(); // For monthly or other triggers
    }

    const rewardSchedule = await RewardSchedule.create({
      guestId,
      rewardType,
      description,
      rewardConfig,
      scheduleDate,
      recurringType,
    });

    res.status(201).json(rewardSchedule);
  } catch (error) {
    res.status(500).json({ message: 'Error creating reward schedule', error });
  }
};

================
File: src/controllers/roleController.js
================
const Role = require('../models/Role');
const Permission = require('../models/Permission');
const RoleTemplate = require('../models/RoleTemplate');
const { createAuditLog } = require('../services/auditLogService');
const roleService = require('../services/roleService');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

exports.createRole = async (req, res, next) => {
  try {
    const role = await roleService.createRole(req.body);
    res.status(201).json(role);
  } catch (error) {
    logger.error('Error creating role:', error);
    next(new AppError('Failed to create role', 500));
  }
};

exports.assignPermission = async (req, res, next) => {
  try {
    await roleService.assignPermission(req.body.roleId, req.body.permissionId);
    res.status(200).json({ message: 'Permission assigned successfully' });
  } catch (error) {
    logger.error('Error assigning permission:', error);
    next(error);
  }
};

exports.getAllRoles = async (req, res, next) => {
  try {
    const roles = await roleService.getAllRoles();
    res.status(200).json(roles);
  } catch (error) {
    logger.error('Error fetching all roles:', error);
    next(new AppError('Failed to fetch roles', 500));
  }
};

exports.getAllPermissions = async (req, res, next) => {
  try {
    const permissions = await roleService.getAllPermissions();
    res.status(200).json(permissions);
  } catch (error) {
    logger.error('Error fetching all permissions:', error);
    next(new AppError('Failed to fetch permissions', 500));
  }
};

// Update role template assignments
exports.assignRoleTemplate = async (req, res, next) => {
  try {
    await roleService.assignRoleTemplate(req.body.roleId, req.body.roleTemplateId);
    res.status(200).json({ message: 'Role template assigned successfully' });
  } catch (error) {
    logger.error('Error assigning role template:', error);
    next(error);
  }
};

exports.getRoleById = async (req, res, next) => {
  try {
    const role = await roleService.getRoleById(req.params.id);
    if (!role) {
      return next(new AppError('Role not found', 404));
    }
    res.status(200).json(role);
  } catch (error) {
    logger.error(`Error fetching role ${req.params.id}:`, error);
    next(error);
  }
};

exports.updateRole = async (req, res, next) => {
  try {
    const updatedRole = await roleService.updateRole(req.params.id, req.body);
    res.status(200).json(updatedRole);
  } catch (error) {
    logger.error(`Error updating role ${req.params.id}:`, error);
    next(error);
  }
};

exports.deleteRole = async (req, res, next) => {
  try {
    await roleService.deleteRole(req.params.id);
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting role ${req.params.id}:`, error);
    next(error);
  }
};

exports.assignRole = async (req, res, next) => {
  try {
    await roleService.assignRole(req.body.userId, req.body.roleId);
    res.status(200).json({ message: 'Role assigned successfully' });
  } catch (error) {
    logger.error('Error assigning role:', error);
    next(error);
  }
};

exports.removeRole = async (req, res, next) => {
  try {
    await roleService.removeRole(req.body.userId, req.body.roleId);
    res.status(200).json({ message: 'Role removed successfully' });
  } catch (error) {
    logger.error('Error removing role:', error);
    next(error);
  }
};

exports.getUserRoles = async (req, res, next) => {
  try {
    const roles = await roleService.getUserRoles(req.params.userId);
    res.status(200).json(roles);
  } catch (error) {
    logger.error(`Error fetching roles for user ${req.params.userId}:`, error);
    next(error);
  }
};

================
File: src/controllers/roleTemplateAssignmentsController.js
================
const { RoleTemplateAssignments } = require('../models');

// Get all role template assignments
exports.getAllRoleTemplateAssignments = async (req, res) => {
    try {
        const assignments = await RoleTemplateAssignments.findAll();
        res.json(assignments);
    } catch (error) {
        res.status(500).json({ message: 'Error fetching role template assignments', error: error.message });
    }
};

// Get a specific role template assignment by ID
exports.getRoleTemplateAssignmentById = async (req, res) => {
    try {
        const assignment = await RoleTemplateAssignments.findByPk(req.params.id);
        if (!assignment) {
            return res.status(404).json({ message: 'Role template assignment not found' });
        }
        res.json(assignment);
    } catch (error) {
        res.status(500).json({ message: 'Error fetching role template assignment', error: error.message });
    }
};

// Create a new role template assignment
exports.createRoleTemplateAssignment = async (req, res) => {
    try {
        const newAssignment = await RoleTemplateAssignments.create(req.body);
        res.status(201).json(newAssignment);
    } catch (error) {
        res.status(400).json({ message: 'Error creating role template assignment', error: error.message });
    }
};

// Update an existing role template assignment
exports.updateRoleTemplateAssignment = async (req, res) => {
    try {
        const [updated] = await RoleTemplateAssignments.update(req.body, {
            where: { id: req.params.id }
        });
        if (!updated) {
            return res.status(404).json({ message: 'Role template assignment not found' });
        }
        const updatedAssignment = await RoleTemplateAssignments.findByPk(req.params.id);
        res.json(updatedAssignment);
    } catch (error) {
        res.status(400).json({ message: 'Error updating role template assignment', error: error.message });
    }
};

// Delete a role template assignment
exports.deleteRoleTemplateAssignment = async (req, res) => {
    try {
        const deleted = await RoleTemplateAssignments.destroy({
            where: { id: req.params.id }
        });
        if (!deleted) {
            return res.status(404).json({ message: 'Role template assignment not found' });
        }
        res.status(204).send();
    } catch (error) {
        res.status(500).json({ message: 'Error deleting role template assignment', error: error.message });
    }
};

================
File: src/controllers/roleTemplateController.js
================
const { RoleTemplate, Role } = require('../models');
const { createAuditLog } = require('../services/auditLogService');

// Fetch all role templates
exports.getAllRoleTemplates = async (req, res) => {
  try {
    const roleTemplates = await RoleTemplate.findAll({
      include: [Role], // Include associated roles
    });
    res.status(200).json(roleTemplates);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching role templates', error });
  }
};

// Fetch a single role template by ID
exports.getRoleTemplateById = async (req, res) => {
  try {
    const roleTemplate = await RoleTemplate.findByPk(req.params.id, {
      include: [Role],
    });
    if (!roleTemplate) return res.status(404).json({ message: 'Role template not found' });
    res.status(200).json(roleTemplate);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching role template', error });
  }
};

// Create a new role template
exports.createRoleTemplate = async (req, res) => {
  try {
    const { name, description, roles } = req.body;

    const roleTemplate = await RoleTemplate.create({ name, description });

    if (roles && roles.length) {
      await roleTemplate.setRoles(roles); // Associate roles with the template
    }

    await createAuditLog('Role Template Created', { roleTemplate: name }, req.user.id);
    res.status(201).json(roleTemplate);
  } catch (error) {
    res.status(500).json({ message: 'Error creating role template', error });
  }
};

// Update a role template
exports.updateRoleTemplate = async (req, res) => {
  try {
    const roleTemplate = await RoleTemplate.findByPk(req.params.id);
    if (!roleTemplate) return res.status(404).json({ message: 'Role template not found' });

    const { name, description, roles } = req.body;

    await roleTemplate.update({ name, description });

    if (roles && roles.length) {
      await roleTemplate.setRoles(roles); // Update associated roles
    }

    await createAuditLog('Role Template Updated', { roleTemplate: name }, req.user.id);
    res.json(roleTemplate);
  } catch (error) {
    res.status(500).json({ message: 'Error updating role template', error });
  }
};

// Delete a role template
exports.deleteRoleTemplate = async (req, res) => {
  try {
    const roleTemplate = await RoleTemplate.findByPk(req.params.id);
    if (!roleTemplate) return res.status(404).json({ message: 'Role template not found' });

    await roleTemplate.destroy();
    await createAuditLog('Role Template Deleted', { roleTemplate: roleTemplate.name }, req.user.id);
    res.json({ message: 'Role template deleted successfully' });
  } catch (error) {
    res.status(500).json({ message: 'Error deleting role template', error });
  }
};

================
File: src/controllers/serviceFeeController.js
================
const serviceFeeService = require('../services/serviceFeeService');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

// Get all service fees
exports.getAllServiceFees = async (req, res, next) => {
  try {
    const serviceFees = await serviceFeeService.getAllServiceFees();
    res.status(200).json(serviceFees);
  } catch (error) {
    logger.error('Error fetching all service fees:', error);
    next(new AppError('Failed to fetch service fees', 500));
  }
};

// Get a single service fee by ID
exports.getServiceFeeById = async (req, res, next) => {
  try {
    const serviceFee = await serviceFeeService.getServiceFeeById(req.params.id);
    if (!serviceFee) {
      return next(new AppError('Service fee not found', 404));
    }
    res.status(200).json(serviceFee);
  } catch (error) {
    logger.error(`Error fetching service fee ${req.params.id}:`, error);
    next(error);
  }
};

// Create a new service fee
exports.createServiceFee = async (req, res, next) => {
  try {
    const newServiceFee = await serviceFeeService.createServiceFee(req.body);
    res.status(201).json(newServiceFee);
  } catch (error) {
    logger.error('Error creating service fee:', error);
    next(new AppError('Failed to create service fee', 500));
  }
};

// Update an existing service fee
exports.updateServiceFee = async (req, res, next) => {
  try {
    const updatedServiceFee = await serviceFeeService.updateServiceFee(req.params.id, req.body);
    if (!updatedServiceFee) {
      return next(new AppError('Service fee not found', 404));
    }
    res.status(200).json(updatedServiceFee);
  } catch (error) {
    logger.error(`Error updating service fee ${req.params.id}:`, error);
    next(error);
  }
};

// Delete a service fee
exports.deleteServiceFee = async (req, res, next) => {
  try {
    const result = await serviceFeeService.deleteServiceFee(req.params.id);
    if (!result) {
      return next(new AppError('Service fee not found', 404));
    }
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting service fee ${req.params.id}:`, error);
    next(error);
  }
};

// Get service fees by client
exports.getServiceFeesByClient = async (req, res, next) => {
  try {
    const serviceFees = await serviceFeeService.getServiceFeesByClient(req.params.clientId);
    res.status(200).json(serviceFees);
  } catch (error) {
    logger.error(`Error fetching service fees for client ${req.params.clientId}:`, error);
    next(error);
  }
};

================
File: src/controllers/superAdminController.js
================
const db = require('../models');

// Fetch all clients
exports.getAllClients = async (req, res) => {
  try {
    const clients = await db.Client.findAll();
    res.status(200).json(clients);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching clients', error });
  }
};

// Create a new client
exports.createClient = async (req, res) => {
  try {
    const client = await db.Client.create(req.body);
    res.status(201).json(client);
  } catch (error) {
    res.status(500).json({ message: 'Error creating client', error });
  }
};

// Update a client
exports.updateClient = async (req, res) => {
  try {
    const client = await db.Client.update(req.body, { where: { id: req.params.id } });
    res.status(200).json(client);
  } catch (error) {
    res.status(500).json({ message: 'Error updating client', error });
  }
};

// Delete a client
exports.deleteClient = async (req, res) => {
  try {
    await db.Client.destroy({ where: { id: req.params.id } });
    res.status(204).json();
  } catch (error) {
    res.status(500).json({ message: 'Error deleting client', error });
  }
};

================
File: src/controllers/tabletController.js
================
const { Request, Response } = require ('express');
const orderService = require ('../services/orderService');
const tabletService = require('../services/tabletService');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const getActiveOrdersController = async (req, res) => {
  try {
    const activeOrders = await orderService.getActiveOrders();
    res.status(200).json(activeOrders);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching active orders' });
  }
};

const cancelOrderController = async (req, res) => {
  try {
    const { orderId } = req.params;
    await orderService.cancelOrder(orderId);
    res.status(200).json({ message: 'Order cancelled successfully' });
  } catch (error) {
    res.status(500).json({ message: 'Error cancelling order' });
  }
};

const markItemOutOfStockController = async (req, res) => {
  try {
    const { itemId } = req.params;
    await orderService.markItemOutOfStock(itemId);
    res.status(200).json({ message: 'Item marked  of stock' });
  } catch (error) {
    res.status(500).json({ message: 'Error marking item  of stock' });
  }
};

exports.getAllTablets = async (req, res, next) => {
  try {
    const tablets = await tabletService.getAllTablets();
    res.status(200).json(tablets);
  } catch (error) {
    logger.error('Error fetching all tablets:', error);
    next(new AppError('Failed to fetch tablets', 500));
  }
};

exports.getTabletById = async (req, res, next) => {
  try {
    const tablet = await tabletService.getTabletById(req.params.id);
    if (!tablet) {
      return next(new AppError('Tablet not found', 404));
    }
    res.status(200).json(tablet);
  } catch (error) {
    logger.error(`Error fetching tablet ${req.params.id}:`, error);
    next(error);
  }
};

exports.createTablet = async (req, res, next) => {
  try {
    const newTablet = await tabletService.createTablet(req.body);
    res.status(201).json(newTablet);
  } catch (error) {
    logger.error('Error creating tablet:', error);
    next(new AppError('Failed to create tablet', 500));
  }
};

exports.updateTablet = async (req, res, next) => {
  try {
    const updatedTablet = await tabletService.updateTablet(req.params.id, req.body);
    if (!updatedTablet) {
      return next(new AppError('Tablet not found', 404));
    }
    res.status(200).json(updatedTablet);
  } catch (error) {
    logger.error(`Error updating tablet ${req.params.id}:`, error);
    next(error);
  }
};

exports.deleteTablet = async (req, res, next) => {
  try {
    const result = await tabletService.deleteTablet(req.params.id);
    if (!result) {
      return next(new AppError('Tablet not found', 404));
    }
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting tablet ${req.params.id}:`, error);
    next(error);
  }
};

exports.getTabletsByLocation = async (req, res, next) => {
  try {
    const tablets = await tabletService.getTabletsByLocation(req.params.locationId);
    res.status(200).json(tablets);
  } catch (error) {
    logger.error(`Error fetching tablets for location ${req.params.locationId}:`, error);
    next(error);
  }
};

exports.syncTabletData = async (req, res, next) => {
  try {
    const result = await tabletService.syncTabletData(req.params.id);
    res.status(200).json(result);
  } catch (error) {
    logger.error(`Error syncing data for tablet ${req.params.id}:`, error);
    next(error);
  }
};

================
File: src/controllers/taxController.js
================
const TaxService = require('../services/taxService');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

exports.getAllTaxRates = async (req, res, next) => {
  try {
    const taxRates = await TaxService.getAllTaxRates();
    res.status(200).json(taxRates);
  } catch (error) {
    logger.error('Error fetching all tax rates:', error);
    next(new AppError('Failed to fetch tax rates', 500));
  }
};

exports.getTaxRateById = async (req, res, next) => {
  try {
    const taxRate = await TaxService.getTaxRateById(req.params.id);
    if (!taxRate) {
      return next(new AppError('Tax rate not found', 404));
    }
    res.status(200).json(taxRate);
  } catch (error) {
    logger.error(`Error fetching tax rate ${req.params.id}:`, error);
    next(error);
  }
};

exports.createTaxRate = async (req, res, next) => {
  try {
    const newTaxRate = await TaxService.createTaxRate(req.body);
    res.status(201).json(newTaxRate);
  } catch (error) {
    logger.error('Error creating tax rate:', error);
    next(new AppError('Failed to create tax rate', 500));
  }
};

exports.updateTaxRate = async (req, res, next) => {
  try {
    const updatedTaxRate = await TaxService.updateTaxRate(req.params.id, req.body);
    if (!updatedTaxRate) {
      return next(new AppError('Tax rate not found', 404));
    }
    res.status(200).json(updatedTaxRate);
  } catch (error) {
    logger.error(`Error updating tax rate ${req.params.id}:`, error);
    next(error);
  }
};

exports.deleteTaxRate = async (req, res, next) => {
  try {
    const result = await TaxService.deleteTaxRate(req.params.id);
    if (!result) {
      return next(new AppError('Tax rate not found', 404));
    }
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting tax rate ${req.params.id}:`, error);
    next(error);
  }
};

exports.getTaxRatesByLocation = async (req, res, next) => {
  try {
    const taxRates = await TaxService.getTaxRatesByLocation(req.params.locationId);
    res.status(200).json(taxRates);
  } catch (error) {
    logger.error(`Error fetching tax rates for location ${req.params.locationId}:`, error);
    next(error);
  }
};

exports.calculateTax = async (req, res, next) => {
  try {
    const { locationId, items } = req.body;
    const taxAmount = await TaxService.calculateTax(locationId, items);
    res.status(200).json({ taxAmount });
  } catch (error) {
    logger.error('Error calculating tax:', error);
    next(error);
  }
};

exports.getTaxSettings = async (req, res, next) => {
  try {
    const { locationId, provider } = req.params;
    const taxSettings = await TaxService.getApplicableTax(locationId, provider);
    res.status(200).json(taxSettings);
  } catch (error) {
    logger.error('Error fetching tax settings:', error);
    next(new AppError('Failed to fetch tax settings', 500));
  }
};

exports.updateTaxSettings = async (req, res, next) => {
  try {
    const { locationId, provider, taxRate, taxIdNumber } = req.body;
    const updatedSettings = await TaxService.updateTaxSettings(locationId, provider, taxRate, taxIdNumber);
    res.status(200).json(updatedSettings);
  } catch (error) {
    logger.error('Error updating tax settings:', error);
    next(new AppError('Failed to update tax settings', 500));
  }
};

================
File: src/controllers/tipController.js
================
const { Tip } = require('../models');

exports.createTip = async (req, res) => {
  try {
    const { clientId, locationId, tipAmount, tipType, displayAmount } = req.body;
    const tip = await Tip.create({ clientId, locationId, tipAmount, tipType, displayAmount });
    res.status(201).json(tip);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

exports.getTips = async (req, res) => {
  try {
    const tips = await Tip.findAll();
    res.status(200).json(tips);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

================
File: src/controllers/trackingPixelController.js
================
const trackingPixelService = require('../services/trackingPixelService');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

exports.createPixel = async (req, res, next) => {
  try {
    const newPixel = await trackingPixelService.createPixel(req.body);
    res.status(201).json(newPixel);
  } catch (error) {
    logger.error('Error creating tracking pixel:', error);
    next(new AppError('Failed to create tracking pixel', 500));
  }
};

exports.getAllPixels = async (req, res, next) => {
  try {
    const pixels = await trackingPixelService.getAllPixels();
    res.status(200).json(pixels);
  } catch (error) {
    logger.error('Error fetching all tracking pixels:', error);
    next(new AppError('Failed to fetch tracking pixels', 500));
  }
};

exports.getPixelById = async (req, res, next) => {
  try {
    const pixel = await trackingPixelService.getPixelById(req.params.id);
    if (!pixel) {
      return next(new AppError('Tracking pixel not found', 404));
    }
    res.status(200).json(pixel);
  } catch (error) {
    logger.error(`Error fetching tracking pixel ${req.params.id}:`, error);
    next(error);
  }
};

exports.updatePixel = async (req, res, next) => {
  try {
    const updatedPixel = await trackingPixelService.updatePixel(req.params.id, req.body);
    if (!updatedPixel) {
      return next(new AppError('Tracking pixel not found', 404));
    }
    res.status(200).json(updatedPixel);
  } catch (error) {
    logger.error(`Error updating tracking pixel ${req.params.id}:`, error);
    next(error);
  }
};

exports.deletePixel = async (req, res, next) => {
  try {
    const result = await trackingPixelService.deletePixel(req.params.id);
    if (!result) {
      return next(new AppError('Tracking pixel not found', 404));
    }
    res.status(204).send();
  } catch (error) {
    logger.error(`Error deleting tracking pixel ${req.params.id}:`, error);
    next(error);
  }
};

exports.triggerPixel = async (req, res, next) => {
  try {
    const result = await trackingPixelService.triggerPixel(req.params.id);
    res.status(200).json(result);
  } catch (error) {
    logger.error(`Error triggering tracking pixel ${req.params.id}:`, error);
    next(error);
  }
};

================
File: src/controllers/translatorController.js
================
const PosProfile = require('../models/PosProfile');
const translatorService = require('../services/translatorService');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

// Sync order with the POS system
exports.syncOrder = async (req, res) => {
  const { locationId, orderData } = req.body;

  try {
    const posProfile = await PosProfile.findOne({ where: { locationId } });

    if (!posProfile) {
      return res.status(404).json({ message: 'POS profile not found for this location.' });
    }

    // Customize payload based on POS profile settings
    const payload = generatePayload(posProfile, orderData);

    // Send the payload to the third-party POS system (e.g., via API call)
    const response = await sendToThirdParty(posProfile.posName, payload);

    res.json({ message: 'Order synced successfully.', response });
  } catch (error) {
    logger.error('Error syncing order with POS:', error);
    res.status(500).json({ message: 'Error syncing order with POS', error: error.message });
  }
};

// Helper function to generate custom payload
function generatePayload(posProfile, orderData) {
  switch (posProfile.posName) {
    case 'Stripe':
      return { /* Stripe-specific payload structure with orderData */ orderData };
    case 'WorldPay':
      return { /* WorldPay-specific payload structure with orderData */ orderData };
    default:
      return { /* Default payload structure with orderData */ orderData };
  }
}

// Placeholder function for sending data to third-party systems
async function sendToThirdParty(posName, payload) {
  // Implement API call logic here
  return { success: true, posName, payload };
}

// New methods for translation functionality
exports.translateText = async (req, res, next) => {
  try {
    const { text, targetLanguage, sourceLanguage } = req.body;
    const translatedText = await translatorService.translateText(text, targetLanguage, sourceLanguage);
    res.status(200).json({ translatedText });
  } catch (error) {
    logger.error('Error translating text:', error);
    next(new AppError('Failed to translate text', 500));
  }
};

exports.getSupportedLanguages = async (req, res, next) => {
  try {
    const languages = await translatorService.getSupportedLanguages();
    res.status(200).json(languages);
  } catch (error) {
    logger.error('Error fetching supported languages:', error);
    next(new AppError('Failed to fetch supported languages', 500));
  }
};

exports.detectLanguage = async (req, res, next) => {
  try {
    const { text } = req.body;
    const detectedLanguage = await translatorService.detectLanguage(text);
    res.status(200).json({ detectedLanguage });
  } catch (error) {
    logger.error('Error detecting language:', error);
    next(new AppError('Failed to detect language', 500));
  }
};

exports.translateMenu = async (req, res, next) => {
  try {
    const { menuId, targetLanguage } = req.body;
    const translatedMenu = await translatorService.translateMenu(menuId, targetLanguage);
    res.status(200).json(translatedMenu);
  } catch (error) {
    logger.error('Error translating menu:', error);
    next(new AppError('Failed to translate menu', 500));
  }
};

exports.getTranslationHistory = async (req, res, next) => {
  try {
    const history = await translatorService.getTranslationHistory(req.query);
    res.status(200).json(history);
  } catch (error) {
    logger.error('Error fetching translation history:', error);
    next(new AppError('Failed to fetch translation history', 500));
  }
};

================
File: src/controllers/twoFactorController.js
================
const twoFactorService = require('../services/twoFactorService');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

exports.enable2FA = async (req, res, next) => {
  try {
    const { userId } = req.user;
    const result = await twoFactorService.enable2FA(userId);
    res.status(200).json(result);
  } catch (error) {
    logger.error('Error enabling 2FA:', error);
    next(new AppError('Failed to enable 2FA', 500));
  }
};

exports.disable2FA = async (req, res, next) => {
  try {
    const { userId } = req.user;
    await twoFactorService.disable2FA(userId);
    res.status(200).json({ message: '2FA disabled successfully' });
  } catch (error) {
    logger.error('Error disabling 2FA:', error);
    next(new AppError('Failed to disable 2FA', 500));
  }
};

exports.verify2FA = async (req, res, next) => {
  try {
    const { userId, token } = req.body;
    const isValid = await twoFactorService.verify2FA(userId, token);
    res.status(200).json({ isValid });
  } catch (error) {
    logger.error('Error verifying 2FA token:', error);
    next(new AppError('Failed to verify 2FA token', 500));
  }
};

exports.generateBackupCodes = async (req, res, next) => {
  try {
    const { userId } = req.user;
    const backupCodes = await twoFactorService.generateBackupCodes(userId);
    res.status(200).json({ backupCodes });
  } catch (error) {
    logger.error('Error generating backup codes:', error);
    next(new AppError('Failed to generate backup codes', 500));
  }
};

exports.verifyBackupCode = async (req, res, next) => {
  try {
    const { userId, backupCode } = req.body;
    const isValid = await twoFactorService.verifyBackupCode(userId, backupCode);
    res.status(200).json({ isValid });
  } catch (error) {
    logger.error('Error verifying backup code:', error);
    next(new AppError('Failed to verify backup code', 500));
  }
};

exports.get2FAStatus = async (req, res, next) => {
  try {
    const { userId } = req.user;
    const status = await twoFactorService.get2FAStatus(userId);
    res.status(200).json(status);
  } catch (error) {
    logger.error('Error fetching 2FA status:', error);
    next(new AppError('Failed to fetch 2FA status', 500));
  }
};

================
File: src/controllers/userController.js
================
const userService = require('../services/userService');

const getAllUsers = async (req, res, next) => {
  try {
    const users = await userService.getAllUsers();
    res.json(users);
  } catch (error) {
    next(error);
  }
};

const getUserById = async (req, res, next) => {
  try {
    const user = await userService.getUserById(req.params.id);
    res.json(user);
  } catch (error) {
    next(error);
  }
};

const createUser = async (req, res, next) => {
  try {
    const newUser = await userService.createUser(req.body);
    res.status(201).json(newUser);
  } catch (error) {
    next(error);
  }
};

const updateUser = async (req, res, next) => {
  try {
    const updatedUser = await userService.updateUser(req.params.id, req.body);
    res.json(updatedUser);
  } catch (error) {
    next(error);
  }
};

const deleteUser = async (req, res, next) => {
  try {
    await userService.deleteUser(req.params.id);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};

module.exports = {
  getAllUsers,
  getUserById,
  createUser,
  updateUser,
  deleteUser
};

================
File: src/controllers/walletController.js
================
const walletService = require('../services/walletService');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

exports.getWalletBalance = async (req, res, next) => {
  try {
    const { userId } = req.user;
    const balance = await walletService.getWalletBalance(userId);
    res.status(200).json({ balance });
  } catch (error) {
    logger.error('Error fetching wallet balance:', error);
    next(new AppError('Failed to fetch wallet balance', 500));
  }
};

exports.addFunds = async (req, res, next) => {
  try {
    const { userId } = req.user;
    const { amount } = req.body;
    const updatedBalance = await walletService.addFunds(userId, amount);
    res.status(200).json({ message: 'Funds added successfully', balance: updatedBalance });
  } catch (error) {
    logger.error('Error adding funds to wallet:', error);
    next(new AppError('Failed to add funds to wallet', 500));
  }
};

exports.withdrawFunds = async (req, res, next) => {
  try {
    const { userId } = req.user;
    const { amount } = req.body;
    const updatedBalance = await walletService.withdrawFunds(userId, amount);
    res.status(200).json({ message: 'Funds withdrawn successfully', balance: updatedBalance });
  } catch (error) {
    logger.error('Error withdrawing funds from wallet:', error);
    next(new AppError('Failed to withdraw funds from wallet', 500));
  }
};

exports.getTransactionHistory = async (req, res, next) => {
  try {
    const { userId } = req.user;
    const transactions = await walletService.getTransactionHistory(userId);
    res.status(200).json(transactions);
  } catch (error) {
    logger.error('Error fetching transaction history:', error);
    next(new AppError('Failed to fetch transaction history', 500));
  }
};

exports.transferFunds = async (req, res, next) => {
  try {
    const { userId } = req.user;
    const { recipientId, amount } = req.body;
    const result = await walletService.transferFunds(userId, recipientId, amount);
    res.status(200).json(result);
  } catch (error) {
    logger.error('Error transferring funds:', error);
    next(new AppError('Failed to transfer funds', 500));
  }
};

exports.getWalletDetails = async (req, res, next) => {
  try {
    const { userId } = req.params;
    const walletDetails = await walletService.getWalletDetails(userId);
    res.status(200).json(walletDetails);
  } catch (error) {
    logger.error('Error fetching wallet details:', error);
    next(new AppError('Failed to fetch wallet details', 500));
  }
};

================
File: src/cron/subscriptionCron.js
================
const cron = require 'node-cron';
const { processSubscriptions } = require '../services/subscriptionService';
const logger = require '../utils/logger';

const startSubscriptionCron = () => {
  // Run every day at midnight
  cron.schedule('0 0 * * *', async () => {
    try {
      logger.info('Starting subscription processing');
      await processSubscriptions();
      logger.info('Subscription processing completed');
    } catch (error) {
      logger.error('Error processing subscriptions:', error);
    }
  });
};

================
File: src/middleware/auditLogger.js
================
const { Request, Response, NextFunction } = require 'express';
const AuditLog = require '../models/AuditLog';
const { AuthRequest } = require './auth';

const auditLogger = (action) => {
  return async (req, res, next) => {
    try {
      await AuditLog.create({
        userId.user?.id,
        action,
        details.stringify(req.body),
        ipAddress.ip,
        userAgent.get('User-Agent') || '',
      });
      next();
    } catch (error) {
      console.error('Error logging audit:', error);
      next();
    }
  };
};

================
File: src/middleware/auth.js
================
const jwt = require('jsonwebtoken');
const { AppError } = require('../utils/errorHandler');
const { User, Role } = require('../models');

const authenticate = async (req, res, next) => {
  const token = req.header('Authorization')?.replace('Bearer ', '');

  if (!token) {
    return next(new AppError('Authentication required', 401));
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const user = await User.findByPk(decoded.userId, { include: Role });

    if (!user) {
      return next(new AppError('User not found', 401));
    }

    req.user = user;
    next();
  } catch (error) {
    next(new AppError('Invalid token', 401));
  }
};

const authorizeGlobalAdmin = (req, res, next) => {
  if (req.user.Role.name !== 'GLOBAL_ADMIN') {
    return next(new AppError('Access denied. Global Admin rights required.', 403));
  }
  next();
};

module.exports = { authenticate, authorizeGlobalAdmin };

================
File: src/middleware/authorize.js
================
const authorize = (roles = []) => {
  return (req, res, next) => {
    if (typeof roles === 'string') {
      roles = [roles];
    }

    if (roles.length && !roles.includes(req.user.role)) {
      return res.status(403).json({ message: 'Forbidden' });
    }

    next();
  };
};

module.exports = authorize;

================
File: src/middleware/brandingValidationMiddleware.js
================
const multer = require('multer');

const storage = multer.memoryStorage();
const fileFilter = (req, file, cb) => {
  // Accept only image files with specific formats
  if (!file.mimetype.match(/^image\/(jpeg|png|gif)$/)) {
    return cb(new Error('Only image files are allowed (jpeg, png, gif)'), false);
  }
  cb(null, true);
};

const upload = multer({
  storage,
  fileFilter,
  limits: { fileSize: 500 * 1024 }, // Limit file size to 500KB
});

exports.uploadLogo = upload.single('logo');

================
File: src/middleware/cache.js
================
const redis = require('redis');
const { promisify } = require('util');

const client = redis.createClient(process.env.REDIS_URL);
const getAsync = promisify(client.get).bind(client);
const setAsync = promisify(client.set).bind(client);

const cache = (duration) => async (req, res, next) => {
  const key = `__express__${req.originalUrl || req.url}`;
  const cachedResponse = await getAsync(key);
  if (cachedResponse) {
    res.send(JSON.parse(cachedResponse));
    return;
  }
  res.sendResponse = res.send;
  res.send = (body) => {
    setAsync(key, JSON.stringify(body), 'EX', duration);
    res.sendResponse(body);
  };
  next();
};

module.exports = cache;

// Use in routes:
// backend/src/routes/dashboardRoutes.js
const cache = require('../middleware/cache');
router.get('/data/:clientId', authenticate, cache(300), dashboardController.getDashboardData);

================
File: src/middleware/errorHandler.js
================
const errorHandler = (err, req, res, next) => {
  console.error(err.stack);

  const statusCode = err.statusCode || 500;
  const message = err.message || 'Internal Server Error';

  res.status(statusCode).json({
    success: false,
    error: message,
  });
};

module.exports = errorHandler;

================
File: src/middleware/logger.js
================
const winston = require('winston');
const { createLogger, format, transports } = winston;

// Define custom format for logs
const customFormat = format.combine(
  format.timestamp(),
  format.printf(({ timestamp, level, message }) => {
    return `${timestamp} [${level}]: ${message}`;
  })
);

// Create a logger instance
const logger = createLogger({
  level: 'info',
  format: customFormat,
  transports: [
    new transports.Console(),
    new transports.File({ filename: 'logs/application.log' }), // Ensure correct log file path
  ],
});

module.exports = logger;

================
File: src/middleware/permissionsMiddleware.js
================
const Permission = require('../models/Permission');
const User = require('../models/User');
const logger = require('../services/logger');

exports.checkPermission = (requiredPermission) => {
  return async (req, res, next) => {
    try {
      const userPermissions = req.user.permissions;

      const permissionDetails = await Permission.findOne({ where: { name: requiredPermission } });

      if (!permissionDetails) {
        logger.error(`Required permission ${requiredPermission} not found in the database`);
        return res.status(500).json({ message: 'Permission check failed: Invalid permission' });
      }

      if (!userPermissions.includes(permissionDetails.id)) {
        logger.warn(`User ${req.user.id} denied access: missing permission ${requiredPermission}`);
        return res.status(403).json({ message: 'You do not have the required permission.' });
      }

      logger.info(`User ${req.user.id} granted access: has permission ${requiredPermission}`);
      next();
    } catch (error) {
      logger.error(`Permission check failed: ${error.message}`);
      res.status(500).json({ message: 'Permission check failed', error: error.message });
    }
  };
};

exports.hasPermission = async (userId, requiredPermission) => {
  try {
    const user = await User.findByPk(userId, { include: ['permissions'] });
    if (!user) {
      logger.error(`User with ID ${userId} not found`);
      return false;
    }

    const permissionDetails = await Permission.findOne({ where: { name: requiredPermission } });

    if (!permissionDetails) {
      logger.error(`Required permission ${requiredPermission} not found in the database`);
      return false;
    }

    return user.permissions.some(p => p.id === permissionDetails.id);
  } catch (error) {
    logger.error(`Error checking permission for user ${userId}: ${error.message}`);
    return false;
  }
};

module.exports = exports;

================
File: src/middleware/pixelMiddleware.js
================
const db = require('../models');

async function applyTrackingPixels(req, res, next) {
  try {
    const { locationId } = req.client; // Assuming locationId is set by subdomainMiddleware
    const globalPixels = await db.TrackingPixel.findAll({ where: { isGlobal: true } });
    const locationPixels = await db.TrackingPixel.findAll({ where: { locationId } });

    req.trackingPixels = [...globalPixels, ...locationPixels];
    next();
  } catch (error) {
    res.status(500).json({ message: 'Error loading tracking pixels', error });
  }
}

module.exports = applyTrackingPixels;

================
File: src/middleware/posProfileMiddleware.js
================
const PosProfile = require('../models/PosProfile');

// Middleware to load POS profile based on location ID or selected profile
const loadPosProfile = async (req, res, next) => {
  try {
    const { locationId } = req.body;

    if (!locationId) {
      return res.status(400).json({ message: 'Location ID is required.' });
    }

    const posProfile = await PosProfile.findOne({ where: { locationId } });

    if (!posProfile) {
      return res.status(404).json({ message: 'POS Profile not found for the given location.' });
    }

    req.posProfile = posProfile;
    next();
  } catch (error) {
    res.status(500).json({ message: 'Error loading POS Profile', error });
  }
};

module.exports = loadPosProfile;

================
File: src/middleware/rateLimiter.js
================
const rateLimit = require 'express-rate-limit';
const RedisStore = require 'rate-limit-redis';
const redisClient = require '../config/redis';

const apiLimiter = rateLimit({
  store RedisStore({
    client,
    prefix: 'rate_limit:',
  }),
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per windowMs
});

const authLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 5 // limit each IP to 5 login requests per hour
});

================
File: src/middleware/sanitizeMiddleware.js
================
const { body } = require('express-validator');

module.exports = [
  // Escape HTML entities and trim whitespace
  body('*').escape().trim(),

  // Custom sanitization for email fields
  body('email').normalizeEmail(),

  // Custom sanitization for phone number fields
  body('phone').trim().escape().customSanitizer(value => value.replace(/[^0-9]/g, '')),

  // Additional custom sanitization based on specific model requirements
  body('address').optional().trim().escape(),

  // Use a different approach for sanitizing fields like price
  body('price').toFloat(),
];

================
File: src/middleware/security.js
================
const helmet = require 'helmet';
const cors = require 'cors';
const { Express } = require 'express';

const setupSecurity = (app) => {
  // Set security HTTP headers
  app.use(helmet());

  // Enable CORS
  app.use(cors());

  // Prevent XSS attacks
  app.use(helmet.xssFilter());

  // Prevent clickjacking
  app.use(helmet.frameguard({ action: 'deny' }));

  // Hide X-Powered-By header
  app.use(helmet.hidePoweredBy());

  // Prevent MIME type sniffing
  app.use(helmet.noSniff());

  // Set strict transport security
  app.use(helmet.hsts({
    maxAge: 31536000,
    includeSubDomains,
    preload
  }));
};

================
File: src/middleware/subdomainMiddleware.js
================
const { Client } = require('../models');
const NodeCache = require('node-cache');
const logger = require('../services/logger');

// Cache setup (TTL: 10 minutes)
const clientCache = new NodeCache({ stdTTL: 600, checkperiod: 120 });

const subdomainMiddleware = async (req, res, next) => {
  const subdomain = req.headers.host.split('.')[0]; // Get the subdomain part

  // Ignore predefined subdomains
  if (['www', 'api', 'yourplatform', 'localhost'].includes(subdomain)) { 
    return next(); 
  }

  try {
    // Check cache first
    let client = clientCache.get(subdomain);
    if (!client) {
      client = await Client.findOne({ where: { subdomain } });
      if (!client) {
        logger.warn(`Client not found for subdomain: ${subdomain}`);
        return res.status(404).json({ message: 'Client not found' });
      }
      // Store in cache
      clientCache.set(subdomain, client);
    }

    req.client = client; // Attach the client data to the request
    next();
  } catch (error) {
    logger.error(`Error retrieving client information for subdomain: ${subdomain}`, { error });
    return res.status(500).json({ message: 'Error retrieving client information', error });
  }
};

module.exports = subdomainMiddleware;

================
File: src/middleware/subdomainRouter.js
================
const { Client } = require('../models');
const cache = require('../utils/cache');

const subdomainRouter = async (req, res, next) => {
  const host = req.get('host');
  const subdomain = host.split('.')[0];

  // Handle predefined subdomains like 'www', 'api', and 'localhost'
  if (['www', 'api', 'localhost'].includes(subdomain)) { 
    return next(); 
  }

  try {
    let client = await cache.get(`client:${subdomain}`);
    if (!client) {
      client = await Client.findOne({ where: { subdomain } });
      if (client) {
        await cache.set(`client:${subdomain}`, client, 3600); // Cache for 1 hour
      }
    }

    if (!client) {
      return res.status(404).json({ error: 'Client not found' });
    }

    req.client = client;
    next();
  } catch (error) {
    console.error('Subdomain routing error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

module.exports = subdomainRouter;

================
File: src/middleware/validate.js
================
const { Request, Response, NextFunction } = require 'express';
const Joi = require 'joi';

const validate = (schema.ObjectSchema) => {
  return (req, res, next) => {
    const { error } = schema.validate(req.body);
    if (error) {
      return res.status(400).json({ message.details[0].message });
    }
    next();
  };
};

================
File: src/migrations/01_create_all_tables.js
================
module.exports = {
  up: async (queryInterface) => {
    // ... existing code ...
  },
  down: async (queryInterface) => {
    // ... existing code ...
  }
};

================
File: src/migrations/20240818161348-add-location-menu-override.js
================
module.exports = {
  up: async (queryInterface) => {
    // ... existing code ...
  },
  down: async (queryInterface) => {
    // ... existing code ...
  }
};

================
File: src/migrations/20240818161349-add-location-tax-config.js
================
module.exports = {
  up: async (queryInterface) => {
    // ... existing code ...
  },
  down: async (queryInterface) => {
    // ... existing code ...
  }
};

================
File: src/migrations/20240818161350-add-loyalty-challenge.js
================
module.exports = {
  up: async () => {
    // ... existing code ...
  },
  down: async () => {
    // ... existing code ...
  }
};

================
File: src/migrations/20240818161351-add-loyalty-config.js
================
module.exports = {
  up: async (queryInterface) => {
    // ... existing code ...
  },
  down: async (queryInterface) => {
    // ... existing code ...
  }
};

================
File: src/migrations/20240818161352-add-loyalty-integration.js
================
module.exports = {
  up: async (queryInterface) => {
    // ... existing code ...
  },
  down: async (queryInterface) => {
    // ... existing code ...
  }
};

================
File: src/migrations/20240821000100-add-cooldown-fields.js
================
'use strict';

module.exports = {
  up: async (queryInterface) => {
    // ... existing code ...
  },
  down: async (queryInterface) => {
    // ... existing code ...
  }
};

================
File: src/migrations/20240821000100-seed-sample-loyalty-and-discounts.js
================
'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.bulkInsert('Discounts', [
      {
        name: '10% Off Next Purchase',
        type: 'percentage',
        value: 10.0,
        cooldownPeriod: 168, // 1 week in hours
        maxUses

================
File: src/migrations/20240828024349-update-role-and-template-associations.js
================
module.exports = {
  up: async (queryInterface) => {
    // ... existing code ...
  },
  down: async (queryInterface) => {
    // ... existing code ...
  }
};

================
File: src/migrations/20240829024230-create-campaign.js
================
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  up: async (queryInterface) => {
    // ... existing code ...
  },
  down: async (queryInterface) => {
    // ... existing code ...
  }
};

================
File: src/migrations/YYYYMMDDHHMMSS-add-default-prep-time-to-locations.js
================
'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.addColumn('Locations', 'defaultPrepTime', {
      type: Sequelize.INTEGER,
      allowNull: false,
      defaultValue: 15,
    });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.removeColumn('Locations', 'defaultPrepTime');
  }
};

================
File: src/migrations/YYYYMMDDHHMMSS-add-doordash-marketplace-fields.js
================
'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.addColumn('OrderProviders', 'doordashStoreId', {
      type: Sequelize.STRING,
      allowNull: true,
    });
    await queryInterface.addColumn('OrderProviders', 'doordashMerchantId', {
      type: Sequelize.STRING,
      allowNull: true,
    });
    await queryInterface.addColumn('OrderProviders', 'doordashApiKey', {
      type: Sequelize.STRING,
      allowNull: true,
    });
    await queryInterface.addColumn('OrderProviders', 'isDoordashMenuSyncEnabled', {
      type: Sequelize.BOOLEAN,
      allowNull: false,
      defaultValue: false,
    });
    await queryInterface.addColumn('OrderProviders', 'isDoordashAutoAcceptEnabled', {
      type: Sequelize.BOOLEAN,
      allowNull: false,
      defaultValue: false,
    });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.removeColumn('OrderProviders', 'doordashStoreId');
    await queryInterface.removeColumn('OrderProviders', 'doordashMerchantId');
    await queryInterface.removeColumn('OrderProviders', 'doordashApiKey');
    await queryInterface.removeColumn('OrderProviders', 'isDoordashMenuSyncEnabled');
    await queryInterface.removeColumn('OrderProviders', 'isDoordashAutoAcceptEnabled');
  }
};

================
File: src/migrations/YYYYMMDDHHMMSS-add-inventory-settings-to-locations.js
================
'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.addColumn('Locations', 'outOfStockBehavior', {
      type: Sequelize.ENUM('grey', 'hide'),
      allowNull: false,
      defaultValue: 'grey',
    });
    await queryInterface.addColumn('Locations', 'inventoryResetTime', {
      type: Sequelize.STRING,
      allowNull: true,
    });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.removeColumn('Locations', 'outOfStockBehavior');
    await queryInterface.removeColumn('Locations', 'inventoryResetTime');
  }
};

================
File: src/migrations/YYYYMMDDHHMMSS-add-prep-time-and-inventory-offset-to-menu-items.js
================
'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.addColumn('MenuItems', 'prepTime', {
      type: Sequelize.INTEGER,
      allowNull: false,
      defaultValue: 0,
    });
    await queryInterface.addColumn('MenuItems', 'onlineInventoryOffset', {
      type: Sequelize.INTEGER,
      allowNull: false,
      defaultValue: 0,
    });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.removeColumn('MenuItems', 'prepTime');
    await queryInterface.removeColumn('MenuItems', 'onlineInventoryOffset');
  }
};

================
File: src/migrations/YYYYMMDDHHMMSS-add-scheduled-order-fields.js
================
'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.addColumn('OrderProviders', 'handleScheduledOrders', {
      type: Sequelize.BOOLEAN,
      allowNull: false,
      defaultValue: false,
    });
    await queryInterface.addColumn('OrderProviders', 'scheduledOrderLeadTime', {
      type: Sequelize.INTEGER,
      allowNull: false,
      defaultValue: 30,
    });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.removeColumn('OrderProviders', 'handleScheduledOrders');
    await queryInterface.removeColumn('OrderProviders', 'scheduledOrderLeadTime');
  }
};

================
File: src/migrations/YYYYMMDDHHMMSS-create-client-branding.js
================
const { QueryInterface, DataTypes } = require 'sequelize';

module.exports = {
  up (queryInterface) => {
    await queryInterface.createTable('ClientBrandings', {
      id: {
        allowNull,
        autoIncrement,
        primaryKey,
        type.INTEGER
      },
      clientId: {
        type.INTEGER,
        allowNull,
        references: {
          model: 'Clients',
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE'
      },
      logo: {
        type.STRING,
        allowNull
      },
      favicon: {
        type.STRING,
        allowNull
      },
      primaryColor: {
        type.STRING,
        allowNull
      },
      secondaryColor: {
        type.STRING,
        allowNull
      },
      accentColor: {
        type.STRING,
        allowNull
      },
      fontFamily: {
        type.STRING,
        allowNull
      },
      buttonStyle: {
        type.ENUM('rounded', 'square'),
        allowNull
      },
      headerStyle: {
        type.ENUM('centered', 'left-aligned'),
        allowNull
      },
      footerContent: {
        type.TEXT,
        allowNull
      },
      createdAt: {
        allowNull,
        type.DATE
      },
      updatedAt: {
        allowNull,
        type.DATE
      }
    });
  },

  down (queryInterface) => {
    await queryInterface.dropTable('ClientBrandings');
  }
};

================
File: src/migrations/YYYYMMDDHHMMSS-create-client-features.js
================
'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable('ClientFeatures', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      clientId: {
        type: Sequelize.INTEGER,
        allowNull: false,
        references: {
          model: 'Clients',
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE'
      },
      loyalty: {
        type: Sequelize.BOOLEAN,
        allowNull: false,
        defaultValue: false
      },
      onlineOrdering: {
        type: Sequelize.BOOLEAN,
        allowNull: false,
        defaultValue: false
      },
      tableReservations: {
        type: Sequelize.BOOLEAN,
        allowNull: false,
        defaultValue: false
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE
      },
      updatedAt: {
        allowNull: false,
        type: Sequelize.DATE
      }
    });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.dropTable('ClientFeatures');
  }
};

================
File: src/migrations/YYYYMMDDHHMMSS-create-location-profile.js
================
'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable('LocationProfiles', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      clientId: {
        type: Sequelize.INTEGER,
        allowNull: false,
        references: {
          model: 'Clients',
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE'
      },
      name: {
        type: Sequelize.STRING,
        allowNull: false
      },
      settings: {
        type: Sequelize.JSON,
        allowNull: false
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE
      },
      updatedAt: {
        allowNull: false,
        type: Sequelize.DATE
      }
    });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.dropTable('LocationProfiles');
  }
};

================
File: src/migrations/YYYYMMDDHHMMSS-create-location.js
================
'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable('Locations', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      clientId: {
        type: Sequelize.INTEGER,
        allowNull: false,
        references: {
          model: 'Clients',
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE'
      },
      name: {
        type: Sequelize.STRING,
        allowNull: false
      },
      address: {
        type: Sequelize.STRING,
        allowNull: false
      },
      posIntegrationId: {
        type: Sequelize.INTEGER,
        allowNull: false,
        references: {
          model: 'POSIntegrations',
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'RESTRICT'
      },
      customSettings: {
        type: Sequelize.JSON,
        allowNull: false,
        defaultValue: {
          hasDelivery: false,
          hasDineIn: false,
          hasPickup: false
        }
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE
      },
      updatedAt: {
        allowNull: false,
        type: Sequelize.DATE
      }
    });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.dropTable('Locations');
  }
};

================
File: src/migrations/YYYYMMDDHHMMSS-create-order-provider.js
================
'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable('OrderProviders', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      locationId: {
        type: Sequelize.INTEGER,
        allowNull: false,
        references: {
          model: 'Locations',
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE'
      },
      name: {
        type: Sequelize.STRING,
        allowNull: false
      },
      type: {
        type: Sequelize.ENUM('doordash', 'ubereats', 'grubhub', 'other'),
        allowNull: false
      },
      apiKey: {
        type: Sequelize.STRING,
        allowNull: false
      },
      apiSecret: {
        type: Sequelize.STRING,
        allowNull: false
      },
      isActive: {
        type: Sequelize.BOOLEAN,
        allowNull: false,
        defaultValue: true
      },
      upliftPercentage: {
        type: Sequelize.FLOAT,
        allowNull: false,
        defaultValue: 0
      },
      customUpliftRules: {
        type: Sequelize.JSON,
        allowNull: true
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE
      },
      updatedAt: {
        allowNull: false,
        type: Sequelize.DATE
      }
    });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.dropTable('OrderProviders');
  }
};

================
File: src/migrations/YYYYMMDDHHMMSS-create-review.js
================
'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable('Reviews', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      menuItemId: {
        type: Sequelize.INTEGER,
        allowNull: false,
        references: {
          model: 'MenuItems',
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE'
      },
      firstName: {
        type: Sequelize.STRING,
        allowNull: false
      },
      lastInitial: {
        type: Sequelize.STRING(1),
        allowNull: false
      },
      rating: {
        type: Sequelize.INTEGER,
        allowNull: false
      },
      comment: {
        type: Sequelize.TEXT,
        allowNull: true
      },
      isApproved: {
        type: Sequelize.BOOLEAN,
        allowNull: false,
        defaultValue: false
      },
      orderAgainPercentage: {
        type: Sequelize.INTEGER,
        allowNull: true
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE
      },
      updatedAt: {
        allowNull: false,
        type: Sequelize.DATE
      }
    });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.dropTable('Reviews');
  }
};

================
File: src/migrations/YYYYMMDDHHMMSS-create-scheduled-order.js
================
'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable('ScheduledOrders', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      orderId: {
        type: Sequelize.INTEGER,
        allowNull: false,
        references: {
          model: 'Orders',
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE'
      },
      scheduledTime: {
        type: Sequelize.DATE,
        allowNull: false
      },
      sentToPOS: {
        type: Sequelize.BOOLEAN,
        allowNull: false,
        defaultValue: false
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE
      },
      updatedAt: {
        allowNull: false,
        type: Sequelize.DATE
      }
    });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.dropTable('ScheduledOrders');
  }
};

================
File: src/migrations/YYYYMMDDHHMMSS-create-user.js
================


================
File: src/migrations/YYYYMMDDHHMMSS-update-pos-settings.js
================
const { QueryInterface, DataTypes } = require 'sequelize';

module.exports = {
  up (queryInterface) => {
    await queryInterface.addColumn('POSSettings', 'clientId', {
      type.INTEGER,
      allowNull,
      references: {
        model: 'Clients',
        key: 'id'
      },
      onUpdate: 'CASCADE',
      onDelete: 'CASCADE'
    });
  },

  down (queryInterface) => {
    await queryInterface.removeColumn('POSSettings', 'clientId');
  }
};

================
File: src/models/ABTest.js
================
const { Model, DataTypes } = require('sequelize');

class ABTest extends Model {
  static init(sequelize) {
    super.init({
      name: {
        type: DataTypes.STRING,
        allowNull: false
      },
      description: DataTypes.TEXT,
      startDate: DataTypes.DATE,
      endDate: DataTypes.DATE,
      status: {
        type: DataTypes.ENUM('DRAFT', 'RUNNING', 'COMPLETED', 'CANCELLED'),
        defaultValue: 'DRAFT'
      }
    }, {
      sequelize,
      modelName: 'ABTest',
      tableName: 'ab_tests',
      timestamps: true
    });
  }

  static associate(models) {
    this.hasMany(models.ABTestVariant, { foreignKey: 'abTestId', as: 'variants' });
    this.hasMany(models.ABTestMetric, { foreignKey: 'abTestId', as: 'metrics' });
  }
}

module.exports = ABTest;

================
File: src/models/ABTestMetric.js
================
const { Model, DataTypes } = require('sequelize');

class ABTestMetric extends Model {
  static init(sequelize) {
    super.init({
      abTestId: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
          model: 'ABTests',
          key: 'id'
        }
      },
      variantId: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
          model: 'ABTestVariants',
          key: 'id'
        }
      },
      metricName: {
        type: DataTypes.STRING,
        allowNull: false
      },
      metricValue: {
        type: DataTypes.FLOAT,
        allowNull: false
      },
      timestamp: {
        type: DataTypes.DATE,
        allowNull: false,
        defaultValue: DataTypes.NOW
      }
    }, {
      sequelize,
      modelName: 'ABTestMetric',
      tableName: 'ab_test_metrics',
      timestamps: true
    });
  }

  static associate(models) {
    if (models.ABTest) {
      this.belongsTo(models.ABTest, { foreignKey: 'abTestId', as: 'abTest' });
    }
    if (models.ABTestVariant) {
      this.belongsTo(models.ABTestVariant, { foreignKey: 'variantId', as: 'variant' });
    }
  }
}

module.exports = ABTestMetric;

================
File: src/models/ABTestResult.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class ABTestResult extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

ABTestResult.attributes = {
  // Define attributes here
};

module.exports = (sequelize) => {
  ABTestResult.init(ABTestResult.attributes, {
    sequelize,
    modelName: 'ABTestResult',
    tableName: 'abtestresults', // Adjust this if needed
  });
  return ABTestResult
};

================
File: src/models/ABTestVariant.js
================
const { Model, DataTypes } = require('sequelize');

class ABTestVariant extends Model {
  static init(sequelize) {
    super.init({
      abTestId: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
          model: 'ABTests',
          key: 'id'
        }
      },
      name: {
        type: DataTypes.STRING,
        allowNull: false
      },
      description: DataTypes.TEXT,
      trafficAllocation: {
        type: DataTypes.FLOAT,
        allowNull: false,
        defaultValue: 0
      }
    }, {
      sequelize,
      modelName: 'ABTestVariant',
      tableName: 'ab_test_variants',
      timestamps: true
    });
  }

  static associate(models) {
    this.belongsTo(models.ABTest, { foreignKey: 'abTestId', as: 'abTest' });
    this.hasMany(models.ABTestMetric, { foreignKey: 'variantId', as: 'metrics' });
  }
}

module.exports = ABTestVariant;

================
File: src/models/Analytics.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Analytics extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

Analytics.attributes = attributes = {
  date: {
    type: DataTypes.DATE,
    allowNull: false
  },
  metric: {
    type: DataTypes.STRING,
    allowNull: false
  },
  value: {
    type: DataTypes.FLOAT,
    allowNull: false
  },
  // Add other attributes as needed
};

module.exports = (sequelize) => {
  Analytics.init(Analytics.attributes, {
    sequelize,
    modelName: 'Analytics',
    tableName: 'analyticss', // Adjust this if needed
  });
  return Analytics
};

================
File: src/models/Asset.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Asset extends BaseModel {
  static associate(models) {
    this.belongsTo(models.Client, { foreignKey: 'clientId' });
  }
}

Asset.attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  type: {
    type: DataTypes.STRING,
    allowNull: false
  },
  url: {
    type: DataTypes.STRING,
    allowNull: false
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  size: {
    type: DataTypes.INTEGER,
    allowNull: true
  },
  mimeType: {
    type: DataTypes.STRING,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  Asset.init(Asset.attributes, {
    sequelize,
    modelName: 'Asset',
    tableName: 'assets', // Adjust this if needed
  });
  return Asset
};

================
File: src/models/AuditLog.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class AuditLog extends BaseModel {
  static associate(models) {
    // define associations here if needed
  }
}

AuditLog.attributes = attributes = {
  userId: {
    type: DataTypes.INTEGER,
    allowNull: true,
  },
  action: {
    type: DataTypes.STRING,
    allowNull: false,
  },
  details: {
    type: DataTypes.TEXT,
    allowNull: true,
  },
  ipAddress: {
    type: DataTypes.STRING,
    allowNull: true,
  },
  userAgent: {
    type: DataTypes.STRING,
    allowNull: true,
  },
};

module.exports = (sequelize) => {
  AuditLog.init(AuditLog.attributes, {
    sequelize,
    modelName: 'AuditLog',
    tableName: 'auditlogs', // Adjust this if needed
  });
  return AuditLog
};

================
File: src/models/BaseModel.js
================
const { Model, DataTypes } = require('sequelize');

class BaseModel extends Model {
  static init(sequelize) {
    if (!this.modelAttributes || typeof this.modelAttributes !== 'function') {
      throw new Error(`modelAttributes method must be implemented by ${this.name}`);
    }
    const attributes = this.modelAttributes(DataTypes);
    return super.init(attributes, { sequelize, modelName: this.name });
  }

  static getModelName() {
    return this.name;
  }
}

module.exports = BaseModel;

================
File: src/models/Branding.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Branding extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

Branding.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  logoUrl: {
    type: DataTypes.STRING,
    allowNull: true
  },
  primaryColor: {
    type: DataTypes.STRING,
    allowNull: true
  },
  secondaryColor: {
    type: DataTypes.STRING,
    allowNull: true
  },
  fontFamily: {
    type: DataTypes.STRING,
    allowNull: true
  },
  customCss: {
    type: DataTypes.TEXT,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  Branding.init(Branding.attributes, {
    sequelize,
    modelName: 'Branding',
    tableName: 'brandings', // Adjust this if needed
  });
  return Branding
};

================
File: src/models/BrandingProfile.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class BrandingProfile extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

BrandingProfile.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  logoUrl: {
    type: DataTypes.STRING,
    allowNull: true
  },
  colorScheme: {
    type: DataTypes.JSON,
    allowNull: true
  },
  fontSettings: {
    type: DataTypes.JSON,
    allowNull: true
  },
  isDefault: {
    type: DataTypes.BOOLEAN,
    defaultValue: false
  }
};

module.exports = (sequelize) => {
  BrandingProfile.init(BrandingProfile.attributes, {
    sequelize,
    modelName: 'BrandingProfile',
    tableName: 'brandingprofiles', // Adjust this if needed
  });
  return BrandingProfile
};

================
File: src/models/Campaign.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Campaign extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

Campaign.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  startDate: {
    type: DataTypes.DATE,
    allowNull: false
  },
  endDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  status: {
    type: DataTypes.ENUM('draft', 'active', 'paused', 'completed'),
    defaultValue: 'draft'
  },
  type: {
    type: DataTypes.ENUM('email', 'sms', 'push', 'in-app'),
    allowNull: false
  },
  targetAudience: {
    type: DataTypes.JSON,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  Campaign.init(Campaign.attributes, {
    sequelize,
    modelName: 'Campaign',
    tableName: 'campaigns', // Adjust this if needed
  });
  return Campaign
};

================
File: src/models/CampaignResult.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class CampaignResult extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

CampaignResult.attributes = attributes = {
  campaignId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Campaigns', key: 'id' }
  },
  metric: {
    type: DataTypes.STRING,
    allowNull: false
  },
  value: {
    type: DataTypes.FLOAT,
    allowNull: false
  },
  date: {
    type: DataTypes.DATE,
    allowNull: false
  }
};

module.exports = (sequelize) => {
  CampaignResult.init(CampaignResult.attributes, {
    sequelize,
    modelName: 'CampaignResult',
    tableName: 'campaignresults', // Adjust this if needed
  });
  return CampaignResult
};

================
File: src/models/CampaignStep.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class CampaignStep extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

CampaignStep.attributes = {
  // Define attributes here
};

module.exports = (sequelize) => {
  CampaignStep.init(CampaignStep.attributes, {
    sequelize,
    modelName: 'CampaignStep',
    tableName: 'campaignsteps', // Adjust this if needed
  });
  return CampaignStep
};

================
File: src/models/Catering.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Catering extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

Catering.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  minimumOrderAmount: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false
  },
  leadTime: {
    type: DataTypes.INTEGER,
    allowNull: false,
    comment: 'Lead time in hours'
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    defaultValue: true
  }
};

module.exports = (sequelize) => {
  Catering.init(Catering.attributes, {
    sequelize,
    modelName: 'Catering',
    tableName: 'caterings', // Adjust this if needed
  });
  return Catering
};

================
File: src/models/CateringAdmin.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class CateringAdmin extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

CateringAdmin.attributes = attributes = {
  userId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Users', key: 'id' }
  },
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  permissions: {
    type: DataTypes.JSON,
    allowNull: true
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    defaultValue: true
  }
};

module.exports = (sequelize) => {
  CateringAdmin.init(CateringAdmin.attributes, {
    sequelize,
    modelName: 'CateringAdmin',
    tableName: 'cateringadmins', // Adjust this if needed
  });
  return CateringAdmin
};

================
File: src/models/CateringMenu.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class CateringMenu extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

CateringMenu.attributes = attributes = {
  cateringId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Caterings', key: 'id' }
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  startDate: {
    type: DataTypes.DATE,
    allowNull: false
  },
  endDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    defaultValue: true
  }
};

module.exports = (sequelize) => {
  CateringMenu.init(CateringMenu.attributes, {
    sequelize,
    modelName: 'CateringMenu',
    tableName: 'cateringmenus', // Adjust this if needed
  });
  return CateringMenu
};

================
File: src/models/CateringMenuItem.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class CateringMenuItem extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

CateringMenuItem.attributes = attributes = {
  cateringMenuId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'CateringMenus', key: 'id' }
  },
  menuItemId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'MenuItems', key: 'id' }
  },
  price: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false
  },
  minimumQuantity: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 1
  },
  maximumQuantity: {
    type: DataTypes.INTEGER,
    allowNull: true
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    defaultValue: true
  }
};

module.exports = (sequelize) => {
  CateringMenuItem.init(CateringMenuItem.attributes, {
    sequelize,
    modelName: 'CateringMenuItem',
    tableName: 'cateringmenuitems', // Adjust this if needed
  });
  return CateringMenuItem
};

================
File: src/models/CateringOrder.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class CateringOrder extends BaseModel {
  static init(sequelize) {
    super.init({
      id: {
        type: DataTypes.UUID,
        defaultValue: DataTypes.UUIDV4,
        primaryKey: true
      },
      clientId: {
        type: DataTypes.UUID,
        allowNull: false
      },
      customerId: {
        type: DataTypes.UUID,
        allowNull: false
      },
      total: {
        type: DataTypes.FLOAT,
        allowNull: false
      },
      status: {
        type: DataTypes.ENUM('PENDING', 'PROCESSING', 'COMPLETED', 'CANCELLED'),
        allowNull: false
      },
      eventDate: {
        type: DataTypes.DATE,
        allowNull: false
      },
      eventType: {
        type: DataTypes.STRING,
        allowNull: false
      },
      deliveryAddress: {
        type: DataTypes.STRING,
        allowNull: false
      },
      specialInstructions: {
        type: DataTypes.TEXT,
        allowNull: true
      }
    }, {
      sequelize,
      modelName: 'CateringOrder'
    });
  }

  static associate(models) {
    this.hasMany(models.CateringOrderItem, { foreignKey: 'orderId' });
  }
}

module.exports = CateringOrder;

================
File: src/models/CateringOrderAssignments.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class CateringOrderAssignments extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

CateringOrderAssignments.attributes = attributes = {
  cateringOrderId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'CateringOrders', key: 'id' }
  },
  assignedUserId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Users', key: 'id' }
  },
  assignmentType: {
    type: DataTypes.ENUM('preparation', 'delivery'),
    allowNull: false
  },
  status: {
    type: DataTypes.ENUM('assigned', 'in_progress', 'completed'),
    defaultValue: 'assigned'
  },
  notes: {
    type: DataTypes.TEXT,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  CateringOrderAssignments.init(CateringOrderAssignments.attributes, {
    sequelize,
    modelName: 'CateringOrderAssignments',
    tableName: 'cateringorderassignmentss', // Adjust this if needed
  });
  return CateringOrderAssignments
};

================
File: src/models/CateringOrderCustomization.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class CateringOrderCustomization extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

CateringOrderCustomization.attributes = attributes = {
  cateringOrderItemId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'CateringOrderItems', key: 'id' }
  },
  customizationType: {
    type: DataTypes.STRING,
    allowNull: false
  },
  customizationValue: {
    type: DataTypes.STRING,
    allowNull: false
  },
  additionalCost: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false,
    defaultValue: 0
  }
};

module.exports = (sequelize) => {
  CateringOrderCustomization.init(CateringOrderCustomization.attributes, {
    sequelize,
    modelName: 'CateringOrderCustomization',
    tableName: 'cateringordercustomizations', // Adjust this if needed
  });
  return CateringOrderCustomization
};

================
File: src/models/CateringOrderFees.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class CateringOrderFees extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

CateringOrderFees.attributes = attributes = {
  cateringOrderId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'CateringOrders', key: 'id' }
  },
  feeType: {
    type: DataTypes.ENUM('delivery', 'service', 'other'),
    allowNull: false
  },
  amount: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false
  },
  description: {
    type: DataTypes.STRING,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  CateringOrderFees.init(CateringOrderFees.attributes, {
    sequelize,
    modelName: 'CateringOrderFees',
    tableName: 'cateringorderfeess', // Adjust this if needed
  });
  return CateringOrderFees
};

================
File: src/models/CateringOrderItem.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class CateringOrderItem extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

CateringOrderItem.attributes = attributes = {
  cateringOrderId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'CateringOrders', key: 'id' }
  },
  cateringMenuItemId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'CateringMenuItems', key: 'id' }
  },
  quantity: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 1
  },
  price: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false
  },
  specialInstructions: {
    type: DataTypes.TEXT,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  CateringOrderItem.init(CateringOrderItem.attributes, {
    sequelize,
    modelName: 'CateringOrderItem',
    tableName: 'cateringorderitems', // Adjust this if needed
  });
  return CateringOrderItem
};

================
File: src/models/CateringOrderLocation.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class CateringOrderLocation extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

CateringOrderLocation.attributes = attributes = {
  cateringOrderId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'CateringOrders', key: 'id' }
  },
  locationId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Locations', key: 'id' }
  },
  isPickup: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: false
  },
  deliveryAddress: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  deliveryInstructions: {
    type: DataTypes.TEXT,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  CateringOrderLocation.init(CateringOrderLocation.attributes, {
    sequelize,
    modelName: 'CateringOrderLocation',
    tableName: 'cateringorderlocations', // Adjust this if needed
  });
  return CateringOrderLocation
};

================
File: src/models/CateringOrderModifier.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class CateringOrderModifier extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

CateringOrderModifier.attributes = attributes = {
  cateringOrderItemId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'CateringOrderItems', key: 'id' }
  },
  modifierId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Modifiers', key: 'id' }
  },
  quantity: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 1
  },
  price: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false
  }
};

module.exports = (sequelize) => {
  CateringOrderModifier.init(CateringOrderModifier.attributes, {
    sequelize,
    modelName: 'CateringOrderModifier',
    tableName: 'cateringordermodifiers', // Adjust this if needed
  });
  return CateringOrderModifier
};

================
File: src/models/CateringSettings.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class CateringSettings extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

CateringSettings.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  minimumOrderAmount: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false,
    defaultValue: 0
  },
  leadTimeHours: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 24
  },
  maxOrderDaysInAdvance: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 30
  },
  deliveryFee: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: true
  },
  serviceFeePercentage: {
    type: DataTypes.DECIMAL(5, 2),
    allowNull: true
  },
  allowPickup: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  allowDelivery: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  }
};

module.exports = (sequelize) => {
  CateringSettings.init(CateringSettings.attributes, {
    sequelize,
    modelName: 'CateringSettings',
    tableName: 'cateringsettingss', // Adjust this if needed
  });
  return CateringSettings
};

================
File: src/models/Challenge.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Challenge extends BaseModel {
  static associate(models) {
    // define associations here if needed
  }
}

Challenge.attributes = attributes = {
  name: {
    type: DataTypes.STRING,
    allowNull: false,
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true,
  },
  type: {
    type: DataTypes.STRING,
    allowNull: false,
  },
  goal: {
    type: DataTypes.INTEGER,
    allowNull: false,
  },
  reward: {
    type: DataTypes.FLOAT,
    allowNull: false,
  },
  startDate: {
    type: DataTypes.DATE,
    allowNull: false,
  },
  endDate: {
    type: DataTypes.DATE,
    allowNull: false,
  },
};

module.exports = (sequelize) => {
  Challenge.init(Challenge.attributes, {
    sequelize,
    modelName: 'Challenge',
    tableName: 'challenges', // Adjust this if needed
  });
  return Challenge
};

================
File: src/models/checkModelExports.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class checkModelExports extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

checkModelExports.attributes = {
  // Define attributes here
};

module.exports = (sequelize) => {
  checkModelExports.init(checkModelExports.attributes, {
    sequelize,
    modelName: 'checkModelExports',
    tableName: 'checkmodelexportss', // Adjust this if needed
  });
  return checkModelExports
};

================
File: src/models/checkModels.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class checkModels extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

checkModels.attributes = {
  // Define attributes here
};

module.exports = (sequelize) => {
  checkModels.init(checkModels.attributes, {
    sequelize,
    modelName: 'checkModels',
    tableName: 'checkmodelss', // Adjust this if needed
  });
  return checkModels
};

================
File: src/models/Client.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Client extends BaseModel {
  static associate(models) {
    // define associations here if needed
  }
}

Client.attributes = attributes = {
  name: {
    type: DataTypes.STRING,
    allowNull: false,
  },
  email: {
    type: DataTypes.STRING,
    allowNull: false,
    unique: true,
    validate: {
      isEmail: true,
    },
  },
  phone: {
    type: DataTypes.STRING,
    allowNull: true,
  },
  address: {
    type: DataTypes.TEXT,
    allowNull: true,
  },
  // Add any other fields that are needed for the Client model
};

module.exports = (sequelize) => {
  Client.init(Client.attributes, {
    sequelize,
    modelName: 'Client',
    tableName: 'clients', // Adjust this if needed
  });
  return Client
};

================
File: src/models/ClientBranding.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class ClientBranding extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

ClientBranding.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: {
      model: 'Clients',
      key: 'id'
    }
  },
  logoUrl: {
    type: DataTypes.STRING,
    allowNull: true
  },
  primaryColor: {
    type: DataTypes.STRING,
    allowNull: true
  },
  secondaryColor: {
    type: DataTypes.STRING,
    allowNull: true
  },
  fontFamily: {
    type: DataTypes.STRING,
    allowNull: true
  },
  customCss: {
    type: DataTypes.TEXT,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  ClientBranding.init(ClientBranding.attributes, {
    sequelize,
    modelName: 'ClientBranding',
    tableName: 'clientbrandings', // Adjust this if needed
  });
  return ClientBranding
};

================
File: src/models/ClientFeatures.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class ClientFeatures extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

ClientFeatures.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: {
      model: 'Clients',
      key: 'id'
    }
  },
  featureName: {
    type: DataTypes.STRING,
    allowNull: false
  },
  isEnabled: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: false
  },
  configuration: {
    type: DataTypes.JSON,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  ClientFeatures.init(ClientFeatures.attributes, {
    sequelize,
    modelName: 'ClientFeatures',
    tableName: 'clientfeaturess', // Adjust this if needed
  });
  return ClientFeatures
};

================
File: src/models/ClientPreferences.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class ClientPreferences extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

ClientPreferences.attributes = {
  // Define attributes here
};

module.exports = (sequelize) => {
  ClientPreferences.init(ClientPreferences.attributes, {
    sequelize,
    modelName: 'ClientPreferences',
    tableName: 'clientpreferencess', // Adjust this if needed
  });
  return ClientPreferences
};

================
File: src/models/ClientProfile.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class ClientProfile extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

ClientProfile.attributes = {
  // Define attributes here
};

module.exports = (sequelize) => {
  ClientProfile.init(ClientProfile.attributes, {
    sequelize,
    modelName: 'ClientProfile',
    tableName: 'clientprofiles', // Adjust this if needed
  });
  return ClientProfile
};

================
File: src/models/ClientSettings.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class ClientSettings extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

ClientSettings.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: {
      model: 'Clients',
      key: 'id'
    }
  },
  settingKey: {
    type: DataTypes.STRING,
    allowNull: false
  },
  settingValue: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  dataType: {
    type: DataTypes.STRING,
    allowNull: false
  }
};

module.exports = (sequelize) => {
  ClientSettings.init(ClientSettings.attributes, {
    sequelize,
    modelName: 'ClientSettings',
    tableName: 'clientsettingss', // Adjust this if needed
  });
  return ClientSettings
};

================
File: src/models/CommissaryKitchen.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class CommissaryKitchen extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

CommissaryKitchen.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  address: {
    type: DataTypes.TEXT,
    allowNull: false
  },
  capacity: {
    type: DataTypes.INTEGER,
    allowNull: true
  },
  operatingHours: {
    type: DataTypes.JSON,
    allowNull: true
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  }
};

module.exports = (sequelize) => {
  CommissaryKitchen.init(CommissaryKitchen.attributes, {
    sequelize,
    modelName: 'CommissaryKitchen',
    tableName: 'commissarykitchens', // Adjust this if needed
  });
  return CommissaryKitchen
};

================
File: src/models/CommissaryLocation.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class CommissaryLocation extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

CommissaryLocation.attributes = attributes = {
  commissaryKitchenId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'CommissaryKitchens', key: 'id' }
  },
  locationId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Locations', key: 'id' }
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  deliverySchedule: {
    type: DataTypes.JSON,
    allowNull: true
  },
  notes: {
    type: DataTypes.TEXT,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  CommissaryLocation.init(CommissaryLocation.attributes, {
    sequelize,
    modelName: 'CommissaryLocation',
    tableName: 'commissarylocations', // Adjust this if needed
  });
  return CommissaryLocation
};

================
File: src/models/CorePOSProfile.js
================
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
  const CorePOSProfile = sequelize.define('CorePOSProfile', {
    id: {
      type: DataTypes.UUID,
      defaultValue: DataTypes.UUIDV4,
      primaryKey: true,
    },
    name: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    posType: {
      type: DataTypes.ENUM('TOAST', 'BRINK', 'REVEL', 'SQUARE'),
      allowNull: false,
    },
    apiEndpoint: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    apiKey: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    syncInterval: {
      type: DataTypes.INTEGER,
      defaultValue: 3600,
    },
    lastSyncTimestamp: {
      type: DataTypes.DATE,
    },
    isActive: {
      type: DataTypes.BOOLEAN,
      defaultValue: true,
    },
    settings: {
      type: DataTypes.JSON,
      defaultValue: {},
    },
  }, {
    tableName: 'core_pos_profiles',
  });

  return CorePOSProfile;
};

================
File: src/models/DataWall.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class DataWall extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

DataWall.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  dataSource: {
    type: DataTypes.STRING,
    allowNull: false
  },
  queryParameters: {
    type: DataTypes.JSON,
    allowNull: true
  },
  refreshInterval: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 3600 // in seconds
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  lastRefreshed: {
    type: DataTypes.DATE,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  DataWall.init(DataWall.attributes, {
    sequelize,
    modelName: 'DataWall',
    tableName: 'datawalls', // Adjust this if needed
  });
  return DataWall
};

================
File: src/models/DeliveryDriver.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class DeliveryDriver extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

DeliveryDriver.attributes = attributes = {
  userId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Users', key: 'id' }
  },
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  vehicleType: {
    type: DataTypes.ENUM('car', 'motorcycle', 'bicycle', 'scooter'),
    allowNull: false
  },
  licensePlate: {
    type: DataTypes.STRING,
    allowNull: true
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  currentStatus: {
    type: DataTypes.ENUM('available', 'on_delivery', 'offline'),
    allowNull: false,
    defaultValue: 'offline'
  },
  rating: {
    type: DataTypes.FLOAT,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  DeliveryDriver.init(DeliveryDriver.attributes, {
    sequelize,
    modelName: 'DeliveryDriver',
    tableName: 'deliverydrivers', // Adjust this if needed
  });
  return DeliveryDriver
};

================
File: src/models/Discount.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Discount extends BaseModel {
  static associate(models) {
    // Define associations here if needed
  }
}

Discount.attributes = attributes = {
  code: {
    type: DataTypes.STRING,
    allowNull: false,
    unique: true
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  discountType: {
    type: DataTypes.ENUM('percentage', 'fixed'),
    allowNull: false
  },
  value: {
    type: DataTypes.FLOAT,
    allowNull: false
  },
  startDate: {
    type: DataTypes.DATE,
    allowNull: false
  },
  endDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  maxUses: {
    type: DataTypes.INTEGER,
    allowNull: true
  },
  currentUses: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0
  },
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: true,
    references: {
      model: 'Clients',
      key: 'id'
    }
  }
};

module.exports = (sequelize) => {
  Discount.init(Discount.attributes, {
    sequelize,
    modelName: 'Discount',
    tableName: 'discounts', // Adjust this if needed
  });
  return Discount
};

================
File: src/models/DiscountItem.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class DiscountItem extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

DiscountItem.attributes = attributes = {
  discountId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Discounts', key: 'id' }
  },
  menuItemId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'MenuItems', key: 'id' }
  },
  isExcluded: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: false
  }
};

module.exports = (sequelize) => {
  DiscountItem.init(DiscountItem.attributes, {
    sequelize,
    modelName: 'DiscountItem',
    tableName: 'discountitems', // Adjust this if needed
  });
  return DiscountItem
};

================
File: src/models/DriverLocations.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class DriverLocations extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

DriverLocations.attributes = attributes = {
  driverId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'DeliveryDrivers', key: 'id' }
  },
  latitude: {
    type: DataTypes.FLOAT,
    allowNull: false
  },
  longitude: {
    type: DataTypes.FLOAT,
    allowNull: false
  },
  timestamp: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW
  },
  accuracy: {
    type: DataTypes.FLOAT,
    allowNull: true
  },
  speed: {
    type: DataTypes.FLOAT,
    allowNull: true
  },
  bearing: {
    type: DataTypes.FLOAT,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  DriverLocations.init(DriverLocations.attributes, {
    sequelize,
    modelName: 'DriverLocations',
    tableName: 'driverlocationss', // Adjust this if needed
  });
  return DriverLocations
};

================
File: src/models/DropOffSchedule.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class DropOffSchedule extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

DropOffSchedule.attributes = attributes = {
  locationId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Locations', key: 'id' }
  },
  dropOffSpotId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'DropOffSpots', key: 'id' }
  },
  dayOfWeek: {
    type: DataTypes.INTEGER,
    allowNull: false,
    validate: { min: 0, max: 6 }
  },
  startTime: {
    type: DataTypes.TIME,
    allowNull: false
  },
  endTime: {
    type: DataTypes.TIME,
    allowNull: false
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  }
};

module.exports = (sequelize) => {
  DropOffSchedule.init(DropOffSchedule.attributes, {
    sequelize,
    modelName: 'DropOffSchedule',
    tableName: 'dropoffschedules', // Adjust this if needed
  });
  return DropOffSchedule
};

================
File: src/models/DropOffSpot.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class DropOffSpot extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

DropOffSpot.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  address: {
    type: DataTypes.STRING,
    allowNull: false
  },
  latitude: {
    type: DataTypes.FLOAT,
    allowNull: true
  },
  longitude: {
    type: DataTypes.FLOAT,
    allowNull: true
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  }
};

module.exports = (sequelize) => {
  DropOffSpot.init(DropOffSpot.attributes, {
    sequelize,
    modelName: 'DropOffSpot',
    tableName: 'dropoffspots', // Adjust this if needed
  });
  return DropOffSpot
};

================
File: src/models/FeatureManagement.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class FeatureManagement extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

FeatureManagement.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  featureName: {
    type: DataTypes.STRING,
    allowNull: false
  },
  isEnabled: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: false
  },
  configuration: {
    type: DataTypes.JSON,
    allowNull: true
  },
  startDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  endDate: {
    type: DataTypes.DATE,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  FeatureManagement.init(FeatureManagement.attributes, {
    sequelize,
    modelName: 'FeatureManagement',
    tableName: 'featuremanagements', // Adjust this if needed
  });
  return FeatureManagement
};

================
File: src/models/GlobalMenu.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class GlobalMenu extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

GlobalMenu.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  startDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  endDate: {
    type: DataTypes.DATE,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  GlobalMenu.init(GlobalMenu.attributes, {
    sequelize,
    modelName: 'GlobalMenu',
    tableName: 'globalmenus', // Adjust this if needed
  });
  return GlobalMenu
};

================
File: src/models/GlobalSetting.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class GlobalSetting extends BaseModel {
  static associate(models) {
    // Global settings typically don't have associations, but you can add if needed
  }
}

GlobalSetting.attributes = attributes = {
  key: {
    type: DataTypes.STRING,
    allowNull: false,
    unique: true
  },
  value: {
    type: DataTypes.TEXT,
    allowNull: false
  },
  dataType: {
    type: DataTypes.ENUM('string', 'number', 'boolean', 'json'),
    allowNull: false,
    defaultValue: 'string'
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  isEditable: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  }
};

module.exports = (sequelize) => {
  GlobalSetting.init(GlobalSetting.attributes, {
    sequelize,
    modelName: 'GlobalSetting',
    tableName: 'globalsettings', // Adjust this if needed
  });
  return GlobalSetting
};

================
File: src/models/Guest.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Guest extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

Guest.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  email: {
    type: DataTypes.STRING,
    allowNull: false,
    unique: true,
    validate: {
      isEmail: true
    }
  },
  phoneNumber: {
    type: DataTypes.STRING,
    allowNull: true,
    unique: true
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  lastOrderDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  totalOrders: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0
  },
  totalSpent: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false,
    defaultValue: 0
  }
};

module.exports = (sequelize) => {
  Guest.init(Guest.attributes, {
    sequelize,
    modelName: 'Guest',
    tableName: 'guests', // Adjust this if needed
  });
  return Guest
};

================
File: src/models/GuestDiscounts.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class GuestDiscounts extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

GuestDiscounts.attributes = attributes = {
  guestId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Guests', key: 'id' }
  },
  discountId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Discounts', key: 'id' }
  },
  usageCount: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0
  },
  lastUsedDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  }
};

module.exports = (sequelize) => {
  GuestDiscounts.init(GuestDiscounts.attributes, {
    sequelize,
    modelName: 'GuestDiscounts',
    tableName: 'guestdiscountss', // Adjust this if needed
  });
  return GuestDiscounts
};

================
File: src/models/GuestLoyaltyProgram.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class GuestLoyaltyProgram extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

GuestLoyaltyProgram.attributes = attributes = {
  guestId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Guests', key: 'id' }
  },
  loyaltyProgramId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'LoyaltyPrograms', key: 'id' }
  },
  points: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0
  },
  tier: {
    type: DataTypes.STRING,
    allowNull: true
  },
  joinDate: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW
  },
  lastActivityDate: {
    type: DataTypes.DATE,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  GuestLoyaltyProgram.init(GuestLoyaltyProgram.attributes, {
    sequelize,
    modelName: 'GuestLoyaltyProgram',
    tableName: 'guestloyaltyprograms', // Adjust this if needed
  });
  return GuestLoyaltyProgram
};

================
File: src/models/GuestProfile.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class GuestProfile extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

GuestProfile.attributes = attributes = {
  guestId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Guests', key: 'id' }
  },
  firstName: {
    type: DataTypes.STRING,
    allowNull: true
  },
  lastName: {
    type: DataTypes.STRING,
    allowNull: true
  },
  dateOfBirth: {
    type: DataTypes.DATEONLY,
    allowNull: true
  },
  gender: {
    type: DataTypes.ENUM('male', 'female', 'other', 'prefer_not_to_say'),
    allowNull: true
  },
  address: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  city: {
    type: DataTypes.STRING,
    allowNull: true
  },
  state: {
    type: DataTypes.STRING,
    allowNull: true
  },
  zipCode: {
    type: DataTypes.STRING,
    allowNull: true
  },
  country: {
    type: DataTypes.STRING,
    allowNull: true
  },
  preferences: {
    type: DataTypes.JSON,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  GuestProfile.init(GuestProfile.attributes, {
    sequelize,
    modelName: 'GuestProfile',
    tableName: 'guestprofiles', // Adjust this if needed
  });
  return GuestProfile
};

================
File: src/models/GuestRewards.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class GuestRewards extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

GuestRewards.attributes = attributes = {
  guestId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Guests', key: 'id' }
  },
  rewardId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Rewards', key: 'id' }
  },
  issuedDate: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW
  },
  expirationDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  isRedeemed: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: false
  },
  redeemedDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  status: {
    type: DataTypes.ENUM('active', 'expired', 'redeemed'),
    allowNull: false,
    defaultValue: 'active'
  }
};

module.exports = (sequelize) => {
  GuestRewards.init(GuestRewards.attributes, {
    sequelize,
    modelName: 'GuestRewards',
    tableName: 'guestrewardss', // Adjust this if needed
  });
  return GuestRewards
};

================
File: src/models/HouseAccount.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class HouseAccount extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

HouseAccount.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  balance: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false,
    defaultValue: 0
  },
  creditLimit: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: true
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  billingCycle: {
    type: DataTypes.ENUM('weekly', 'bi-weekly', 'monthly'),
    allowNull: false,
    defaultValue: 'monthly'
  },
  paymentTerms: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 30 // days
  }
};

module.exports = (sequelize) => {
  HouseAccount.init(HouseAccount.attributes, {
    sequelize,
    modelName: 'HouseAccount',
    tableName: 'houseaccounts', // Adjust this if needed
  });
  return HouseAccount
};

================
File: src/models/HouseAccountLocations.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class HouseAccountLocations extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

HouseAccountLocations.attributes = attributes = {
  houseAccountId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'HouseAccounts', key: 'id' }
  },
  locationId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Locations', key: 'id' }
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  }
};

module.exports = (sequelize) => {
  HouseAccountLocations.init(HouseAccountLocations.attributes, {
    sequelize,
    modelName: 'HouseAccountLocations',
    tableName: 'houseaccountlocationss', // Adjust this if needed
  });
  return HouseAccountLocations
};

================
File: src/models/HouseAccountUser.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class HouseAccountUser extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

HouseAccountUser.attributes = attributes = {
  houseAccountId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'HouseAccounts', key: 'id' }
  },
  userId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Users', key: 'id' }
  },
  role: {
    type: DataTypes.ENUM('admin', 'user'),
    allowNull: false,
    defaultValue: 'user'
  },
  spendingLimit: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: true
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  }
};

module.exports = (sequelize) => {
  HouseAccountUser.init(HouseAccountUser.attributes, {
    sequelize,
    modelName: 'HouseAccountUser',
    tableName: 'houseaccountusers', // Adjust this if needed
  });
  return HouseAccountUser
};

================
File: src/models/index.js
================
'use strict';

const fs = require('fs');
const path = require('path');
const Sequelize = require('sequelize');
const process = require('process');
const basename = path.basename(__filename);
const env = process.env.NODE_ENV || 'development';
const config = require(__dirname + '/../config/config.json')[env];
const db = {};

let sequelize;
if (config.use_env_variable) {
  sequelize = new Sequelize(process.env[config.use_env_variable], config);
} else {
  sequelize = new Sequelize(config.database, config.username, config.password, config);
}

// Function to import a model
const importModel = (file) => {
  const model = require(path.join(__dirname, file));
  if (typeof model.init === 'function') {
    model.init(sequelize);
    db[model.name] = model;
    console.log(`Initialized model: ${model.name}`);
  } else {
    console.warn(`Skipped model: ${file} (not a Sequelize model or missing init method)`);
  }
};

// Import all models
fs.readdirSync(__dirname)
  .filter(file => {
    return (
      file.indexOf('.') !== 0 &&
      file !== basename &&
      file.slice(-3) === '.js' &&
      file.indexOf('.test.js') === -1 &&
      file !== 'BaseModel.js'
    );
  })
  .forEach(importModel);

// Set up associations
Object.values(db).forEach(model => {
  if (typeof model.associate === 'function') {
    model.associate(db);
    console.log(`Associations set up for: ${model.name}`);
  } else {
    console.log(`No associations for: ${model.name}`);
  }
});

// Handle connection errors
sequelize
  .authenticate()
  .then(() => {
    console.log('Database connection has been established successfully.');
  })
  .catch(err => {
    console.error('Unable to connect to the database:', err);
  });

db.sequelize = sequelize;
db.Sequelize = Sequelize;

module.exports = db;

================
File: src/models/Inventory.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Inventory extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

Inventory.attributes = attributes = {
  locationId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Locations', key: 'id' }
  },
  menuItemId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'MenuItems', key: 'id' }
  },
  quantity: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0
  },
  unit: {
    type: DataTypes.STRING,
    allowNull: false
  },
  reorderPoint: {
    type: DataTypes.INTEGER,
    allowNull: true
  },
  lastRestockDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  expirationDate: {
    type: DataTypes.DATE,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  Inventory.init(Inventory.attributes, {
    sequelize,
    modelName: 'Inventory',
    tableName: 'inventorys', // Adjust this if needed
  });
  return Inventory
};

================
File: src/models/Invoice.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Invoice extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

Invoice.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  houseAccountId: {
    type: DataTypes.INTEGER,
    allowNull: true,
    references: { model: 'HouseAccounts', key: 'id' }
  },
  orderId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Orders', key: 'id' }
  },
  invoiceNumber: {
    type: DataTypes.STRING,
    allowNull: false,
    unique: true
  },
  amount: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false
  },
  status: {
    type: DataTypes.ENUM('pending', 'paid', 'overdue', 'cancelled'),
    allowNull: false,
    defaultValue: 'pending'
  },
  dueDate: {
    type: DataTypes.DATE,
    allowNull: false
  },
  paidDate: {
    type: DataTypes.DATE,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  Invoice.init(Invoice.attributes, {
    sequelize,
    modelName: 'Invoice',
    tableName: 'invoices', // Adjust this if needed
  });
  return Invoice
};

================
File: src/models/Item.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Item extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

Item.attributes = attributes = {
  menuId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Menus', key: 'id' }
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  price: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false
  },
  imageUrl: {
    type: DataTypes.STRING,
    allowNull: true
  },
  isAvailable: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  category: {
    type: DataTypes.STRING,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  Item.init(Item.attributes, {
    sequelize,
    modelName: 'Item',
    tableName: 'items', // Adjust this if needed
  });
  return Item
};

================
File: src/models/ItemModifier.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class ItemModifier extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

ItemModifier.attributes = attributes = {
  itemId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Items', key: 'id' }
  },
  modifierId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Modifiers', key: 'id' }
  },
  isRequired: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: false
  },
  minSelection: {
    type: DataTypes.INTEGER,
    allowNull: true
  },
  maxSelection: {
    type: DataTypes.INTEGER,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  ItemModifier.init(ItemModifier.attributes, {
    sequelize,
    modelName: 'ItemModifier',
    tableName: 'itemmodifiers', // Adjust this if needed
  });
  return ItemModifier
};

================
File: src/models/ItemReview.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class ItemReview extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

ItemReview.attributes = attributes = {
  itemId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Items', key: 'id' }
  },
  userId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Users', key: 'id' }
  },
  rating: {
    type: DataTypes.INTEGER,
    allowNull: false,
    validate: {
      min: 1,
      max: 5
    }
  },
  comment: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  isVerified: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: false
  }
};

module.exports = (sequelize) => {
  ItemReview.init(ItemReview.attributes, {
    sequelize,
    modelName: 'ItemReview',
    tableName: 'itemreviews', // Adjust this if needed
  });
  return ItemReview
};

================
File: src/models/Location.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Location extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

Location.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: {
      model: 'Clients',
      key: 'id'
    }
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  address: {
    type: DataTypes.STRING,
    allowNull: false
  },
  city: {
    type: DataTypes.STRING,
    allowNull: false
  },
  state: {
    type: DataTypes.STRING,
    allowNull: false
  },
  zipCode: {
    type: DataTypes.STRING,
    allowNull: false
  },
  country: {
    type: DataTypes.STRING,
    allowNull: false
  },
  phoneNumber: {
    type: DataTypes.STRING,
    allowNull: true
  },
  email: {
    type: DataTypes.STRING,
    allowNull: true,
    validate: {
      isEmail: true
    }
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  timezone: {
    type: DataTypes.STRING,
    allowNull: false
  },
  latitude: {
    type: DataTypes.FLOAT,
    allowNull: true
  },
  longitude: {
    type: DataTypes.FLOAT,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  Location.init(Location.attributes, {
    sequelize,
    modelName: 'Location',
    tableName: 'locations', // Adjust this if needed
  });
  return Location
};

================
File: src/models/LocationHours.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class LocationHours extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

LocationHours.attributes = attributes = {
  locationId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Locations', key: 'id' }
  },
  dayOfWeek: {
    type: DataTypes.INTEGER,
    allowNull: false,
    validate: {
      min: 0,
      max: 6
    }
  },
  openTime: {
    type: DataTypes.TIME,
    allowNull: false
  },
  closeTime: {
    type: DataTypes.TIME,
    allowNull: false
  },
  isClosed: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: false
  }
};

module.exports = (sequelize) => {
  LocationHours.init(LocationHours.attributes, {
    sequelize,
    modelName: 'LocationHours',
    tableName: 'locationhourss', // Adjust this if needed
  });
  return LocationHours
};

================
File: src/models/LocationMenu.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class LocationMenu extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

LocationMenu.attributes = attributes = {
  locationId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Locations', key: 'id' }
  },
  menuId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Menus', key: 'id' }
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  startDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  endDate: {
    type: DataTypes.DATE,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  LocationMenu.init(LocationMenu.attributes, {
    sequelize,
    modelName: 'LocationMenu',
    tableName: 'locationmenus', // Adjust this if needed
  });
  return LocationMenu
};

================
File: src/models/LocationMenuGroup.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class LocationMenuGroup extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

LocationMenuGroup.attributes = attributes = {
  locationId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Locations', key: 'id' }
  },
  menuGroupId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'MenuGroups', key: 'id' }
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  displayOrder: {
    type: DataTypes.INTEGER,
    allowNull: true
  },
  customName: {
    type: DataTypes.STRING,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  LocationMenuGroup.init(LocationMenuGroup.attributes, {
    sequelize,
    modelName: 'LocationMenuGroup',
    tableName: 'locationmenugroups', // Adjust this if needed
  });
  return LocationMenuGroup
};

================
File: src/models/LocationMenuOverride.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class LocationMenuOverride extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

LocationMenuOverride.attributes = attributes = {
  locationId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Locations', key: 'id' }
  },
  menuItemId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'MenuItems', key: 'id' }
  },
  price: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: true
  },
  isAvailable: {
    type: DataTypes.BOOLEAN,
    allowNull: true
  },
  customName: {
    type: DataTypes.STRING,
    allowNull: true
  },
  customDescription: {
    type: DataTypes.TEXT,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  LocationMenuOverride.init(LocationMenuOverride.attributes, {
    sequelize,
    modelName: 'LocationMenuOverride',
    tableName: 'locationmenuoverrides', // Adjust this if needed
  });
  return LocationMenuOverride
};

================
File: src/models/LocationPOSProfile.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class LocationPOSProfile extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

LocationPOSProfile.attributes = attributes = {
  locationId: {
    type: DataTypes.UUID,
    allowNull: false,
  },
  corePOSProfileId: {
    type: DataTypes.UUID,
    allowNull: false,
    references: {
      model: 'core_pos_profiles',
      key: 'id',
    },
  },
  lastSyncStatus: {
    type: DataTypes.ENUM('SUCCESS', 'FAILED', 'IN_PROGRESS', 'NOT_SYNCED'),
    defaultValue: 'NOT_SYNCED',
  },
  lastSyncError: {
    type: DataTypes.STRING,
  },
  customSettings: {
    type: DataTypes.JSON,
    defaultValue: {},
  },
};

module.exports = (sequelize) => {
  LocationPOSProfile.init(LocationPOSProfile.attributes, {
    sequelize,
    modelName: 'LocationPOSProfile',
    tableName: 'location_pos_profiles', // Adjust this if needed
  });
  return LocationPOSProfile
};

================
File: src/models/LocationProfile.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class LocationProfile extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

LocationProfile.attributes = attributes = {
  locationId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Locations', key: 'id' }
  },
  timezone: {
    type: DataTypes.STRING,
    allowNull: false
  },
  currency: {
    type: DataTypes.STRING,
    allowNull: false
  },
  languagePreference: {
    type: DataTypes.STRING,
    allowNull: true
  },
  deliveryRadius: {
    type: DataTypes.FLOAT,
    allowNull: true
  },
  minimumOrderAmount: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: true
  },
  deliveryFee: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: true
  },
  customSettings: {
    type: DataTypes.JSON,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  LocationProfile.init(LocationProfile.attributes, {
    sequelize,
    modelName: 'LocationProfile',
    tableName: 'locationprofiles', // Adjust this if needed
  });
  return LocationProfile
};

================
File: src/models/LocationTaxConfig.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class LocationTaxConfig extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

LocationTaxConfig.attributes = attributes = {
  locationId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Locations', key: 'id' }
  },
  taxName: {
    type: DataTypes.STRING,
    allowNull: false
  },
  taxRate: {
    type: DataTypes.DECIMAL(5, 2),
    allowNull: false
  },
  isDefault: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: false
  },
  applicableItemCategories: {
    type: DataTypes.JSON,
    allowNull: true
  },
  exemptItemCategories: {
    type: DataTypes.JSON,
    allowNull: true
  },
  startDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  endDate: {
    type: DataTypes.DATE,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  LocationTaxConfig.init(LocationTaxConfig.attributes, {
    sequelize,
    modelName: 'LocationTaxConfig',
    tableName: 'locationtaxconfigs', // Adjust this if needed
  });
  return LocationTaxConfig
};

================
File: src/models/Logger.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Logger extends BaseModel {
  static associate(models) {
    // Define associations here if needed
  }
}

Logger.attributes = attributes = {
  level: {
    type: DataTypes.STRING,
    allowNull: false
  },
  message: {
    type: DataTypes.TEXT,
    allowNull: false
  },
  meta: {
    type: DataTypes.JSON,
    allowNull: true
  },
  timestamp: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW
  },
  source: {
    type: DataTypes.STRING,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  Logger.init(Logger.attributes, {
    sequelize,
    modelName: 'Logger',
    tableName: 'loggers', // Adjust this if needed
  });
  return Logger
};

================
File: src/models/Logger.js.save
================


================
File: src/models/Loyalty.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Loyalty extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

Loyalty.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  pointsPerDollar: {
    type: DataTypes.FLOAT,
    allowNull: false,
    defaultValue: 1
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  startDate: {
    type: DataTypes.DATE,
    allowNull: false
  },
  endDate: {
    type: DataTypes.DATE,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  Loyalty.init(Loyalty.attributes, {
    sequelize,
    modelName: 'Loyalty',
    tableName: 'loyaltys', // Adjust this if needed
  });
  return Loyalty
};

================
File: src/models/LoyaltyAnalytics.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class LoyaltyAnalytics extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

LoyaltyAnalytics.attributes = attributes = {
  loyaltyId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Loyalties', key: 'id' }
  },
  date: {
    type: DataTypes.DATEONLY,
    allowNull: false
  },
  totalPointsEarned: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0
  },
  totalPointsRedeemed: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0
  },
  activeUsers: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0
  },
  newEnrollments: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0
  }
};

module.exports = (sequelize) => {
  LoyaltyAnalytics.init(LoyaltyAnalytics.attributes, {
    sequelize,
    modelName: 'LoyaltyAnalytics',
    tableName: 'loyaltyanalyticss', // Adjust this if needed
  });
  return LoyaltyAnalytics
};

================
File: src/models/LoyaltyChallenge.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class LoyaltyChallenge extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

LoyaltyChallenge.attributes = attributes = {
  loyaltyId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Loyalties', key: 'id' }
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  type: {
    type: DataTypes.ENUM('purchase', 'visit', 'referral', 'social', 'custom'),
    allowNull: false
  },
  goal: {
    type: DataTypes.INTEGER,
    allowNull: false
  },
  reward: {
    type: DataTypes.INTEGER,
    allowNull: false,
    comment: 'Points awarded for completing the challenge'
  },
  startDate: {
    type: DataTypes.DATE,
    allowNull: false
  },
  endDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  }
};

module.exports = (sequelize) => {
  LoyaltyChallenge.init(LoyaltyChallenge.attributes, {
    sequelize,
    modelName: 'LoyaltyChallenge',
    tableName: 'loyaltychallenges', // Adjust this if needed
  });
  return LoyaltyChallenge
};

================
File: src/models/LoyaltyChallengeProgress.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class LoyaltyChallengeProgress extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

LoyaltyChallengeProgress.attributes = attributes = {
  challengeId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'LoyaltyChallenges', key: 'id' }
  },
  userId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Users', key: 'id' }
  },
  progress: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0
  },
  isCompleted: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: false
  },
  completedAt: {
    type: DataTypes.DATE,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  LoyaltyChallengeProgress.init(LoyaltyChallengeProgress.attributes, {
    sequelize,
    modelName: 'LoyaltyChallengeProgress',
    tableName: 'loyaltychallengeprogresss', // Adjust this if needed
  });
  return LoyaltyChallengeProgress
};

================
File: src/models/LoyaltyChallengeRewards.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class LoyaltyChallengeRewards extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

LoyaltyChallengeRewards.attributes = attributes = {
  challengeId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'LoyaltyChallenges', key: 'id' }
  },
  rewardId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'LoyaltyRewards', key: 'id' }
  },
  quantity: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 1
  }
};

module.exports = (sequelize) => {
  LoyaltyChallengeRewards.init(LoyaltyChallengeRewards.attributes, {
    sequelize,
    modelName: 'LoyaltyChallengeRewards',
    tableName: 'loyaltychallengerewardss', // Adjust this if needed
  });
  return LoyaltyChallengeRewards
};

================
File: src/models/LoyaltyConfig.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class LoyaltyConfig extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

LoyaltyConfig.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  pointsPerDollar: {
    type: DataTypes.FLOAT,
    allowNull: false,
    defaultValue: 1
  },
  pointsExpirationMonths: {
    type: DataTypes.INTEGER,
    allowNull: true
  },
  tierSystem: {
    type: DataTypes.JSON,
    allowNull: true
  },
  bonusRules: {
    type: DataTypes.JSON,
    allowNull: true
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  }
};

module.exports = (sequelize) => {
  LoyaltyConfig.init(LoyaltyConfig.attributes, {
    sequelize,
    modelName: 'LoyaltyConfig',
    tableName: 'loyaltyconfigs', // Adjust this if needed
  });
  return LoyaltyConfig
};

================
File: src/models/LoyaltyIntegration.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class LoyaltyIntegration extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

LoyaltyIntegration.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  integrationType: {
    type: DataTypes.ENUM('pos', 'crm', 'email', 'sms', 'other'),
    allowNull: false
  },
  integrationName: {
    type: DataTypes.STRING,
    allowNull: false
  },
  config: {
    type: DataTypes.JSON,
    allowNull: false
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  lastSyncDate: {
    type: DataTypes.DATE,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  LoyaltyIntegration.init(LoyaltyIntegration.attributes, {
    sequelize,
    modelName: 'LoyaltyIntegration',
    tableName: 'loyaltyintegrations', // Adjust this if needed
  });
  return LoyaltyIntegration
};

================
File: src/models/LoyaltyProgram.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class LoyaltyProgram extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

LoyaltyProgram.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  startDate: {
    type: DataTypes.DATE,
    allowNull: false
  },
  endDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  rules: {
    type: DataTypes.JSON,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  LoyaltyProgram.init(LoyaltyProgram.attributes, {
    sequelize,
    modelName: 'LoyaltyProgram',
    tableName: 'loyaltyprograms', // Adjust this if needed
  });
  return LoyaltyProgram
};

================
File: src/models/LoyaltyReward.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class LoyaltyReward extends BaseModel {
  static init(sequelize) {
    super.init({
      id: {
        type: DataTypes.UUID,
        defaultValue: DataTypes.UUIDV4,
        primaryKey: true
      },
      clientId: {
        type: DataTypes.UUID,
        allowNull: false
      },
      name: {
        type: DataTypes.STRING,
        allowNull: false
      },
      description: {
        type: DataTypes.TEXT,
        allowNull: true
      },
      pointsRequired: {
        type: DataTypes.INTEGER,
        allowNull: false
      },
      reward: {
        type: DataTypes.STRING,
        allowNull: false
      }
    }, {
      sequelize,
      modelName: 'LoyaltyReward'
    });
  }

  static associate(models) {
    // Define associations if any
  }
}

module.exports = LoyaltyReward;

================
File: src/models/LoyaltySubscription.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class LoyaltySubscription extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

LoyaltySubscription.attributes = attributes = {
  userId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Users', key: 'id' }
  },
  programId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'LoyaltyPrograms', key: 'id' }
  },
  startDate: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW
  },
  endDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  status: {
    type: DataTypes.ENUM('active', 'paused', 'cancelled'),
    allowNull: false,
    defaultValue: 'active'
  },
  currentPoints: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0
  },
  currentTier: {
    type: DataTypes.STRING,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  LoyaltySubscription.init(LoyaltySubscription.attributes, {
    sequelize,
    modelName: 'LoyaltySubscription',
    tableName: 'loyaltysubscriptions', // Adjust this if needed
  });
  return LoyaltySubscription
};

================
File: src/models/LoyaltyTier.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class LoyaltyTier extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

LoyaltyTier.attributes = attributes = {
  programId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'LoyaltyPrograms', key: 'id' }
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  requiredPoints: {
    type: DataTypes.INTEGER,
    allowNull: false
  },
  benefits: {
    type: DataTypes.JSON,
    allowNull: true
  },
  multiplier: {
    type: DataTypes.FLOAT,
    allowNull: false,
    defaultValue: 1
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  }
};

module.exports = (sequelize) => {
  LoyaltyTier.init(LoyaltyTier.attributes, {
    sequelize,
    modelName: 'LoyaltyTier',
    tableName: 'loyaltytiers', // Adjust this if needed
  });
  return LoyaltyTier
};

================
File: src/models/LoyaltyTransaction.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class LoyaltyTransaction extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

LoyaltyTransaction.attributes = attributes = {
  userId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Users', key: 'id' }
  },
  programId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'LoyaltyPrograms', key: 'id' }
  },
  orderId: {
    type: DataTypes.INTEGER,
    allowNull: true,
    references: { model: 'Orders', key: 'id' }
  },
  points: {
    type: DataTypes.INTEGER,
    allowNull: false
  },
  type: {
    type: DataTypes.ENUM('earn', 'redeem', 'expire', 'adjust'),
    allowNull: false
  },
  description: {
    type: DataTypes.STRING,
    allowNull: true
  },
  balance: {
    type: DataTypes.INTEGER,
    allowNull: false
  }
};

module.exports = (sequelize) => {
  LoyaltyTransaction.init(LoyaltyTransaction.attributes, {
    sequelize,
    modelName: 'LoyaltyTransaction',
    tableName: 'loyaltytransactions', // Adjust this if needed
  });
  return LoyaltyTransaction
};

================
File: src/models/MarketingCampaign.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class MarketingCampaign extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

MarketingCampaign.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  type: {
    type: DataTypes.ENUM('email', 'sms', 'push', 'social', 'other'),
    allowNull: false
  },
  status: {
    type: DataTypes.ENUM('draft', 'scheduled', 'active', 'paused', 'completed'),
    allowNull: false,
    defaultValue: 'draft'
  },
  startDate: {
    type: DataTypes.DATE,
    allowNull: false
  },
  endDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  targetAudience: {
    type: DataTypes.JSON,
    allowNull: true
  },
  content: {
    type: DataTypes.JSON,
    allowNull: true
  },
  budget: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: true
  }
};

module.exports = (sequelize) => {
  MarketingCampaign.init(MarketingCampaign.attributes, {
    sequelize,
    modelName: 'MarketingCampaign',
    tableName: 'marketingcampaigns', // Adjust this if needed
  });
  return MarketingCampaign
};

================
File: src/models/MarketingPerformance.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class MarketingPerformance extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

MarketingPerformance.attributes = attributes = {
  campaignId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'MarketingCampaigns', key: 'id' }
  },
  date: {
    type: DataTypes.DATEONLY,
    allowNull: false
  },
  impressions: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0
  },
  clicks: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0
  },
  conversions: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0
  },
  revenue: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false,
    defaultValue: 0
  },
  cost: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false,
    defaultValue: 0
  },
  roi: {
    type: DataTypes.FLOAT,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  MarketingPerformance.init(MarketingPerformance.attributes, {
    sequelize,
    modelName: 'MarketingPerformance',
    tableName: 'marketingperformances', // Adjust this if needed
  });
  return MarketingPerformance
};

================
File: src/models/MarketingReport.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class MarketingReport extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

MarketingReport.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  campaignId: {
    type: DataTypes.INTEGER,
    allowNull: true,
    references: { model: 'MarketingCampaigns', key: 'id' }
  },
  reportType: {
    type: DataTypes.ENUM('daily', 'weekly', 'monthly', 'campaign'),
    allowNull: false
  },
  startDate: {
    type: DataTypes.DATE,
    allowNull: false
  },
  endDate: {
    type: DataTypes.DATE,
    allowNull: false
  },
  metrics: {
    type: DataTypes.JSON,
    allowNull: false
  },
  insights: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  recommendations: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  generatedAt: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW
  }
};

module.exports = (sequelize) => {
  MarketingReport.init(MarketingReport.attributes, {
    sequelize,
    modelName: 'MarketingReport',
    tableName: 'marketingreports', // Adjust this if needed
  });
  return MarketingReport
};

================
File: src/models/Menu.js
================
const { DataTypes } = require('sequelize');
const sequelize = require('../db');

const Menu = sequelize.define('Menu', {
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true,
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false,
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true,
  },
  clientId: {
    type: DataTypes.UUID,
    allowNull: false,
  },
  locationId: {
    type: DataTypes.UUID,
    allowNull: true,
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    defaultValue: true,
  },
  startDate: {
    type: DataTypes.DATE,
    allowNull: true,
  },
  endDate: {
    type: DataTypes.DATE,
    allowNull: true,
  },
  menuType: {
    type: DataTypes.ENUM('REGULAR', 'SPECIAL', 'SEASONAL'),
    defaultValue: 'REGULAR',
  },
});

Menu.associate = (models) => {
  Menu.hasMany(models.MenuGroup, { as: 'groups', foreignKey: 'menuId' });
  Menu.belongsTo(models.Client, { foreignKey: 'clientId' });
  Menu.belongsTo(models.Location, { foreignKey: 'locationId' });
};

module.exports = Menu;

================
File: src/models/MenuAnalytics.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class MenuAnalytics extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

MenuAnalytics.attributes = attributes = {
  menuId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Menus', key: 'id' }
  },
  locationId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Locations', key: 'id' }
  },
  date: {
    type: DataTypes.DATEONLY,
    allowNull: false
  },
  views: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0
  },
  orders: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0
  },
  revenue: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false,
    defaultValue: 0
  },
  averageOrderValue: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false,
    defaultValue: 0
  }
};

module.exports = (sequelize) => {
  MenuAnalytics.init(MenuAnalytics.attributes, {
    sequelize,
    modelName: 'MenuAnalytics',
    tableName: 'menuanalyticss', // Adjust this if needed
  });
  return MenuAnalytics
};

================
File: src/models/MenuBuilderSettings.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class MenuBuilderSettings extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

MenuBuilderSettings.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  defaultCurrency: {
    type: DataTypes.STRING,
    allowNull: false,
    defaultValue: 'USD'
  },
  allowCustomization: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  maxCategories: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 10
  },
  maxItemsPerCategory: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 50
  },
  allowSpecialInstructions: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  customSettings: {
    type: DataTypes.JSON,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  MenuBuilderSettings.init(MenuBuilderSettings.attributes, {
    sequelize,
    modelName: 'MenuBuilderSettings',
    tableName: 'menubuildersettingss', // Adjust this if needed
  });
  return MenuBuilderSettings
};

================
File: src/models/MenuGroup.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class MenuGroup extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

MenuGroup.attributes = attributes = {
  menuId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Menus', key: 'id' }
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  displayOrder: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  }
};

module.exports = (sequelize) => {
  MenuGroup.init(MenuGroup.attributes, {
    sequelize,
    modelName: 'MenuGroup',
    tableName: 'menugroups', // Adjust this if needed
  });
  return MenuGroup
};

================
File: src/models/MenuItem.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class MenuItem extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

MenuItem.attributes = attributes = {
  menuId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Menus', key: 'id' }
  },
  menuGroupId: {
    type: DataTypes.INTEGER,
    allowNull: true,
    references: { model: 'MenuGroups', key: 'id' }
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  price: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false
  },
  imageUrl: {
    type: DataTypes.STRING,
    allowNull: true
  },
  isAvailable: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  calories: {
    type: DataTypes.INTEGER,
    allowNull: true
  },
  allergens: {
    type: DataTypes.JSON,
    allowNull: true
  },
  tags: {
    type: DataTypes.JSON,
    allowNull: true
  },
  displayOrder: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0
  }
};

module.exports = (sequelize) => {
  MenuItem.init(MenuItem.attributes, {
    sequelize,
    modelName: 'MenuItem',
    tableName: 'menuitems', // Adjust this if needed
  });
  return MenuItem
};

================
File: src/models/MenuItemAnalytics.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class MenuItemAnalytics extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

MenuItemAnalytics.attributes = attributes = {
  menuItemId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'MenuItems', key: 'id' }
  },
  locationId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Locations', key: 'id' }
  },
  date: {
    type: DataTypes.DATEONLY,
    allowNull: false
  },
  views: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0
  },
  orders: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0
  },
  revenue: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false,
    defaultValue: 0
  },
  averageRating: {
    type: DataTypes.FLOAT,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  MenuItemAnalytics.init(MenuItemAnalytics.attributes, {
    sequelize,
    modelName: 'MenuItemAnalytics',
    tableName: 'menuitemanalyticss', // Adjust this if needed
  });
  return MenuItemAnalytics
};

================
File: src/models/MenuItemModifier.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class MenuItemModifier extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

MenuItemModifier.attributes = attributes = {
  menuItemId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'MenuItems', key: 'id' }
  },
  modifierId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Modifiers', key: 'id' }
  },
  isRequired: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: false
  },
  minSelection: {
    type: DataTypes.INTEGER,
    allowNull: true
  },
  maxSelection: {
    type: DataTypes.INTEGER,
    allowNull: true
  },
  displayOrder: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0
  }
};

module.exports = (sequelize) => {
  MenuItemModifier.init(MenuItemModifier.attributes, {
    sequelize,
    modelName: 'MenuItemModifier',
    tableName: 'menuitemmodifiers', // Adjust this if needed
  });
  return MenuItemModifier
};

================
File: src/models/MenuItemSizeModifier.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class MenuItemSizeModifier extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

MenuItemSizeModifier.attributes = attributes = {
  menuItemId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'MenuItems', key: 'id' }
  },
  sizeModifierId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'SizeModifiers', key: 'id' }
  },
  price: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false
  },
  isDefault: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: false
  },
  isAvailable: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  displayOrder: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0
  }
};

module.exports = (sequelize) => {
  MenuItemSizeModifier.init(MenuItemSizeModifier.attributes, {
    sequelize,
    modelName: 'MenuItemSizeModifier',
    tableName: 'menuitemsizemodifiers', // Adjust this if needed
  });
  return MenuItemSizeModifier
};

================
File: src/models/MenuSyncHistory.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class MenuSyncHistory extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

MenuSyncHistory.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  menuId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Menus', key: 'id' }
  },
  syncType: {
    type: DataTypes.ENUM('manual', 'automatic', 'scheduled'),
    allowNull: false
  },
  status: {
    type: DataTypes.ENUM('success', 'failed', 'partial'),
    allowNull: false
  },
  startTime: {
    type: DataTypes.DATE,
    allowNull: false
  },
  endTime: {
    type: DataTypes.DATE,
    allowNull: false
  },
  details: {
    type: DataTypes.JSON,
    allowNull: true
  },
  errorMessage: {
    type: DataTypes.TEXT,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  MenuSyncHistory.init(MenuSyncHistory.attributes, {
    sequelize,
    modelName: 'MenuSyncHistory',
    tableName: 'menusynchistorys', // Adjust this if needed
  });
  return MenuSyncHistory
};

================
File: src/models/MiniSite.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class MiniSite extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

MiniSite.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  subdomain: {
    type: DataTypes.STRING,
    allowNull: false,
    unique: true
  },
  theme: {
    type: DataTypes.STRING,
    allowNull: false,
    defaultValue: 'default'
  },
  customDomain: {
    type: DataTypes.STRING,
    allowNull: true,
    unique: true
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  settings: {
    type: DataTypes.JSON,
    allowNull: true
  },
  seoSettings: {
    type: DataTypes.JSON,
    allowNull: true
  },
  createdAt: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW
  },
  updatedAt: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW
  }
};

module.exports = (sequelize) => {
  MiniSite.init(MiniSite.attributes, {
    sequelize,
    modelName: 'MiniSite',
    tableName: 'minisites', // Adjust this if needed
  });
  return MiniSite
};

================
File: src/models/MiniSiteAnalytics.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class MiniSiteAnalytics extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

MiniSiteAnalytics.attributes = attributes = {
  miniSiteId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'MiniSites', key: 'id' }
  },
  date: {
    type: DataTypes.DATEONLY,
    allowNull: false
  },
  pageViews: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0
  },
  uniqueVisitors: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0
  },
  averageTimeOnSite: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0,
    comment: 'Average time on site in seconds'
  },
  bounceRate: {
    type: DataTypes.FLOAT,
    allowNull: false,
    defaultValue: 0
  },
  conversionRate: {
    type: DataTypes.FLOAT,
    allowNull: false,
    defaultValue: 0
  }
};

module.exports = (sequelize) => {
  MiniSiteAnalytics.init(MiniSiteAnalytics.attributes, {
    sequelize,
    modelName: 'MiniSiteAnalytics',
    tableName: 'minisiteanalyticss', // Adjust this if needed
  });
  return MiniSiteAnalytics
};

================
File: src/models/ModelName.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class ModelName extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

ModelName.attributes = attributes = {
  // Define attributes here
};

module.exports = (sequelize) => {
  ModelName.init(ModelName.attributes, {
    sequelize,
    modelName: 'ModelName',
    tableName: 'modelnames', // Adjust this if needed
  });
  return ModelName
};

================
File: src/models/Modifier.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Modifier extends BaseModel {
  static init(sequelize) {
    super.init({
      id: {
        type: DataTypes.UUID,
        defaultValue: DataTypes.UUIDV4,
        primaryKey: true
      },
      orderItemId: {
        type: DataTypes.UUID,
        allowNull: false
      },
      name: {
        type: DataTypes.STRING,
        allowNull: false
      },
      price: {
        type: DataTypes.FLOAT,
        allowNull: false
      }
    }, {
      sequelize,
      modelName: 'Modifier'
    });
  }

  static associate(models) {
    this.belongsTo(models.OrderItem, { foreignKey: 'orderItemId' });
  }
}

module.exports = Modifier;

================
File: src/models/Order.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Order extends BaseModel {
  static init(sequelize) {
    super.init({
      id: {
        type: DataTypes.UUID,
        defaultValue: DataTypes.UUIDV4,
        primaryKey: true
      },
      clientId: {
        type: DataTypes.UUID,
        allowNull: false
      },
      customerId: {
        type: DataTypes.UUID,
        allowNull: false
      },
      total: {
        type: DataTypes.FLOAT,
        allowNull: false
      },
      status: {
        type: DataTypes.ENUM('PENDING', 'PROCESSING', 'COMPLETED', 'CANCELLED'),
        allowNull: false
      }
    }, {
      sequelize,
      modelName: 'Order'
    });
  }

  static associate(models) {
    this.hasMany(models.OrderItem, { foreignKey: 'orderId' });
  }
}

module.exports = Order;

================
File: src/models/OrderHistory.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class OrderHistory extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

OrderHistory.attributes = attributes = {
  orderId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Orders', key: 'id' }
  },
  userId: {
    type: DataTypes.INTEGER,
    allowNull: true,
    references: { model: 'Users', key: 'id' }
  },
  status: {
    type: DataTypes.ENUM('pending', 'processing', 'completed', 'cancelled'),
    allowNull: false
  },
  note: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  timestamp: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW
  }
};

module.exports = (sequelize) => {
  OrderHistory.init(OrderHistory.attributes, {
    sequelize,
    modelName: 'OrderHistory',
    tableName: 'orderhistorys', // Adjust this if needed
  });
  return OrderHistory
};

================
File: src/models/OrderItem.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class OrderItem extends BaseModel {
  static init(sequelize) {
    super.init({
      id: {
        type: DataTypes.UUID,
        defaultValue: DataTypes.UUIDV4,
        primaryKey: true
      },
      orderId: {
        type: DataTypes.UUID,
        allowNull: false
      },
      menuItemId: {
        type: DataTypes.UUID,
        allowNull: false
      },
      name: {
        type: DataTypes.STRING,
        allowNull: false
      },
      quantity: {
        type: DataTypes.INTEGER,
        allowNull: false
      },
      price: {
        type: DataTypes.FLOAT,
        allowNull: false
      },
      specialInstructions: {
        type: DataTypes.TEXT,
        allowNull: true
      }
    }, {
      sequelize,
      modelName: 'OrderItem'
    });
  }

  static associate(models) {
    this.belongsTo(models.Order, { foreignKey: 'orderId' });
    this.belongsTo(models.MenuItem, { foreignKey: 'menuItemId' });
    this.hasMany(models.Modifier, { foreignKey: 'orderItemId' });
  }
}

module.exports = OrderItem;

================
File: src/models/OrderProvider.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class OrderProvider extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

OrderProvider.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  providerId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Providers', key: 'id' }
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  apiKey: {
    type: DataTypes.STRING,
    allowNull: true
  },
  apiSecret: {
    type: DataTypes.STRING,
    allowNull: true
  },
  settings: {
    type: DataTypes.JSON,
    allowNull: true
  },
  lastSyncDate: {
    type: DataTypes.DATE,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  OrderProvider.init(OrderProvider.attributes, {
    sequelize,
    modelName: 'OrderProvider',
    tableName: 'orderproviders', // Adjust this if needed
  });
  return OrderProvider
};

================
File: src/models/PaymentProfile.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class PaymentProfile extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

PaymentProfile.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  userId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Users', key: 'id' }
  },
  paymentType: {
    type: DataTypes.ENUM('credit_card', 'bank_account', 'paypal', 'other'),
    allowNull: false
  },
  isDefault: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: false
  },
  lastFour: {
    type: DataTypes.STRING(4),
    allowNull: false
  },
  expirationDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  tokenizedData: {
    type: DataTypes.TEXT,
    allowNull: false
  },
  billingAddress: {
    type: DataTypes.JSON,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  PaymentProfile.init(PaymentProfile.attributes, {
    sequelize,
    modelName: 'PaymentProfile',
    tableName: 'paymentprofiles', // Adjust this if needed
  });
  return PaymentProfile
};

================
File: src/models/Permission.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Permission extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

Permission.attributes = attributes = {
  name: {
    type: DataTypes.STRING,
    allowNull: false,
    unique: true
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  category: {
    type: DataTypes.STRING,
    allowNull: false
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  }
};

module.exports = (sequelize) => {
  Permission.init(Permission.attributes, {
    sequelize,
    modelName: 'Permission',
    tableName: 'permissions', // Adjust this if needed
  });
  return Permission
};

================
File: src/models/PosIntegration.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class PosIntegration extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

PosIntegration.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  posType: {
    type: DataTypes.STRING,
    allowNull: false
  },
  apiKey: {
    type: DataTypes.STRING,
    allowNull: true
  },
  apiSecret: {
    type: DataTypes.STRING,
    allowNull: true
  },
  accessToken: {
    type: DataTypes.STRING,
    allowNull: true
  },
  refreshToken: {
    type: DataTypes.STRING,
    allowNull: true
  },
  tokenExpiresAt: {
    type: DataTypes.DATE,
    allowNull: true
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  lastSyncDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  settings: {
    type: DataTypes.JSON,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  PosIntegration.init(PosIntegration.attributes, {
    sequelize,
    modelName: 'PosIntegration',
    tableName: 'posintegrations', // Adjust this if needed
  });
  return PosIntegration
};

================
File: src/models/PosIntegrationErrorLog.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class PosIntegrationErrorLog extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

PosIntegrationErrorLog.attributes = attributes = {
  posIntegrationId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'PosIntegrations', key: 'id' }
  },
  errorType: {
    type: DataTypes.STRING,
    allowNull: false
  },
  errorMessage: {
    type: DataTypes.TEXT,
    allowNull: false
  },
  errorDetails: {
    type: DataTypes.JSON,
    allowNull: true
  },
  occurredAt: {
    type: DataTypes.DATE,
    allowNull: false,
    defaultValue: DataTypes.NOW
  },
  resolved: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: false
  },
  resolvedAt: {
    type: DataTypes.DATE,
    allowNull: true
  },
  resolutionNotes: {
    type: DataTypes.TEXT,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  PosIntegrationErrorLog.init(PosIntegrationErrorLog.attributes, {
    sequelize,
    modelName: 'PosIntegrationErrorLog',
    tableName: 'posintegrationerrorlogs', // Adjust this if needed
  });
  return PosIntegrationErrorLog
};

================
File: src/models/PosIntegrationMapping.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class PosIntegrationMapping extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

PosIntegrationMapping.attributes = attributes = {
  posIntegrationId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'PosIntegrations', key: 'id' }
  },
  entityType: {
    type: DataTypes.STRING,
    allowNull: false
  },
  localId: {
    type: DataTypes.STRING,
    allowNull: false
  },
  externalId: {
    type: DataTypes.STRING,
    allowNull: false
  },
  mappingData: {
    type: DataTypes.JSON,
    allowNull: true
  },
  lastSyncDate: {
    type: DataTypes.DATE,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  PosIntegrationMapping.init(PosIntegrationMapping.attributes, {
    sequelize,
    modelName: 'PosIntegrationMapping',
    tableName: 'posintegrationmappings', // Adjust this if needed
  });
  return PosIntegrationMapping
};

================
File: src/models/PosIntegrationSettings.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class PosIntegrationSettings extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

PosIntegrationSettings.attributes = attributes = {
  posIntegrationId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'PosIntegrations', key: 'id' }
  },
  syncFrequency: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 60, // in minutes
    comment: 'How often to sync with POS system in minutes'
  },
  autoSync: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  syncItems: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  syncCategories: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  syncModifiers: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  syncOrders: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  customSettings: {
    type: DataTypes.JSON,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  PosIntegrationSettings.init(PosIntegrationSettings.attributes, {
    sequelize,
    modelName: 'PosIntegrationSettings',
    tableName: 'posintegrationsettingss', // Adjust this if needed
  });
  return PosIntegrationSettings
};

================
File: src/models/PosProfile.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class PosProfile extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

PosProfile.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  posType: {
    type: DataTypes.ENUM('Toast', 'Square', 'Clover', 'Other'),
    allowNull: false
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  apiKey: {
    type: DataTypes.STRING,
    allowNull: true
  },
  apiSecret: {
    type: DataTypes.STRING,
    allowNull: true
  },
  accessToken: {
    type: DataTypes.STRING,
    allowNull: true
  },
  refreshToken: {
    type: DataTypes.STRING,
    allowNull: true
  },
  tokenExpiresAt: {
    type: DataTypes.DATE,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  PosProfile.init(PosProfile.attributes, {
    sequelize,
    modelName: 'PosProfile',
    tableName: 'posprofiles', // Adjust this if needed
  });
  return PosProfile
};

================
File: src/models/PosProfileConfig.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class PosProfileConfig extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

PosProfileConfig.attributes = attributes = {
  posProfileId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'PosProfiles', key: 'id' }
  },
  syncFrequency: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 60, // in minutes
  },
  autoSync: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  menuSyncEnabled: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  orderSyncEnabled: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  customerSyncEnabled: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  customConfig: {
    type: DataTypes.JSON,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  PosProfileConfig.init(PosProfileConfig.attributes, {
    sequelize,
    modelName: 'PosProfileConfig',
    tableName: 'posprofileconfigs', // Adjust this if needed
  });
  return PosProfileConfig
};

================
File: src/models/PosSettings.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class POSSettings extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

POSSettings.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  posType: {
    type: DataTypes.STRING,
    allowNull: false
  },
  apiEndpoint: {
    type: DataTypes.STRING,
    allowNull: true
  },
  apiKey: {
    type: DataTypes.STRING,
    allowNull: true
  },
  apiSecret: {
    type: DataTypes.STRING,
    allowNull: true
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  settings: {
    type: DataTypes.JSON,
    allowNull: true
  },
  lastSyncDate: {
    type: DataTypes.DATE,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  POSSettings.init(POSSettings.attributes, {
    sequelize,
    modelName: 'POSSettings',
    tableName: 'possettingss', // Adjust this if needed
  });
  return POSSettings
};

================
File: src/models/PricingOverride.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class PricingOverride extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

PricingOverride.attributes = attributes = {
  menuItemId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'MenuItems', key: 'id' }
  },
  locationId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Locations', key: 'id' }
  },
  price: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false
  },
  startDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  endDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  reason: {
    type: DataTypes.STRING,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  PricingOverride.init(PricingOverride.attributes, {
    sequelize,
    modelName: 'PricingOverride',
    tableName: 'pricingoverrides', // Adjust this if needed
  });
  return PricingOverride
};

================
File: src/models/PricingUplift.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class PricingUplift extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

PricingUplift.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  locationId: {
    type: DataTypes.INTEGER,
    allowNull: true,
    references: { model: 'Locations', key: 'id' }
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  type: {
    type: DataTypes.ENUM('percentage', 'fixed'),
    allowNull: false
  },
  value: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false
  },
  appliesTo: {
    type: DataTypes.ENUM('all', 'category', 'item'),
    allowNull: false
  },
  categoryId: {
    type: DataTypes.INTEGER,
    allowNull: true,
    references: { model: 'Categories', key: 'id' }
  },
  menuItemId: {
    type: DataTypes.INTEGER,
    allowNull: true,
    references: { model: 'MenuItems', key: 'id' }
  },
  startDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  endDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  }
};

module.exports = (sequelize) => {
  PricingUplift.init(PricingUplift.attributes, {
    sequelize,
    modelName: 'PricingUplift',
    tableName: 'pricinguplifts', // Adjust this if needed
  });
  return PricingUplift
};

================
File: src/models/Product.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Product extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

Product.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  categoryId: {
    type: DataTypes.INTEGER,
    allowNull: true,
    references: { model: 'Categories', key: 'id' }
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  sku: {
    type: DataTypes.STRING,
    allowNull: true,
    unique: true
  },
  price: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false
  },
  cost: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: true
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  imageUrl: {
    type: DataTypes.STRING,
    allowNull: true
  },
  attributes: {
    type: DataTypes.JSON,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  Product.init(Product.attributes, {
    sequelize,
    modelName: 'Product',
    tableName: 'products', // Adjust this if needed
  });
  return Product
};

================
File: src/models/Provider.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Provider extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

Provider.attributes = attributes = {
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  type: {
    type: DataTypes.ENUM('delivery', 'pos', 'payment', 'other'),
    allowNull: false
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  apiEndpoint: {
    type: DataTypes.STRING,
    allowNull: true
  },
  apiVersion: {
    type: DataTypes.STRING,
    allowNull: true
  },
  supportContact: {
    type: DataTypes.STRING,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  Provider.init(Provider.attributes, {
    sequelize,
    modelName: 'Provider',
    tableName: 'providers', // Adjust this if needed
  });
  return Provider
};

================
File: src/models/ProviderIntegration.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class ProviderIntegration extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

ProviderIntegration.attributes = attributes = {
  providerId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Providers', key: 'id' }
  },
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  apiKey: {
    type: DataTypes.STRING,
    allowNull: true
  },
  apiSecret: {
    type: DataTypes.STRING,
    allowNull: true
  },
  accessToken: {
    type: DataTypes.STRING,
    allowNull: true
  },
  refreshToken: {
    type: DataTypes.STRING,
    allowNull: true
  },
  tokenExpiresAt: {
    type: DataTypes.DATE,
    allowNull: true
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  settings: {
    type: DataTypes.JSON,
    allowNull: true
  },
  lastSyncDate: {
    type: DataTypes.DATE,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  ProviderIntegration.init(ProviderIntegration.attributes, {
    sequelize,
    modelName: 'ProviderIntegration',
    tableName: 'providerintegrations', // Adjust this if needed
  });
  return ProviderIntegration
};

================
File: src/models/ProviderPricing.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class ProviderPricing extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

ProviderPricing.attributes = attributes = {
  providerId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Providers', key: 'id' }
  },
  planName: {
    type: DataTypes.STRING,
    allowNull: false
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  price: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false
  },
  billingCycle: {
    type: DataTypes.ENUM('monthly', 'yearly', 'per-transaction'),
    allowNull: false
  },
  features: {
    type: DataTypes.JSON,
    allowNull: true
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  startDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  endDate: {
    type: DataTypes.DATE,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  ProviderPricing.init(ProviderPricing.attributes, {
    sequelize,
    modelName: 'ProviderPricing',
    tableName: 'providerpricings', // Adjust this if needed
  });
  return ProviderPricing
};

================
File: src/models/ProviderProfile.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class ProviderProfile extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

ProviderProfile.attributes = attributes = {
  providerId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Providers', key: 'id' }
  },
  logo: {
    type: DataTypes.STRING,
    allowNull: true
  },
  website: {
    type: DataTypes.STRING,
    allowNull: true
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  supportEmail: {
    type: DataTypes.STRING,
    allowNull: true
  },
  supportPhone: {
    type: DataTypes.STRING,
    allowNull: true
  },
  technicalContactName: {
    type: DataTypes.STRING,
    allowNull: true
  },
  technicalContactEmail: {
    type: DataTypes.STRING,
    allowNull: true
  },
  serviceAreas: {
    type: DataTypes.JSON,
    allowNull: true
  },
  features: {
    type: DataTypes.JSON,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  ProviderProfile.init(ProviderProfile.attributes, {
    sequelize,
    modelName: 'ProviderProfile',
    tableName: 'providerprofiles', // Adjust this if needed
  });
  return ProviderProfile
};

================
File: src/models/Refund.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Refund extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

Refund.attributes = attributes = {
  orderId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Orders', key: 'id' }
  },
  userId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Users', key: 'id' }
  },
  amount: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false
  },
  reason: {
    type: DataTypes.TEXT,
    allowNull: false
  },
  status: {
    type: DataTypes.ENUM('pending', 'processed', 'rejected'),
    allowNull: false,
    defaultValue: 'pending'
  },
  processedBy: {
    type: DataTypes.INTEGER,
    allowNull: true,
    references: { model: 'Users', key: 'id' }
  },
  processedAt: {
    type: DataTypes.DATE,
    allowNull: true
  },
  refundMethod: {
    type: DataTypes.ENUM('original_payment', 'store_credit', 'bank_transfer'),
    allowNull: false
  }
};

module.exports = (sequelize) => {
  Refund.init(Refund.attributes, {
    sequelize,
    modelName: 'Refund',
    tableName: 'refunds', // Adjust this if needed
  });
  return Refund
};

================
File: src/models/Report.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Report extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

Report.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  type: {
    type: DataTypes.ENUM('sales', 'inventory', 'customer', 'financial', 'custom'),
    allowNull: false
  },
  parameters: {
    type: DataTypes.JSON,
    allowNull: true
  },
  schedule: {
    type: DataTypes.JSON,
    allowNull: true
  },
  lastRunAt: {
    type: DataTypes.DATE,
    allowNull: true
  },
  createdBy: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Users', key: 'id' }
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  }
};

module.exports = (sequelize) => {
  Report.init(Report.attributes, {
    sequelize,
    modelName: 'Report',
    tableName: 'reports', // Adjust this if needed
  });
  return Report
};

================
File: src/models/Review.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Review extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

Review.attributes = attributes = {
  userId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Users', key: 'id' }
  },
  orderId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Orders', key: 'id' }
  },
  menuItemId: {
    type: DataTypes.INTEGER,
    allowNull: true,
    references: { model: 'MenuItems', key: 'id' }
  },
  rating: {
    type: DataTypes.INTEGER,
    allowNull: false,
    validate: {
      min: 1,
      max: 5
    }
  },
  comment: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  isVerified: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: false
  },
  status: {
    type: DataTypes.ENUM('pending', 'approved', 'rejected'),
    allowNull: false,
    defaultValue: 'pending'
  }
};

module.exports = (sequelize) => {
  Review.init(Review.attributes, {
    sequelize,
    modelName: 'Review',
    tableName: 'reviews', // Adjust this if needed
  });
  return Review
};

================
File: src/models/Reward.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Reward extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

Reward.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  type: {
    type: DataTypes.ENUM('discount', 'freeItem', 'points', 'other'),
    allowNull: false
  },
  value: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false
  },
  code: {
    type: DataTypes.STRING,
    allowNull: true,
    unique: true
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  startDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  endDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  usageLimit: {
    type: DataTypes.INTEGER,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  Reward.init(Reward.attributes, {
    sequelize,
    modelName: 'Reward',
    tableName: 'rewards', // Adjust this if needed
  });
  return Reward
};

================
File: src/models/RewardSchedule.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class RewardSchedule extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

RewardSchedule.attributes = attributes = {
  rewardId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Rewards', key: 'id' }
  },
  dayOfWeek: {
    type: DataTypes.INTEGER,
    allowNull: false,
    validate: {
      min: 0,
      max: 6
    }
  },
  startTime: {
    type: DataTypes.TIME,
    allowNull: false
  },
  endTime: {
    type: DataTypes.TIME,
    allowNull: false
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  }
};

module.exports = (sequelize) => {
  RewardSchedule.init(RewardSchedule.attributes, {
    sequelize,
    modelName: 'RewardSchedule',
    tableName: 'rewardschedules', // Adjust this if needed
  });
  return RewardSchedule
};

================
File: src/models/Role.js
================
const BaseModel = require('./BaseModel');

class Role extends BaseModel {
  static associate(models) {
    this.belongsToMany(models.RoleTemplate, {
      through: models.RoleTemplateAssignments,
      foreignKey: 'roleId',
      otherKey: 'roleTemplateId',
      as: 'AssignedTemplates'
    });
  }

  static modelAttributes(DataTypes) {
    return {
      name: {
        type: DataTypes.STRING,
        allowNull: false,
        unique: true,
      },
      description: {
        type: DataTypes.STRING,
        allowNull: true,
      },
    };
  }
}

module.exports = Role;

================
File: src/models/RolePermission.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class RolePermission extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

RolePermission.attributes = attributes = {
  roleId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Roles', key: 'id' }
  },
  permissionId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Permissions', key: 'id' }
  }
};

module.exports = (sequelize) => {
  RolePermission.init(RolePermission.attributes, {
    sequelize,
    modelName: 'RolePermission',
    tableName: 'rolepermissions', // Adjust this if needed
  });
  return RolePermission
};

================
File: src/models/RolePermissions.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class RolePermissions extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

RolePermissions.attributes = {
  // Define attributes here
};

module.exports = (sequelize) => {
  RolePermissions.init(RolePermissions.attributes, {
    sequelize,
    modelName: 'RolePermissions',
    tableName: 'rolepermissionss', // Adjust this if needed
  });
  return RolePermissions
};

================
File: src/models/RoleTemplate.js
================
const BaseModel = require('./BaseModel');

class RoleTemplate extends BaseModel {
  static associate(models) {
    this.belongsToMany(models.Role, {
      through: models.RoleTemplateAssignments, // Make sure this model exists
      foreignKey: 'roleTemplateId',
      otherKey: 'roleId',
      as: 'AssignedRoles'
    });
  }

  static modelAttributes(DataTypes) {
    return {
      name: {
        type: DataTypes.STRING,
        allowNull: false,
        unique: true,
      },
      description: {
        type: DataTypes.STRING,
        allowNull: true,
      },
      isEditable: {
        type: DataTypes.BOOLEAN,
        defaultValue: true,
      },
      isPredefined: {
        type: DataTypes.BOOLEAN,
        defaultValue: false,
      },
    };
  }
}

module.exports = RoleTemplate;

================
File: src/models/RoleTemplateAssignments.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class RoleTemplateAssignments extends BaseModel {
  static modelAttributes(DataTypes) {
    return {
      roleId: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
          model: 'Roles',
          key: 'id'
        }
      },
      roleTemplateId: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: {
          model: 'RoleTemplates',
          key: 'id'
        }
      }
    };
  }
}

module.exports = RoleTemplateAssignments;

================
File: src/models/SalesAnalytics.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class SalesAnalytics extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

SalesAnalytics.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  locationId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Locations', key: 'id' }
  },
  date: {
    type: DataTypes.DATEONLY,
    allowNull: false
  },
  totalSales: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false,
    defaultValue: 0
  },
  orderCount: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0
  },
  averageOrderValue: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false,
    defaultValue: 0
  },
  topSellingItems: {
    type: DataTypes.JSON,
    allowNull: true
  },
  salesByHour: {
    type: DataTypes.JSON,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  SalesAnalytics.init(SalesAnalytics.attributes, {
    sequelize,
    modelName: 'SalesAnalytics',
    tableName: 'salesanalyticss', // Adjust this if needed
  });
  return SalesAnalytics
};

================
File: src/models/SalesReport.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class SalesReport extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

SalesReport.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  locationId: {
    type: DataTypes.INTEGER,
    allowNull: true,
    references: { model: 'Locations', key: 'id' }
  },
  reportDate: {
    type: DataTypes.DATEONLY,
    allowNull: false
  },
  reportType: {
    type: DataTypes.ENUM('daily', 'weekly', 'monthly', 'yearly'),
    allowNull: false
  },
  totalSales: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false
  },
  totalOrders: {
    type: DataTypes.INTEGER,
    allowNull: false
  },
  averageOrderValue: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false
  },
  topSellingItems: {
    type: DataTypes.JSON,
    allowNull: true
  },
  salesByCategory: {
    type: DataTypes.JSON,
    allowNull: true
  },
  salesByHour: {
    type: DataTypes.JSON,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  SalesReport.init(SalesReport.attributes, {
    sequelize,
    modelName: 'SalesReport',
    tableName: 'salesreports', // Adjust this if needed
  });
  return SalesReport
};

================
File: src/models/ScheduledOrder.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class ScheduledOrder extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

ScheduledOrder.attributes = attributes = {
  userId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Users', key: 'id' }
  },
  orderId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Orders', key: 'id' }
  },
  scheduledDate: {
    type: DataTypes.DATE,
    allowNull: false
  },
  status: {
    type: DataTypes.ENUM('pending', 'processed', 'cancelled'),
    allowNull: false,
    defaultValue: 'pending'
  },
  recurrence: {
    type: DataTypes.JSON,
    allowNull: true
  },
  notes: {
    type: DataTypes.TEXT,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  ScheduledOrder.init(ScheduledOrder.attributes, {
    sequelize,
    modelName: 'ScheduledOrder',
    tableName: 'scheduledorders', // Adjust this if needed
  });
  return ScheduledOrder
};

================
File: src/models/ServiceFee.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class ServiceFee extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

ServiceFee.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  type: {
    type: DataTypes.ENUM('fixed', 'percentage'),
    allowNull: false
  },
  value: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  applicableOrderTypes: {
    type: DataTypes.JSON,
    allowNull: true
  },
  startDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  endDate: {
    type: DataTypes.DATE,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  ServiceFee.init(ServiceFee.attributes, {
    sequelize,
    modelName: 'ServiceFee',
    tableName: 'servicefees', // Adjust this if needed
  });
  return ServiceFee
};

================
File: src/models/SizeModifier.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class SizeModifier extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

SizeModifier.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  }
};

module.exports = (sequelize) => {
  SizeModifier.init(SizeModifier.attributes, {
    sequelize,
    modelName: 'SizeModifier',
    tableName: 'sizemodifiers', // Adjust this if needed
  });
  return SizeModifier
};

================
File: src/models/Staff.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Staff extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

Staff.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  userId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Users', key: 'id' }
  },
  employeeId: {
    type: DataTypes.STRING,
    allowNull: true,
    unique: true
  },
  position: {
    type: DataTypes.STRING,
    allowNull: false
  },
  hireDate: {
    type: DataTypes.DATEONLY,
    allowNull: false
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  hourlyRate: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: true
  },
  notes: {
    type: DataTypes.TEXT,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  Staff.init(Staff.attributes, {
    sequelize,
    modelName: 'Staff',
    tableName: 'staffs', // Adjust this if needed
  });
  return Staff
};

================
File: src/models/StaffRole.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class StaffRole extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

StaffRole.attributes = attributes = {
  staffId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Staff', key: 'id' }
  },
  roleId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Roles', key: 'id' }
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  startDate: {
    type: DataTypes.DATEONLY,
    allowNull: false
  },
  endDate: {
    type: DataTypes.DATEONLY,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  StaffRole.init(StaffRole.attributes, {
    sequelize,
    modelName: 'StaffRole',
    tableName: 'staffroles', // Adjust this if needed
  });
  return StaffRole
};

================
File: src/models/StaffSchedule.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class StaffSchedule extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

StaffSchedule.attributes = attributes = {
  staffId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Staff', key: 'id' }
  },
  locationId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Locations', key: 'id' }
  },
  dayOfWeek: {
    type: DataTypes.INTEGER,
    allowNull: false,
    validate: {
      min: 0,
      max: 6
    }
  },
  startTime: {
    type: DataTypes.TIME,
    allowNull: false
  },
  endTime: {
    type: DataTypes.TIME,
    allowNull: false
  },
  isRecurring: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  date: {
    type: DataTypes.DATEONLY,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  StaffSchedule.init(StaffSchedule.attributes, {
    sequelize,
    modelName: 'StaffSchedule',
    tableName: 'staffschedules', // Adjust this if needed
  });
  return StaffSchedule
};

================
File: src/models/Subscription.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Subscription extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

Subscription.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  subscriptionPlanId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'SubscriptionPlans', key: 'id' }
  },
  startDate: {
    type: DataTypes.DATE,
    allowNull: false
  },
  endDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  status: {
    type: DataTypes.ENUM('active', 'cancelled', 'expired', 'suspended'),
    allowNull: false,
    defaultValue: 'active'
  },
  cancelledAt: {
    type: DataTypes.DATE,
    allowNull: true
  },
  cancelReason: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  currentPeriodStart: {
    type: DataTypes.DATE,
    allowNull: false
  },
  currentPeriodEnd: {
    type: DataTypes.DATE,
    allowNull: false
  },
  lastBillingDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  nextBillingDate: {
    type: DataTypes.DATE,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  Subscription.init(Subscription.attributes, {
    sequelize,
    modelName: 'Subscription',
    tableName: 'subscriptions', // Adjust this if needed
  });
  return Subscription
};

================
File: src/models/SubscriptionPlan.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class SubscriptionPlan extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

SubscriptionPlan.attributes = attributes = {
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  price: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false
  },
  billingCycle: {
    type: DataTypes.ENUM('monthly', 'quarterly', 'yearly'),
    allowNull: false
  },
  features: {
    type: DataTypes.JSON,
    allowNull: true
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  trialPeriodDays: {
    type: DataTypes.INTEGER,
    allowNull: true
  },
  maxLocations: {
    type: DataTypes.INTEGER,
    allowNull: true
  },
  maxUsers: {
    type: DataTypes.INTEGER,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  SubscriptionPlan.init(SubscriptionPlan.attributes, {
    sequelize,
    modelName: 'SubscriptionPlan',
    tableName: 'subscriptionplans', // Adjust this if needed
  });
  return SubscriptionPlan
};

================
File: src/models/Tag.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Tag extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

Tag.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  type: {
    type: DataTypes.ENUM('dietary', 'allergen', 'cuisine', 'custom'),
    allowNull: false
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  }
};

module.exports = (sequelize) => {
  Tag.init(Tag.attributes, {
    sequelize,
    modelName: 'Tag',
    tableName: 'tags', // Adjust this if needed
  });
  return Tag
};

================
File: src/models/Tax.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Tax extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

Tax.attributes = attributes = {
  clientId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Clients', key: 'id' }
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  type: {
    type: DataTypes.ENUM('sales', 'vat', 'service', 'other'),
    allowNull: false
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  }
};

module.exports = (sequelize) => {
  Tax.init(Tax.attributes, {
    sequelize,
    modelName: 'Tax',
    tableName: 'taxs', // Adjust this if needed
  });
  return Tax
};

================
File: src/models/TaxRate.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class TaxRate extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

TaxRate.attributes = attributes = {
  taxId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Taxes', key: 'id' }
  },
  locationId: {
    type: DataTypes.INTEGER,
    allowNull: true,
    references: { model: 'Locations', key: 'id' }
  },
  rate: {
    type: DataTypes.DECIMAL(5, 2),
    allowNull: false
  },
  startDate: {
    type: DataTypes.DATE,
    allowNull: false
  },
  endDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  }
};

module.exports = (sequelize) => {
  TaxRate.init(TaxRate.attributes, {
    sequelize,
    modelName: 'TaxRate',
    tableName: 'taxrates', // Adjust this if needed
  });
  return TaxRate
};

================
File: src/models/Tenant.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Tenant extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

Tenant.attributes = attributes = {
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  subdomain: {
    type: DataTypes.STRING,
    allowNull: false,
    unique: true
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  settings: {
    type: DataTypes.JSON,
    allowNull: true
  },
  plan: {
    type: DataTypes.STRING,
    allowNull: false
  },
  billingEmail: {
    type: DataTypes.STRING,
    allowNull: false,
    validate: {
      isEmail: true
    }
  },
  technicalContactEmail: {
    type: DataTypes.STRING,
    allowNull: true,
    validate: {
      isEmail: true
    }
  }
};

module.exports = (sequelize) => {
  Tenant.init(Tenant.attributes, {
    sequelize,
    modelName: 'Tenant',
    tableName: 'tenants', // Adjust this if needed
  });
  return Tenant
};

================
File: src/models/TimeSlot.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class TimeSlot extends BaseModel {
  static associate(models) {
    // Add associations here if needed
    // For example:
  }
}

TimeSlot.attributes = attributes = {
  startTime: {
    type: DataTypes.TIME,
    allowNull: false
  },
  endTime: {
    type: DataTypes.TIME,
    allowNull: false
  },
  dayOfWeek: {
    type: DataTypes.INTEGER,
    allowNull: false,
    validate: {
      min: 0,
      max: 6
    }
  },
  isAvailable: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: true
  },
  capacity: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 1
  }
};

module.exports = (sequelize) => {
  TimeSlot.init(TimeSlot.attributes, {
    sequelize,
    modelName: 'TimeSlot',
    tableName: 'timeslots', // Adjust this if needed
  });
  return TimeSlot
};

================
File: src/models/Tip.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Tip extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

Tip.attributes = {
  // Define attributes here
};

module.exports = (sequelize) => {
  Tip.init(Tip.attributes, {
    sequelize,
    modelName: 'Tip',
    tableName: 'tips', // Adjust this if needed
  });
  return Tip
};

================
File: src/models/TipConfiguration.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class TipConfiguration extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

TipConfiguration.attributes = {
  // Define attributes here
};

module.exports = (sequelize) => {
  TipConfiguration.init(TipConfiguration.attributes, {
    sequelize,
    modelName: 'TipConfiguration',
    tableName: 'tipconfigurations', // Adjust this if needed
  });
  return TipConfiguration
};

================
File: src/models/TrackingPixel.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class TrackingPixel extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

TrackingPixel.attributes = {
  // Define attributes here
};

module.exports = (sequelize) => {
  TrackingPixel.init(TrackingPixel.attributes, {
    sequelize,
    modelName: 'TrackingPixel',
    tableName: 'trackingpixels', // Adjust this if needed
  });
  return TrackingPixel
};

================
File: src/models/Transaction.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Transaction extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

Transaction.attributes = {
  // Define attributes here
};

module.exports = (sequelize) => {
  Transaction.init(Transaction.attributes, {
    sequelize,
    modelName: 'Transaction',
    tableName: 'transactions', // Adjust this if needed
  });
  return Transaction
};

================
File: src/models/User.js
================
const { DataTypes } = require('sequelize');
const sequelize = require('../db');

const User = sequelize.define('User', {
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true,
  },
  email: {
    type: DataTypes.STRING,
    allowNull: false,
    unique: true,
    validate: {
      isEmail: true,
    },
  },
  password: {
    type: DataTypes.STRING,
    allowNull: false,
  },
  role: {
    type: DataTypes.ENUM('GUEST', 'CLIENT_ADMIN', 'GLOBAL_ADMIN', 'EMPLOYEE'),
    allowNull: false,
    defaultValue: 'GUEST',
  },
  clientId: {
    type: DataTypes.UUID,
    allowNull: true,
  },
});

module.exports = User;

================
File: src/models/UserRole.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class UserRole extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

UserRole.attributes = {
  // Define attributes here
};

module.exports = (sequelize) => {
  UserRole.init(UserRole.attributes, {
    sequelize,
    modelName: 'UserRole',
    tableName: 'userroles', // Adjust this if needed
  });
  return UserRole
};

================
File: src/models/Wallet.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class Wallet extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

Wallet.attributes = {
  // Define attributes here
};

module.exports = (sequelize) => {
  Wallet.init(Wallet.attributes, {
    sequelize,
    modelName: 'Wallet',
    tableName: 'wallets', // Adjust this if needed
  });
  return Wallet
};

================
File: src/models/WalletDrop.js
================
const { DataTypes } = require('sequelize');
const BaseModel = require('./BaseModel');

class WalletDrop extends BaseModel {
  static associate(models) {
    // Define associations here
  }
}

WalletDrop.attributes = attributes = {
  userId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Users', key: 'id' }
  },
  walletId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: { model: 'Wallets', key: 'id' }
  },
  amount: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false
  },
  status: {
    type: DataTypes.ENUM('pending', 'completed', 'failed'),
    allowNull: false,
    defaultValue: 'pending'
  },
  dropDate: {
    type: DataTypes.DATE,
    allowNull: false
  },
  expirationDate: {
    type: DataTypes.DATE,
    allowNull: true
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  }
};

module.exports = (sequelize) => {
  WalletDrop.init(WalletDrop.attributes, {
    sequelize,
    modelName: 'WalletDrop',
    tableName: 'walletdrops', // Adjust this if needed
  });
  return WalletDrop
};

================
File: src/posConnector/posConfigs.js
================
const posConfigs = {
  brink: {
    format: 'XML',
    apiEndpoint: 'https://api.brinkpos.net/orders',
    inventoryEndpoint: 'https://api.brinkpos.net/inventory',
    contentType: 'application/xml',
  },
  toast: {
    format: 'JSON',
    apiEndpoint: 'https://api.toasttab.com/orders',
    inventoryEndpoint: 'https://api.toasttab.com/inventory',
    contentType: 'application/json',
  },
  revel: {
    format: 'JSON',
    apiEndpoint: 'https://api.revelsystems.com/orders',
    inventoryEndpoint: 'https://api.revelsystems.com/inventory',
    contentType: 'application/json',
  },
  square: {
    format: 'JSON',
    apiEndpoint: 'https://connect.squareup.com/v2/orders',
    inventoryEndpoint: 'https://connect.squareup.com/v2/inventory',
    contentType: 'application/json',
  },
};

module.exports = posConfigs;

================
File: src/posConnector/posConnector.js
================
const axios = require('axios');
const posConfigs = require('./posConfigs');
const logger = require('../services/logger');

class POSConnectorService {
  constructor(posConfig) {
    this.posConfig = posConfig;
    this.defaultConfig = posConfigs[posConfig.provider] || {};
  }

  syncMenus(menuData) {
    if (this.posConfig.format === 'JSON') {
      return this.syncToJSONPOS(menuData);
    } else if (this.posConfig.format === 'XML') {
      return this.syncToXMLPOS(menuData);
    }
  }

  syncToJSONPOS(menuData) {
    return {
      menuName: menuData.name,
      items: menuData.menuItems.map(item => ({
        itemName: item.name,
        price: item.basePrice,
        pointsPrice: item.pointsPrice || null,
        modifiers: item.modifiers,
      })),
    };
  }

  syncToXMLPOS(menuData) {
    return `<Menu><Name>${menuData.name}</Name></Menu>`;
  }

  async sendOrderToPOS(orderData) {
    try {
      const endpoint = this.posConfig.apiEndpoint || this.defaultConfig.apiEndpoint;
      const response = await axios.post(endpoint, orderData, {
        headers: { 'Content-Type': this.posConfig.contentType || this.defaultConfig.contentType },
      });
      logger.info(`Order sent successfully to POS: ${this.posConfig.name}`);
      return response.data;
    } catch (error) {
      logger.error(`Error sending order to POS ${this.posConfig.name}: ${error.message}`);
      throw error;
    }
  }

  async syncInventory(inventoryData) {
    try {
      const endpoint = this.posConfig.inventoryEndpoint || this.defaultConfig.inventoryEndpoint;
      const response = await axios.post(endpoint, inventoryData, {
        headers: { 'Content-Type': this.posConfig.contentType || this.defaultConfig.contentType },
      });
      logger.info(`Inventory synced successfully with POS: ${this.posConfig.name}`);
      return response.data;
    } catch (error) {
      logger.error(`Error syncing inventory with POS ${this.posConfig.name}: ${error.message}`);
      throw error;
    }
  }
}

module.exports = POSConnectorService;

================
File: src/posConnector/posConnectorService.js
================
const axios = require('axios');
const TaxService = require('../services/taxService');
const logger = require('../services/logger');

class POSConnectorService {
  constructor(posConfig) {
    this.posConfig = posConfig;
  }

  async syncMenus(menuData) {
    try {
      const formattedData = this.posConfig.format === 'JSON' 
        ? this.syncToJSONPOS(menuData) 
        : this.syncToXMLPOS(menuData);

      const response = await this.makeRequest('post', this.posConfig.apiEndpoint, formattedData);
      logger.info(`Menu synced successfully with POS: ${this.posConfig.name}`);
      return response.data;
    } catch (error) {
      this.handleError('syncing menu', error);
    }
  }

  syncToJSONPOS(menuData) {
    return {
      menuName: menuData.name,
      items: menuData.menuItems.map(item => ({
        itemName: item.name,
        price: item.basePrice,
        pointsPrice: item.pointsPrice || null,
        modifiers: item.modifiers,
      })),
    };
  }

  syncToXMLPOS(menuData) {
    return `<Menu><Name>${menuData.name}</Name></Menu>`;
  }

  async sendOrderToPOS(orderData) {
    try {
      const response = await this.makeRequest('post', this.posConfig.apiEndpoint, orderData);
      logger.info(`Order sent successfully to POS: ${this.posConfig.name}`);
      return response.data;
    } catch (error) {
      this.handleError('sending order', error);
    }
  }

  async syncInventory(inventoryData) {
    try {
      const response = await this.makeRequest('post', this.posConfig.inventoryEndpoint, inventoryData);
      logger.info(`Inventory synced successfully with POS: ${this.posConfig.name}`);
      return response.data;
    } catch (error) {
      this.handleError('syncing inventory', error);
    }
  }

  async syncTaxRates(locationId, provider) {
    try {
      const taxDetails = await TaxService.getApplicableTax(locationId, provider);
      const response = await this.makeRequest('post', this.posConfig.taxEndpoint, taxDetails);
      logger.info(`Tax rates synced successfully with POS: ${this.posConfig.name}`);
      return response.data;
    } catch (error) {
      this.handleError('syncing tax rates', error);
    }
  }

  async makeRequest(method, url, data) {
    return axios({
      method,
      url,
      data,
      headers: { 'Content-Type': this.posConfig.contentType },
    });
  }

  handleError(operation, error) {
    logger.error(`Error ${operation} with POS ${this.posConfig.name}: ${error.message}`);
    throw error;
  }
}

module.exports = POSConnectorService;

================
File: src/posConnector/posProfiles.js
================
const posConfigs = require('./posConfigs');

const posProfiles = {
  location1: {
    posSystem: 'brink',
    locationId: 1,
    posConfig: posConfigs.brink,
  },
  location2: {
    posSystem: 'toast',
    locationId: 2,
    posConfig: posConfigs.toast,
  },
  location3: {
    posSystem: 'revel',
    locationId: 3,
    posConfig: posConfigs.revel,
  },
  location4: {
    posSystem: 'square',
    locationId: 4,
    posConfig: posConfigs.square,
  },
  // Add more locations as needed
};

module.exports = posProfiles;

================
File: src/routes/abTestResultRoutes.js
================
const express = require('express');
const router = express.Router();
const abTestResultController = require('../controllers/abTestResultController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles(1, 2), abTestResultController.getAllABTestResults);
router.post('/', authorizeRoles(1, 2), abTestResultController.createABTestResult);
router.get('/:id', authorizeRoles(1, 2), abTestResultController.getABTestResult);
router.put('/:id', authorizeRoles(1, 2), abTestResultController.updateABTestResult);
router.delete('/:id', authorizeRoles(1, 2), abTestResultController.deleteABTestResult);

module.exports = router;

================
File: src/routes/abTestRoutes.js
================
const express = require('express');
const { body } = require('express-validator');
const ABTestController = require('../controllers/abTestController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');

const router = express.Router();

router.use(authenticate);

router.post('/', 
  authorize(['admin']),
  [
    body('name').notEmpty().withMessage('Name is required'),
    // Add other validation rules as needed
  ],
  ABTestController.createABTest
);

router.get('/:id', authorize(['admin']), ABTestController.getABTest);
router.put('/:id', authorize(['admin']), ABTestController.updateABTest);
router.delete('/:id', authorize(['admin']), ABTestController.deleteABTest);
router.get('/:id/results', authorize(['admin']), ABTestController.getABTestResults);
router.post('/:id/start', authorize(['admin']), ABTestController.startABTest);
router.post('/:id/stop', authorize(['admin']), ABTestController.stopABTest);

module.exports = router;

================
File: src/routes/adminRoutes.js
================
const express = require('express');
const adminController = require('../controllers/adminController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');
const { body } = require('express-validator');

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticate);

// Apply authorization middleware to all routes
router.use(authorize(['clientAdmin', 'superAdmin']));

// Dashboard data
router.get('/dashboard', adminController.getDashboardData);

// User management
router.get('/users', adminController.getUsers);
router.post('/users', [
  body('username').isString().notEmpty(),
  body('email').isEmail(),
  body('password').isLength({ min: 6 }),
  body('role').isIn(['user', 'admin', 'clientAdmin', 'superAdmin'])
], adminController.createUser);
router.put('/users/:id', [
  body('username').optional().isString(),
  body('email').optional().isEmail(),
  body('password').optional().isLength({ min: 6 }),
  body('role').optional().isIn(['user', 'admin', 'clientAdmin', 'superAdmin'])
], adminController.updateUser);
router.delete('/users/:id', adminController.deleteUser);

// System logs
router.get('/logs', adminController.getSystemLogs);

// System health
router.get('/health', adminController.getSystemHealth);

// Database operations
router.post('/backup', adminController.backupDatabase);
router.post('/restore', [
  body('backupId').isString().notEmpty()
], adminController.restoreDatabase);

module.exports = router;

================
File: src/routes/analytics.js
================
const express = require 'express';
const { getOrderAnalytics, getGuestAnalytics } = require '../controllers/analyticsController';

const router = express.Router();

router.get('/orders', getOrderAnalytics);
router.get('/guests', getGuestAnalytics);

module.exports = router;

================
File: src/routes/analyticsRoutes.js
================
const express = require('express');
const analyticsController = require('../controllers/analyticsController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');

const router = express.Router();

// Use authenticate middleware for all routes
router.use(authenticate);

// Define routes
router.get('/order', authorize(['Admin']), analyticsController.getOrderAnalytics);
router.get('/guest', authorize(['Admin']), analyticsController.getGuestAnalytics);
router.get('/revenue', authorize(['Admin']), analyticsController.getRevenue);
router.get('/customers', authorize(['Admin']), analyticsController.getCustomers);
router.get('/realtime', authorize(['Admin']), analyticsController.getRealtimeMetricsController);

module.exports = router;

================
File: src/routes/assetRoutes.js
================
const express = require('express');
const path = require('path');
const multer = require('multer');
const AssetController = require('../controllers/assetController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');

const router = express.Router();

const upload = multer({ storage: multer.memoryStorage() });

router.use('/uploads', express.static(path.join(__dirname, '..', '..', 'uploads')));

router.use(authenticate);

router.get('/', authorize(['admin', 'manager']), AssetController.getAllAssets);
router.get('/:id', authorize(['admin', 'manager']), AssetController.getAsset);
router.post('/upload', authorize(['admin', 'manager']), upload.single('file'), AssetController.uploadAsset);
router.put('/:id', authorize(['admin', 'manager']), AssetController.updateAsset);
router.delete('/:id', authorize(['admin']), AssetController.deleteAsset);

module.exports = router;

================
File: src/routes/auth.js
================
const express = require 'express';
const { login, logout, refreshToken } = require '../controllers/authController';
const { authenticate } = require '../middleware/auth';

const router = express.Router();

router.post('/login', login);
router.post('/logout', authenticate, logout);
router.post('/refresh-token', refreshToken);

module.exports = router;

================
File: src/routes/authRoutes.js
================
const express = require('express');
const authController = require('../controllers/authController');

const router = express.Router();

router.post('/login', authController.login);
router.post('/register', authController.register);
router.post('/logout', authController.logout);
router.get('/user', authController.getUser);

module.exports = router;

================
File: src/routes/brandingProfileRoutes.js
================
const express = require('express');
const router = express.Router();
const brandingProfileController = require('../controllers/brandingProfileController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles(1, 2), brandingProfileController.getBrandingProfile);
router.post('/', authorizeRoles(1, 2), brandingProfileController.createBrandingProfile);
router.put('/', authorizeRoles(1, 2), brandingProfileController.updateBrandingProfile);
router.delete('/', authorizeRoles(1, 2), brandingProfileController.deleteBrandingProfile);

module.exports = router;

================
File: src/routes/brandingRoutes.js
================
const express = require('express');
const brandingController = require('../controllers/brandingController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');

const router = express.Router();

router.get('/client/:clientId', authenticate, authorize(['Super Admin', 'Admin']), brandingController.getBrandingProfiles);
router.get('/:id', authenticate, authorize(['Super Admin', 'Admin']), brandingController.getBrandingProfileById);
router.post('/', authenticate, authorize(['Super Admin', 'Admin']), brandingController.createBrandingProfile);
router.put('/:id', authenticate, authorize(['Super Admin', 'Admin']), brandingController.updateBrandingProfile);
router.delete('/:id', authenticate, authorize(['Super Admin']), brandingController.deleteBrandingProfile);

module.exports = router;

================
File: src/routes/campaignResultRoutes.js
================
const express = require('express');
const campaignResultController = require('../controllers/campaignResultController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticate);

// Apply authorization middleware to all routes
router.use(authorize(['admin', 'manager']));

// Get all campaign results
router.get('/', campaignResultController.getAllCampaignResults);

// Get a specific campaign result
router.get('/:id', campaignResultController.getCampaignResultById);

// Create a new campaign result
router.post('/', campaignResultController.createCampaignResult);

// Update a campaign result
router.put('/:id', campaignResultController.updateCampaignResult);

// Delete a campaign result
router.delete('/:id', campaignResultController.deleteCampaignResult);

module.exports = router;

================
File: src/routes/campaignStepRoutes.js
================
const express = require('express');
const router = express.Router();
const campaignStepController = require('../controllers/campaignStepController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles(1, 2), campaignStepController.getAllCampaignSteps);
router.post('/', authorizeRoles(1, 2), campaignStepController.createCampaignStep);
router.get('/:id', authorizeRoles(1, 2), campaignStepController.getCampaignStep);
router.put('/:id', authorizeRoles(1, 2), campaignStepController.updateCampaignStep);
router.delete('/:id', authorizeRoles(1, 2), campaignStepController.deleteCampaignStep);

module.exports = router;

================
File: src/routes/categoryRoutes.js
================
const express = require('express');
const categoryController = require('../controllers/categoryController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticate);

// Get all categories
router.get('/', authorize(['admin', 'manager']), categoryController.getAllCategories);

// Get a specific category
router.get('/:id', authorize(['admin', 'manager']), categoryController.getCategoryById);

// Create a new category
router.post('/', authorize(['admin']), categoryController.createCategory);

// Update a category
router.put('/:id', authorize(['admin']), categoryController.updateCategory);

// Delete a category
router.delete('/:id', authorize(['admin']), categoryController.deleteCategory);

module.exports = router;

================
File: src/routes/cateringAdminRoutes.js
================
const express = require('express');
const router = express.Router();
const cateringAdminController = require('../controllers/cateringAdminController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles(1, 2), cateringAdminController.getAllCateringAdmins);
router.post('/', authorizeRoles(1, 2), cateringAdminController.createCateringAdmin);
router.get('/:id', authorizeRoles(1, 2), cateringAdminController.getCateringAdmin);
router.put('/:id', authorizeRoles(1, 2), cateringAdminController.updateCateringAdmin);
router.delete('/:id', authorizeRoles(1, 2), cateringAdminController.deleteCateringAdmin);

module.exports = router;

================
File: src/routes/cateringMenuItemRoutes.js
================
const express = require('express');
const router = express.Router();
const cateringMenuItemController = require('../controllers/cateringMenuItemController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles(1, 2), cateringMenuItemController.getAllCateringMenuItems);
router.post('/', authorizeRoles(1, 2), cateringMenuItemController.createCateringMenuItem);
router.get('/:id', authorizeRoles(1, 2), cateringMenuItemController.getCateringMenuItem);
router.put('/:id', authorizeRoles(1, 2), cateringMenuItemController.updateCateringMenuItem);
router.delete('/:id', authorizeRoles(1, 2), cateringMenuItemController.deleteCateringMenuItem);

module.exports = router;

================
File: src/routes/cateringMenuRoutes.js
================
const express = require('express');
const router = express.Router();
const cateringMenuController = require('../controllers/cateringMenuController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles(1, 2), cateringMenuController.getAllCateringMenus);
router.post('/', authorizeRoles(1, 2), cateringMenuController.createCateringMenu);
router.get('/:id', authorizeRoles(1, 2), cateringMenuController.getCateringMenu);
router.put('/:id', authorizeRoles(1, 2), cateringMenuController.updateCateringMenu);
router.delete('/:id', authorizeRoles(1, 2), cateringMenuController.deleteCateringMenu);

module.exports = router;

================
File: src/routes/cateringOrderAssignmentsRoutes.js
================
const express = require('express');
const router = express.Router();
const cateringOrderAssignmentsController = require('../controllers/cateringOrderAssignmentsController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles(1, 2), cateringOrderAssignmentsController.getAllAssignments);
router.post('/', authorizeRoles(1, 2), cateringOrderAssignmentsController.createAssignment);
router.get('/:id', authorizeRoles(1, 2), cateringOrderAssignmentsController.getAssignment);
router.put('/:id', authorizeRoles(1, 2), cateringOrderAssignmentsController.updateAssignment);
router.delete('/:id', authorizeRoles(1, 2), cateringOrderAssignmentsController.deleteAssignment);

module.exports = router;

================
File: src/routes/cateringOrderCustomizationRoutes.js
================
const express = require('express');
const router = express.Router();
const cateringOrderCustomizationController = require('../controllers/cateringOrderCustomizationController');

// GET all customizations
router.get('/', cateringOrderCustomizationController.getAllCustomizations);

// GET a single customization by ID
router.get('/:id', cateringOrderCustomizationController.getCustomizationById);

// POST a new customization
router.post('/', cateringOrderCustomizationController.createCustomization);

// PUT update an existing customization
router.put('/:id', cateringOrderCustomizationController.updateCustomization);

// DELETE a customization
router.delete('/:id', cateringOrderCustomizationController.deleteCustomization);

module.exports = router;

================
File: src/routes/cateringOrderFeesRoutes.js
================
const express = require('express');
const router = express.Router();
const cateringOrderFeesController = require('../controllers/cateringOrderFeesController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles(1, 2), cateringOrderFeesController.getAllFees);
router.post('/', authorizeRoles(1, 2), cateringOrderFeesController.createFee);
router.get('/:id', authorizeRoles(1, 2), cateringOrderFeesController.getFee);
router.put('/:id', authorizeRoles(1, 2), cateringOrderFeesController.updateFee);
router.delete('/:id', authorizeRoles(1, 2), cateringOrderFeesController.deleteFee);

module.exports = router;

================
File: src/routes/cateringOrderItemRoutes.js
================
const express = require('express');
const router = express.Router();
const cateringOrderItemController = require('../controllers/cateringOrderItemController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles(1, 2), cateringOrderItemController.getAllItems);
router.post('/', authorizeRoles(1, 2), cateringOrderItemController.createItem);
router.get('/:id', authorizeRoles(1, 2), cateringOrderItemController.getItem);
router.put('/:id', authorizeRoles(1, 2), cateringOrderItemController.updateItem);
router.delete('/:id', authorizeRoles(1, 2), cateringOrderItemController.deleteItem);

module.exports = router;

================
File: src/routes/cateringOrderLocationRoutes.js
================
const express = require('express');
const router = express.Router();
const cateringOrderLocationController = require('../controllers/cateringOrderLocationController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles(1, 2), cateringOrderLocationController.getAllLocations);
router.post('/', authorizeRoles(1, 2), cateringOrderLocationController.createLocation);
router.get('/:id', authorizeRoles(1, 2), cateringOrderLocationController.getLocation);
router.put('/:id', authorizeRoles(1, 2), cateringOrderLocationController.updateLocation);
router.delete('/:id', authorizeRoles(1, 2), cateringOrderLocationController.deleteLocation);

module.exports = router;

================
File: src/routes/cateringOrderModifierRoutes.js
================
const express = require('express');
const router = express.Router();
const cateringOrderModifierController = require('../controllers/cateringOrderModifierController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles(1, 2), cateringOrderModifierController.getAllModifiers);
router.post('/', authorizeRoles(1, 2), cateringOrderModifierController.createModifier);
router.get('/:id', authorizeRoles(1, 2), cateringOrderModifierController.getModifier);
router.put('/:id', authorizeRoles(1, 2), cateringOrderModifierController.updateModifier);
router.delete('/:id', authorizeRoles(1, 2), cateringOrderModifierController.deleteModifier);

module.exports = router;

================
File: src/routes/cateringOrderRoutes.js
================
const express = require('express');
const router = express.Router();
const { authenticateToken } = require('../middleware/auth');
const CateringOrder = require('../models/CateringOrder');
const cateringOrderController = require('../controllers/cateringOrderController');

// Get all catering orders for a guest
router.get('/guest/:guestId', authenticateToken, async (req, res) => {
  try {
    const orders = await CateringOrder.findAll({ where: { guestId: req.params.guestId } });
    res.json(orders);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching catering orders', error });
  }
});

// Create a new catering order
router.post('/', authenticateToken, async (req, res) => {
  try {
    const { orderNumber, guestId, houseAccountId, orderDate, totalPrice, orderDetails } = req.body;
    const cateringOrder = await CateringOrder.create({ orderNumber, guestId, houseAccountId, orderDate, totalPrice, orderDetails });
    res.status(201).json(cateringOrder);
  } catch (error) {
    res.status(500).json({ message: 'Error creating catering order', error });
  }
});

// New routes for clients
router.get('/clients/:clientId/catering-orders', cateringOrderController.getOrders);
router.patch('/clients/:clientId/catering-orders/:orderId', cateringOrderController.updateOrderStatus);
router.delete('/clients/:clientId/catering-orders/:orderId', cateringOrderController.deleteOrder);

// Add more routes as needed

module.exports = router;

================
File: src/routes/cateringRoutes.js
================
const express = require('express');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');
const cateringController = require('../controllers/cateringController');

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticate);

// Get catering menu for a specific location
router.get('/location/:locationId', authorize(['admin', 'manager']), cateringController.getCateringMenu);

// Create a new catering order
router.post('/order', authorize(['admin', 'manager', 'user']), cateringController.createCateringOrder);

// Get catering order details
router.get('/order/:orderId', authorize(['admin', 'manager', 'user']), cateringController.getCateringOrderDetails);

// Update catering order status
router.put('/order/:orderId/status', authorize(['admin', 'manager']), cateringController.updateCateringOrderStatus);

// Get all catering orders for a client
router.get('/orders', authorize(['admin', 'manager']), cateringController.getAllCateringOrders);

// Create or update catering menu item
router.post('/menu-item', authorize(['admin']), cateringController.upsertCateringMenuItem);

// Delete catering menu item
router.delete('/menu-item/:itemId', authorize(['admin']), cateringController.deleteCateringMenuItem);

module.exports = router;

================
File: src/routes/cateringSettingsRoutes.js
================
const express = require('express');
const router = express.Router();
const cateringSettingsController = require('../controllers/cateringSettingsController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles(1, 2), cateringSettingsController.getSettings);
router.put('/', authorizeRoles(1, 2), cateringSettingsController.updateSettings);

module.exports = router;

================
File: src/routes/checkoutRoutes.js
================
const express = require('express');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');
const checkoutController = require('../controllers/checkoutController');

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticate);

// Initialize checkout process
router.post('/initialize', authorize(['user', 'admin']), checkoutController.initializeCheckout);

// Process payment
router.post('/process-payment', authorize(['user', 'admin']), checkoutController.processPayment);

// Confirm order
router.post('/confirm-order', authorize(['user', 'admin']), checkoutController.confirmOrder);

// Get checkout status
router.get('/status/:checkoutId', authorize(['user', 'admin']), checkoutController.getCheckoutStatus);

// Apply coupon
router.post('/apply-coupon', authorize(['user', 'admin']), checkoutController.applyCoupon);

// Remove coupon
router.post('/remove-coupon', authorize(['user', 'admin']), checkoutController.removeCoupon);

// Update shipping address
router.put('/shipping-address', authorize(['user', 'admin']), checkoutController.updateShippingAddress);

// Get available payment methods
router.get('/payment-methods', authorize(['user', 'admin']), checkoutController.getPaymentMethods);

module.exports = router;

================
File: src/routes/clientLocationsRoutes.js
================
const express = require('express');
const router = express.Router();
const clientLocationsController = require('../controllers/clientLocationsController');

router.get('/:clientId', clientLocationsController.getClientLocations);

module.exports = router;

================
File: src/routes/clientRoutes.js
================
const express = require('express');
const clientController = require('../controllers/clientController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');
const { body } = require('express-validator');

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticate);

// Get all clients (Super Admin only)
router.get('/', authorize(['superAdmin']), clientController.getAllClients);

// Get a specific client
router.get('/:id', authorize(['superAdmin', 'clientAdmin']), clientController.getClientById);

// Create a new client (Super Admin only)
router.post('/', 
  authorize(['superAdmin']),
  [
    body('name').notEmpty().withMessage('Client name is required'),
    body('email').isEmail().withMessage('Valid email is required'),
    // Add other validation as needed
  ],
  clientController.createClient
);

// Update a client
router.put('/:id', 
  authorize(['superAdmin', 'clientAdmin']),
  [
    body('name').optional().notEmpty().withMessage('Client name cannot be empty'),
    body('email').optional().isEmail().withMessage('Valid email is required'),
    // Add other validation as needed
  ],
  clientController.updateClient
);

// Delete a client (Super Admin only)
router.delete('/:id', authorize(['superAdmin']), clientController.deleteClient);

// Get client settings
router.get('/:id/settings', authorize(['superAdmin', 'clientAdmin']), clientController.getClientSettings);

// Update client settings
router.put('/:id/settings', 
  authorize(['superAdmin', 'clientAdmin']),
  [
    // Add validation for settings fields
  ],
  clientController.updateClientSettings
);

module.exports = router;

================
File: src/routes/clientSettingsRoutes.js
================
const express = require 'express';
const *  = require '../controllers/clientSettingsController';
const { authenticate, authorize } = require '../middleware/auth';

const router = express.Router();

router.use(authenticate);
router.use(authorize(['clientAdmin']));

router.put('/two-factor', clientSettingsController.updateGlobalTwoFactorSetting);
router.put('/location-two-factor-exception', clientSettingsController.updateLocationTwoFactorException);

router.put('/payment-gateways', clientSettingsController.updateGlobalPaymentGateways);
router.put('/location-payment-gateway-exceptions', clientSettingsController.updateLocationPaymentGatewayExceptions);

module.exports = router;

================
File: src/routes/commissaryKitchenRoutes.js
================
const express = require('express');
const commissaryKitchenController = require('../controllers/commissaryKitchenController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticate);

// Get all commissary kitchens
router.get('/', authorize(['admin', 'manager']), commissaryKitchenController.getAllCommissaryKitchens);

// Get a specific commissary kitchen
router.get('/:id', authorize(['admin', 'manager']), commissaryKitchenController.getCommissaryKitchenById);

// Create a new commissary kitchen
router.post('/', authorize(['admin']), commissaryKitchenController.createCommissaryKitchen);

// Update a commissary kitchen
router.put('/:id', authorize(['admin']), commissaryKitchenController.updateCommissaryKitchen);

// Delete a commissary kitchen
router.delete('/:id', authorize(['admin']), commissaryKitchenController.deleteCommissaryKitchen);

// Get inventory for a commissary kitchen
router.get('/:id/inventory', authorize(['admin', 'manager']), commissaryKitchenController.getCommissaryKitchenInventory);

// Update inventory for a commissary kitchen
router.put('/:id/inventory', authorize(['admin', 'manager']), commissaryKitchenController.updateCommissaryKitchenInventory);

module.exports = router;

================
File: src/routes/commissaryLocationRoutes.js
================
const express = require('express');
const router = express.Router();
const commissaryLocationController = require('../controllers/commissaryLocationController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles(1, 2), commissaryLocationController.getAllCommissaryLocations);
router.get('/:id', authorizeRoles(1, 2), commissaryLocationController.getCommissaryLocationById);
router.post('/', authorizeRoles(1, 2), commissaryLocationController.createCommissaryLocation);
router.put('/:id', authorizeRoles(1, 2), commissaryLocationController.updateCommissaryLocation);
router.delete('/:id', authorizeRoles(1, 2), commissaryLocationController.deleteCommissaryLocation);

module.exports = router;

================
File: src/routes/corePosProfileRoutes.js
================
const express = require('express');
const corePosProfileController = require('../controllers/corePosProfileController');

const router = express.Router();

router.get('/', corePosProfileController.getAll);
router.get('/:id', corePosProfileController.getById);
router.post('/', corePosProfileController.create);
router.put('/:id', corePosProfileController.update);
router.delete('/:id', corePosProfileController.delete);
router.post('/:id/sync', corePosProfileController.syncLocation);

module.exports = router;

================
File: src/routes/dashboardRoutes.js
================
const express = require('express');
const router = express.Router();
const dashboardController = require('../controllers/dashboardController');
const { authenticateUser, authorizeGlobalAdmin } = require('../middleware/auth');

router.get('/data', authenticateUser, dashboardController.getDashboardData);
router.get('/global-data', authenticateUser, authorizeGlobalAdmin, dashboardController.getGlobalDashboardData);

module.exports = router;

================
File: src/routes/dataWallRoutes.js
================
const express = require('express');
const router = express.Router();
const { authenticateToken, authorizeRoles, checkPermission } = require('../middleware/roleMiddleware');
const dataWallController = require('../controllers/dataWallController');

// Routes for managing data walls
router.post('/', authenticateToken, authorizeRoles(['Admin']), checkPermission('manage_data_walls'), dataWallController.createDataWall);
router.get('/:locationId', authenticateToken, authorizeRoles(['Admin', 'Manager']), checkPermission('view_data_walls'), dataWallController.getDataWallsByLocation);

module.exports = router;

================
File: src/routes/deliveryDriverRoutes.js
================
const express = require('express');
const deliveryDriverController = require('../controllers/deliveryDriverController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticate);

// Get all delivery drivers
router.get('/', authorize(['admin', 'manager']), deliveryDriverController.getAllDeliveryDrivers);

// Get a specific delivery driver
router.get('/:id', authorize(['admin', 'manager']), deliveryDriverController.getDeliveryDriverById);

// Create a new delivery driver
router.post('/', authorize(['admin']), deliveryDriverController.createDeliveryDriver);

// Update a delivery driver
router.put('/:id', authorize(['admin']), deliveryDriverController.updateDeliveryDriver);

// Delete a delivery driver
router.delete('/:id', authorize(['admin']), deliveryDriverController.deleteDeliveryDriver);

// Get active deliveries for a driver
router.get('/:id/active-deliveries', authorize(['admin', 'manager', 'driver']), deliveryDriverController.getActiveDeliveries);

// Update delivery status
router.put('/:id/delivery/:deliveryId', authorize(['admin', 'manager', 'driver']), deliveryDriverController.updateDeliveryStatus);

module.exports = router;

================
File: src/routes/discountItemRoutes.js
================
const express = require('express');
const router = express.Router();
const discountItemController = require('../controllers/discountItemController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles(1, 2), discountItemController.getAllDiscountItems);
router.get('/:id', authorizeRoles(1, 2), discountItemController.getDiscountItemById);
router.post('/', authorizeRoles(1, 2), discountItemController.createDiscountItem);
router.put('/:id', authorizeRoles(1, 2), discountItemController.updateDiscountItem);
router.delete('/:id', authorizeRoles(1, 2), discountItemController.deleteDiscountItem);

module.exports = router;

================
File: src/routes/discountRoutes.js
================
const express = require('express');
const discountController = require('../controllers/discountController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticate);

// Get all discounts
router.get('/', authorize(['admin', 'manager']), discountController.getAllDiscounts);

// Get a specific discount
router.get('/:id', authorize(['admin', 'manager']), discountController.getDiscountById);

// Create a new discount
router.post('/', authorize(['admin']), discountController.createDiscount);

// Update a discount
router.put('/:id', authorize(['admin']), discountController.updateDiscount);

// Delete a discount
router.delete('/:id', authorize(['admin']), discountController.deleteDiscount);

module.exports = router;

================
File: src/routes/discountsRoutes.js
================
const express = require('express');
const router = express.Router();
const { authenticateToken, authorizeRoles } = require('../middleware/auth');
const discountController = require('../controllers/discountController');

// Create a discount (Admin or higher)
router.post('/', authenticateToken, authorizeRoles(1, 2), discountController.createDiscount);

// Get all discounts for a specific location
router.get('/:locationId', authenticateToken, discountController.getDiscountsByLocation);

module.exports = router;

================
File: src/routes/driverLocationsRoutes.js
================
const express = require('express');
const router = express.Router();
const driverLocationsController = require('../controllers/driverLocationsController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles(1, 2), driverLocationsController.getAllDriverLocations);
router.get('/:id', authorizeRoles(1, 2), driverLocationsController.getDriverLocationById);
router.post('/', authorizeRoles(1, 2), driverLocationsController.createDriverLocation);
router.put('/:id', authorizeRoles(1, 2), driverLocationsController.updateDriverLocation);
router.delete('/:id', authorizeRoles(1, 2), driverLocationsController.deleteDriverLocation);

module.exports = router;

================
File: src/routes/dropoffScheduleRoutes.js
================
const express = require('express');
const router = express.Router();
const dropoffScheduleController = require('../controllers/dropoffScheduleController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles(1, 2), dropoffScheduleController.getAllDropoffSchedules);
router.get('/:id', authorizeRoles(1, 2), dropoffScheduleController.getDropoffScheduleById);
router.post('/', authorizeRoles(1, 2), dropoffScheduleController.createDropoffSchedule);
router.put('/:id', authorizeRoles(1, 2), dropoffScheduleController.updateDropoffSchedule);
router.delete('/:id', authorizeRoles(1, 2), dropoffScheduleController.deleteDropoffSchedule);

module.exports = router;

================
File: src/routes/featureManagementRoutes.js
================
const express = require('express');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');
const featureManagementController = require('../controllers/featureManagementController');

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticate);

// Get client features
router.get('/features/:clientId', authorize(['superAdmin']), featureManagementController.getClientFeatures);

// Update client features
router.put('/features/:clientId', authorize(['superAdmin']), featureManagementController.updateClientFeatures);

// Get all available features
router.get('/available-features', authorize(['superAdmin']), featureManagementController.getAllAvailableFeatures);

// Create a new feature
router.post('/features', authorize(['superAdmin']), featureManagementController.createFeature);

// Update an existing feature
router.put('/features/:featureId', authorize(['superAdmin']), featureManagementController.updateFeature);

// Delete a feature
router.delete('/features/:featureId', authorize(['superAdmin']), featureManagementController.deleteFeature);

module.exports = router;

================
File: src/routes/globalMenuRoutes.js
================
const express = require('express');
const router = express.Router();
const globalMenuController = require('../controllers/globalMenuController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles(1, 2), globalMenuController.getAllGlobalMenus);
router.get('/:id', authorizeRoles(1, 2), globalMenuController.getGlobalMenuById);
router.post('/', authorizeRoles(1, 2), globalMenuController.createGlobalMenu);
router.put('/:id', authorizeRoles(1, 2), globalMenuController.updateGlobalMenu);
router.delete('/:id', authorizeRoles(1, 2), globalMenuController.deleteGlobalMenu);

module.exports = router;

================
File: src/routes/globalSettingRoutes.js
================
const express = require('express');
const router = express.Router();
const globalSettingController = require('../controllers/globalSettingController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles(1, 2), globalSettingController.getAllGlobalSettings);
router.get('/:id', authorizeRoles(1, 2), globalSettingController.getGlobalSettingById);
router.post('/', authorizeRoles(1, 2), globalSettingController.createGlobalSetting);
router.put('/:id', authorizeRoles(1, 2), globalSettingController.updateGlobalSetting);
router.delete('/:id', authorizeRoles(1, 2), globalSettingController.deleteGlobalSetting);

module.exports = router;

================
File: src/routes/guestDiscountsRoutes.js
================
const express = require('express');
const router = express.Router();
const guestDiscountsController = require('../controllers/guestDiscountsController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles(1, 2), guestDiscountsController.getAllGuestDiscounts);
router.get('/:id', authorizeRoles(1, 2), guestDiscountsController.getGuestDiscountById);
router.post('/', authorizeRoles(1, 2), guestDiscountsController.createGuestDiscount);
router.put('/:id', authorizeRoles(1, 2), guestDiscountsController.updateGuestDiscount);
router.delete('/:id', authorizeRoles(1, 2), guestDiscountsController.deleteGuestDiscount);

module.exports = router;

================
File: src/routes/guestLoyaltyProgramRoutes.js
================
const express = require('express');
const router = express.Router();
const guestLoyaltyProgramController = require('../controllers/guestLoyaltyProgramController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles(1, 2), guestLoyaltyProgramController.getAllGuestLoyaltyPrograms);
router.get('/:id', authorizeRoles(1, 2), guestLoyaltyProgramController.getGuestLoyaltyProgramById);
router.post('/', authorizeRoles(1, 2), guestLoyaltyProgramController.createGuestLoyaltyProgram);
router.put('/:id', authorizeRoles(1, 2), guestLoyaltyProgramController.updateGuestLoyaltyProgram);
router.delete('/:id', authorizeRoles(1, 2), guestLoyaltyProgramController.deleteGuestLoyaltyProgram);

module.exports = router;

================
File: src/routes/guestProfileRoutes.js
================
const express = require('express');
const router = express.Router();
const guestProfileController = require('../controllers/guestProfileController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles(1, 2), guestProfileController.getAllGuestProfiles);
router.get('/:id', authorizeRoles(1, 2), guestProfileController.getGuestProfileById);
router.post('/', authorizeRoles(1, 2), guestProfileController.createGuestProfile);
router.put('/:id', authorizeRoles(1, 2), guestProfileController.updateGuestProfile);
router.delete('/:id', authorizeRoles(1, 2), guestProfileController.deleteGuestProfile);

module.exports = router;

================
File: src/routes/guestRewardsRoutes.js
================
const express = require('express');
const router = express.Router();
const guestRewardsController = require('../controllers/guestRewardsController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles(1, 2), guestRewardsController.getAllGuestRewards);
router.get('/:id', authorizeRoles(1, 2), guestRewardsController.getGuestRewardById);
router.post('/', authorizeRoles(1, 2), guestRewardsController.createGuestReward);
router.put('/:id', authorizeRoles(1, 2), guestRewardsController.updateGuestReward);
router.delete('/:id', authorizeRoles(1, 2), guestRewardsController.deleteGuestReward);

module.exports = router;

================
File: src/routes/guestRoutes.js
================
const express = require('express');
const guestController = require('../controllers/guestController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticate);

// Get all guests
router.get('/', authorize(['admin', 'manager']), guestController.getAllGuests);

// Get a specific guest
router.get('/:id', authorize(['admin', 'manager']), guestController.getGuestById);

// Create a new guest
router.post('/', authorize(['admin', 'manager']), guestController.createGuest);

// Update a guest
router.put('/:id', authorize(['admin', 'manager']), guestController.updateGuest);

// Delete a guest
router.delete('/:id', authorize(['admin']), guestController.deleteGuest);

module.exports = router;

================
File: src/routes/health.js
================
const express = require('express');
const router = express.Router();

router.get('/', async (req, res) => {
  try {
    // Simple health check without database query
    res.status(200).json({ status: 'healthy' });
  } catch (error) {
    console.error('Health check failed:', error);
    res.status(500).json({ status: 'unhealthy', error: error.message });
  }
});

module.exports = router;

================
File: src/routes/houseAccountLocationsRoutes.js
================
const express = require('express');
const router = express.Router();
const houseAccountLocationsController = require('../controllers/houseAccountLocationsController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles(1, 2), houseAccountLocationsController.getAllHouseAccountLocations);
router.get('/:id', authorizeRoles(1, 2), houseAccountLocationsController.getHouseAccountLocationById);
router.post('/', authorizeRoles(1, 2), houseAccountLocationsController.createHouseAccountLocation);
router.put('/:id', authorizeRoles(1, 2), houseAccountLocationsController.updateHouseAccountLocation);
router.delete('/:id', authorizeRoles(1, 2), houseAccountLocationsController.deleteHouseAccountLocation);

module.exports = router;

================
File: src/routes/houseAccountRoutes.js
================
const express = require('express');
const houseAccountController = require('../controllers/houseAccountController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticate);

// Get house accounts by client
router.get('/client/:clientId', authorize(['admin', 'manager']), houseAccountController.getHouseAccountsByClient);

// Get a specific house account
router.get('/:id', authorize(['admin', 'manager']), houseAccountController.getHouseAccountById);

// Create a new house account
router.post('/', authorize(['admin']), houseAccountController.createHouseAccount);

// Update a house account
router.put('/:id', authorize(['admin']), houseAccountController.updateHouseAccount);

// Delete a house account
router.delete('/:id', authorize(['admin']), houseAccountController.deleteHouseAccount);

// Add funds to a house account
router.post('/:id/add-funds', authorize(['admin', 'manager']), houseAccountController.addFunds);

// Deduct funds from a house account
router.post('/:id/deduct-funds', authorize(['admin', 'manager']), houseAccountController.deductFunds);

// Get transaction history for a house account
router.get('/:id/transactions', authorize(['admin', 'manager']), houseAccountController.getTransactionHistory);

module.exports = router;

================
File: src/routes/houseAccountUserRoutes.js
================
const express = require('express');
const router = express.Router();
const houseAccountUserController = require('../controllers/houseAccountUserController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles(1, 2), houseAccountUserController.getAllHouseAccountUsers);
router.get('/:id', authorizeRoles(1, 2), houseAccountUserController.getHouseAccountUserById);
router.post('/', authorizeRoles(1, 2), houseAccountUserController.createHouseAccountUser);
router.put('/:id', authorizeRoles(1, 2), houseAccountUserController.updateHouseAccountUser);
router.delete('/:id', authorizeRoles(1, 2), houseAccountUserController.deleteHouseAccountUser);

module.exports = router;

================
File: src/routes/imageUploadRoutes.js
================
const express = require('express');
const multer = require('multer');
const path = require('path');
const router = express.Router();

// Configure multer for local storage
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, path.join(__dirname, '../uploads/images/'));
  },
  filename: function (req, file, cb) {
    cb(null, `${Date.now()}-${file.originalname}`);
  },
});

const upload = multer({ storage: storage });

// Image upload route
router.post('/upload', upload.single('image'), (req, res) => {
  try {
    res.json({ message: 'Image uploaded successfully', imagePath: req.file.path });
  } catch (error) {
    res.status(500).json({ message: 'Image upload failed', error });
  }
});

module.exports = router;

================
File: src/routes/index.js
================
const express = require('express');
const { authenticate } = require('../middleware/auth');

// Import all route files
const authRoutes = require('./authRoutes');
const locationRoutes = require('./locationRoutes');
const menuRoutes = require('./menuRoutes');
const orderRoutes = require('./orderRoutes');
const userRoutes = require('./userRoutes');
const analyticsRoutes = require('./analyticsRoutes');
const inventoryRoutes = require('./inventoryRoutes');
const posRoutes = require('./posRoutes');
const abTestRoutes = require('./abTestRoutes');
const adminRoutes = require('./adminRoutes');
const assetRoutes = require('./assetRoutes');
const brandingRoutes = require('./brandingRoutes');
const campaignRoutes = require('./campaignResultRoutes');
const categoryRoutes = require('./categoryRoutes');
const cateringRoutes = require('./cateringRoutes');
const checkoutRoutes = require('./checkoutRoutes');
const clientRoutes = require('./clientRoutes');
const commissaryRoutes = require('./commissaryKitchenRoutes');
const discountRoutes = require('./discountRoutes');
const driverRoutes = require('./deliveryDriverRoutes');
const featureManagementRoutes = require('./featureManagementRoutes');
const guestRoutes = require('./guestRoutes');
const houseAccountRoutes = require('./houseAccountRoutes');
const imageUploadRoutes = require('./imageUploadRoutes');
const invoiceRoutes = require('./invoiceRoutes');
const loyaltyRoutes = require('./loyaltyRoutes');
const paymentRoutes = require('./paymentRoutes');
const providerRoutes = require('./providerRoutes');
const refundRoutes = require('./refundRoutes');
const reportRoutes = require('./reportRoutes');
const reviewRoutes = require('./reviewRoutes');
const roleRoutes = require('./roleRoutes');
const serviceFeeRoutes = require('./serviceFeeRoutes');
const tabletRoutes = require('./tabletRoutes');
const taxRoutes = require('./taxRoutes');
const tipRoutes = require('./tipRoutes');
const trackingPixelRoutes = require('./trackingPixelRoutes');
const translatorRoutes = require('./translatorRoutes');
const twoFactorRoutes = require('./twoFactorRoutes');
const walletRoutes = require('./walletRoutes');
const campaignResultRoutes = require('./campaignResultRoutes');

const router = express.Router();

// Public routes
router.use('/auth', authRoutes);
router.use('/two-factor', twoFactorRoutes);

// Apply authentication middleware to all routes below
router.use(authenticate);

// Protected routes
router.use('/locations', locationRoutes);
router.use('/menu', menuRoutes);
router.use('/orders', orderRoutes);
router.use('/users', userRoutes);
router.use('/analytics', analyticsRoutes);
router.use('/inventory', inventoryRoutes);
router.use('/pos', posRoutes);
router.use('/ab-test', abTestRoutes);
router.use('/admin', adminRoutes);
router.use('/assets', assetRoutes);
router.use('/branding', brandingRoutes);
router.use('/campaigns', campaignRoutes);
router.use('/categories', categoryRoutes);
router.use('/catering', cateringRoutes);
router.use('/checkout', checkoutRoutes);
router.use('/clients', clientRoutes);
router.use('/commissary', commissaryRoutes);
router.use('/discounts', discountRoutes);
router.use('/drivers', driverRoutes);
router.use('/features', featureManagementRoutes);
router.use('/guests', guestRoutes);
router.use('/house-accounts', houseAccountRoutes);
router.use('/images', imageUploadRoutes);
router.use('/invoices', invoiceRoutes);
router.use('/loyalty', loyaltyRoutes);
router.use('/payments', paymentRoutes);
router.use('/providers', providerRoutes);
router.use('/refunds', refundRoutes);
router.use('/reports', reportRoutes);
router.use('/reviews', reviewRoutes);
router.use('/roles', roleRoutes);
router.use('/service-fees', serviceFeeRoutes);
router.use('/tablet', tabletRoutes);
router.use('/taxes', taxRoutes);
router.use('/tips', tipRoutes);
router.use('/tracking', trackingPixelRoutes);
router.use('/translator', translatorRoutes);
router.use('/wallets', walletRoutes);
router.use('/campaign-results', campaignResultRoutes);

module.exports = router;

================
File: src/routes/inventoryRoutes.js
================
const express = require('express');
const inventoryController = require('../controllers/inventoryController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticate);

// Get all inventory items
router.get('/', authorize(['Admin', 'Manager']), inventoryController.getInventory);

// Get a single inventory item by ID
router.get('/:id', authorize(['Admin', 'Manager']), inventoryController.getInventoryItemById);

// Create a new inventory item
router.post('/', authorize(['Admin']), inventoryController.addInventoryItem);

// Update an existing inventory item
router.put('/:id', authorize(['Admin', 'Manager']), inventoryController.updateInventory);

// Delete an inventory item
router.delete('/:id', authorize(['Admin']), inventoryController.removeInventoryItem);

// Update inventory quantity
router.patch('/:id/quantity', authorize(['Admin', 'Manager']), inventoryController.updateInventoryQuantity);

module.exports = router;

================
File: src/routes/invoiceRoutes.js
================
const express = require('express');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');
const invoiceController = require('../controllers/invoiceController');

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticate);

// Generate invoice
router.post('/generate', authorize(['admin', 'manager']), invoiceController.generateInvoice);

// Get invoice by ID
router.get('/:id', authorize(['admin', 'manager']), invoiceController.getInvoiceById);

// Get all invoices for a client
router.get('/client/:clientId', authorize(['admin', 'manager']), invoiceController.getClientInvoices);

// Update invoice
router.put('/:id', authorize(['admin']), invoiceController.updateInvoice);

// Delete invoice
router.delete('/:id', authorize(['admin']), invoiceController.deleteInvoice);

module.exports = router;

================
File: src/routes/itemModifierRoutes.js
================
const express = require('express');
const router = express.Router();
const itemModifierController = require('../controllers/itemModifierController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles(1, 2), itemModifierController.getAllItemModifiers);
router.get('/:id', authorizeRoles(1, 2), itemModifierController.getItemModifierById);
router.post('/', authorizeRoles(1, 2), itemModifierController.createItemModifier);
router.put('/:id', authorizeRoles(1, 2), itemModifierController.updateItemModifier);
router.delete('/:id', authorizeRoles(1, 2), itemModifierController.deleteItemModifier);

module.exports = router;

================
File: src/routes/itemReviewRoutes.js
================
const express = require('express');
const router = express.Router();
const itemReviewController = require('../controllers/itemReviewController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles(1, 2), itemReviewController.getAllItemReviews);
router.get('/:id', authorizeRoles(1, 2), itemReviewController.getItemReviewById);
router.post('/', authorizeRoles(1, 2), itemReviewController.createItemReview);
router.put('/:id', authorizeRoles(1, 2), itemReviewController.updateItemReview);
router.delete('/:id', authorizeRoles(1, 2), itemReviewController.deleteItemReview);

module.exports = router;

================
File: src/routes/itemRoutes.js
================
const express = require('express');
const router = express.Router();
const { authenticateToken, authorizeRoles } = require('../middleware/auth');
const MenuItem = require('../models/MenuItem');

// Get all items
router.get('/', authenticateToken, authorizeRoles(1, 2), async (req, res) => {
  try {
    const items = await MenuItem.findAll();
    res.json(items);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching items', error });
  }
});

// Create a new item
router.post('/', authenticateToken, authorizeRoles(1, 2), async (req, res) => {
  try {
    const { name, description, basePrice, pointsPrice, menuGroupId } = req.body;
    const newItem = await MenuItem.create({ name, description, basePrice, pointsPrice, menuGroupId });
    res.status(201).json(newItem);
  } catch (error) {
    res.status(500).json({ message: 'Error creating item', error });
  }
});

// Update an item
router.put('/:id', authenticateToken, authorizeRoles(1, 2), async (req, res) => {
  try {
    const item = await MenuItem.findByPk(req.params.id);
    if (!item) return res.status(404).json({ message: 'Item not found' });

    await item.update(req.body);
    res.json(item);
  } catch (error) {
    res.status(500).json({ message: 'Error updating item', error });
  }
});

// Delete an item
router.delete('/:id', authenticateToken, authorizeRoles(1, 2), async (req, res) => {
  try {
    const item = await MenuItem.findByPk(req.params.id);
    if (!item) return res.status(404).json({ message: 'Item not found' });

    await item.destroy();
    res.json({ message: 'Item deleted successfully.' });
  } catch (error) {
    res.status(500).json({ message: 'Error deleting item', error });
  }
});

module.exports = router;

================
File: src/routes/LocationCard.js
================
const express = require('express');
const router = express.Router();
const LocationController = require('../controllers/LocationController');

// Get location card details
router.get('/:locationId', LocationController.getLocationCard);

// Update location card details
router.put('/:locationId', LocationController.updateLocationCard);

// Start order for a location
router.post('/:locationId/start-order', LocationController.startOrder);

module.exports = router;

================
File: src/routes/locationHoursRoutes.js
================
const express = require('express');
const router = express.Router();
const { authenticateToken, authorizeRoles } = require('../middleware/auth');
const LocationHours = require('../models/LocationHours');

// Get all hours for a location
router.get('/location/:locationId', authenticateToken, authorizeRoles(1, 2), async (req, res) => {
  try {
    const hours = await LocationHours.findAll({ where: { locationId: req.params.locationId } });
    res.json(hours);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching location hours', error });
  }
});

// Create new location hours
router.post('/', authenticateToken, authorizeRoles(1, 2), async (req, res) => {
  try {
    const { locationId, type, dayOfWeek, startTime, endTime, startDate, endDate } = req.body;
    const hours = await LocationHours.create({
      locationId,
      type,
      dayOfWeek,
      startTime,
      endTime,
      startDate,
      endDate,
    });
    res.status(201).json(hours);
  } catch (error) {
    res.status(500).json({ message: 'Error creating location hours', error });
  }
});

// Update location hours
router.put('/:id', authenticateToken, authorizeRoles(1, 2), async (req, res) => {
  try {
    const hours = await LocationHours.findByPk(req.params.id);
    if (!hours) return res.status(404).json({ message: 'Hours not found' });

    await hours.update(req.body);
    res.json(hours);
  } catch (error) {
    res.status(500).json({ message: 'Error updating location hours', error });
  }
});

// Delete location hours
router.delete('/:id', authenticateToken, authorizeRoles(1, 2), async (req, res) => {
  try {
    const hours = await LocationHours.findByPk(req.params.id);
    if (!hours) return res.status(404).json({ message: 'Hours not found' });

    await hours.destroy();
    res.json({ message: 'Hours deleted successfully.' });
  } catch (error) {
    res.status(500).json({ message: 'Error deleting location hours', error });
  }
});

module.exports = router;

================
File: src/routes/locationMenuGroupRoutes.js
================
const express = require('express');
const router = express.Router();
const locationMenuGroupController = require('../controllers/locationMenuGroupController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles(1, 2), locationMenuGroupController.getAllLocationMenuGroups);
router.get('/:id', authorizeRoles(1, 2), locationMenuGroupController.getLocationMenuGroupById);
router.post('/', authorizeRoles(1, 2), locationMenuGroupController.createLocationMenuGroup);
router.put('/:id', authorizeRoles(1, 2), locationMenuGroupController.updateLocationMenuGroup);
router.delete('/:id', authorizeRoles(1, 2), locationMenuGroupController.deleteLocationMenuGroup);

module.exports = router;

================
File: src/routes/locationMenuOverrideRoutes.js
================
const express = require('express');
const router = express.Router();
const { authenticateToken, authorizeRoles } = require('../middleware/auth');
const LocationMenuOverride = require('../models/LocationMenuOverride');
const { check, validationResult } = require('express-validator');

// Get all overrides for a location
router.get('/location/:locationId', authenticateToken, authorizeRoles(1, 2), async (req, res) => {
  try {
    const overrides = await LocationMenuOverride.findAll({ where: { locationId: req.params.locationId } });
    res.json(overrides);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching overrides', error });
  }
});

// Create a new location-specific override
router.post(
  '/',
  authenticateToken,
  authorizeRoles(1, 2),
  [
    check('locationId').isInt().withMessage('locationId must be an integer'),
    check('menuItemId').isInt().withMessage('menuItemId must be an integer'),
    check('price').optional().isFloat({ min: 0 }).withMessage('price must be a positive number'),
    check('upliftPercentage').optional().isFloat({ min: 0 }).withMessage('upliftPercentage must be a positive number'),
  ],
  async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    try {
      const { price, isAvailable, upliftPercentage, locationId, menuItemId } = req.body;
      const override = await LocationMenuOverride.create({
        price,
        isAvailable,
        upliftPercentage,
        locationId,
        menuItemId,
      });
      res.status(201).json(override);
    } catch (error) {
      res.status(500).json({ message: 'Error creating override', error });
    }
  }
);

// Update location-specific override
router.put(
  '/:id',
  authenticateToken,
  authorizeRoles(1, 2),
  [
    check('price').optional().isFloat({ min: 0 }).withMessage('price must be a positive number'),
    check('upliftPercentage').optional().isFloat({ min: 0 }).withMessage('upliftPercentage must be a positive number'),
  ],
  async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    try {
      const override = await LocationMenuOverride.findByPk(req.params.id);
      if (!override) return res.status(404).json({ message: 'Override not found' });

      await override.update(req.body);
      res.json(override);
    } catch (error) {
      res.status(500).json({ message: 'Error updating override', error });
    }
  }
);

// Delete location-specific override
router.delete('/:id', authenticateToken, authorizeRoles(1, 2), async (req, res) => {
  try {
    const override = await LocationMenuOverride.findByPk(req.params.id);
    if (!override) return res.status(404).json({ message: 'Override not found' });

    await override.destroy();
    res.json({ message: 'Override deleted successfully.' });
  } catch (error) {
    res.status(500).json({ message: 'Error deleting override', error });
  }
});

module.exports = router;

================
File: src/routes/locationPosProfileRoutes.js
================
const express = require('express');
const router = express.Router();
const locationPosProfileController = require('../controllers/locationPosProfileController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles(1, 2), locationPosProfileController.getAllLocationPosProfiles);
router.get('/:id', authorizeRoles(1, 2), locationPosProfileController.getLocationPosProfileById);
router.post('/', authorizeRoles(1, 2), locationPosProfileController.createLocationPosProfile);
router.put('/:id', authorizeRoles(1, 2), locationPosProfileController.updateLocationPosProfile);
router.delete('/:id', authorizeRoles(1, 2), locationPosProfileController.deleteLocationPosProfile);

module.exports = router;

================
File: src/routes/locationRoutes.js
================
const express = require('express');
const locationController = require('../controllers/locationController');
const authorize = require('../middleware/authorize');
const { authenticate } = require('../middleware/auth');

const router = express.Router();

router.use(authenticate); // Authenticate all location routes

router.get('/', locationController.getLocations);
router.post('/', locationController.createLocation);
router.get('/:id', locationController.getLocationDetails);
router.put('/:id', locationController.updateLocation);
router.delete('/:id', locationController.deleteLocation);
router.get('/count/:clientId', authenticate, locationController.getLocationCount);

module.exports = router;

================
File: src/routes/locations.js
================
const express = require 'express';
import { 
  getLocations, 
  createLocation, 
  updateLocation, 
  deleteLocation,
  updateLocationPOSSettings
} from '../controllers/locationController';
const { authenticate, authorize } = require '../middleware/auth';

const router = express.Router();

router.get('/', authenticate, getLocations);
router.post('/', authenticate, authorize('admin'), createLocation);
router.put('/:id', authenticate, authorize('admin'), updateLocation);
router.delete('/:id', authenticate, authorize('admin'), deleteLocation);
router.put('/:id/pos-settings', authenticate, authorize('admin'), updateLocationPOSSettings);

module.exports = router;

================
File: src/routes/LocationSelectionPage.js
================
const express = require('express');
const router = express.Router();
const LocationController = require('../controllers/LocationController');
const AuthController = require('../controllers/AuthController');

// Get all locations for the selection page
router.get('/', LocationController.getAllLocations);

// Get filtered locations
router.post('/filter', LocationController.getFilteredLocations);

// Get client branding information
router.get('/branding', LocationController.getClientBranding);

// Get user role (for admin dashboard access)
router.get('/user-role', AuthController.getUserRole);

// Login route (if needed on this page)
router.post('/login', AuthController.login);

module.exports = router;

================
File: src/routes/locationTaxConfigRoutes.js
================
const express = require('express');
const router = express.Router();
const locationTaxConfigController = require('../controllers/locationTaxConfigController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles(1, 2), locationTaxConfigController.getAllLocationTaxConfigs);
router.get('/:id', authorizeRoles(1, 2), locationTaxConfigController.getLocationTaxConfigById);
router.post('/', authorizeRoles(1, 2), locationTaxConfigController.createLocationTaxConfig);
router.put('/:id', authorizeRoles(1, 2), locationTaxConfigController.updateLocationTaxConfig);
router.delete('/:id', authorizeRoles(1, 2), locationTaxConfigController.deleteLocationTaxConfig);

module.exports = router;

================
File: src/routes/loyaltyRoutes.js
================
const express = require('express');
const loyaltyController = require('../controllers/loyaltyController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticate);

// Get loyalty program details
router.get('/program/:clientId', authorize(['admin', 'manager']), loyaltyController.getLoyaltyProgram);

// Create or update loyalty program
router.post('/program', authorize(['admin']), loyaltyController.createOrUpdateLoyaltyProgram);

// Get customer loyalty points
router.get('/points/:customerId', authorize(['admin', 'manager', 'customer']), loyaltyController.getCustomerPoints);

// Add loyalty points
router.post('/points/add', authorize(['admin', 'manager']), loyaltyController.addLoyaltyPoints);

// Redeem loyalty points
router.post('/points/redeem', authorize(['admin', 'manager', 'customer']), loyaltyController.redeemLoyaltyPoints);

// Get loyalty tiers
router.get('/tiers/:clientId', authorize(['admin', 'manager']), loyaltyController.getLoyaltyTiers);

// Create loyalty tier
router.post('/tiers', authorize(['admin']), loyaltyController.createLoyaltyTier);

// Update loyalty tier
router.put('/tiers/:tierId', authorize(['admin']), loyaltyController.updateLoyaltyTier);

// Delete loyalty tier
router.delete('/tiers/:tierId', authorize(['admin']), loyaltyController.deleteLoyaltyTier);

// Get loyalty rewards
router.get('/rewards/:clientId', authorize(['admin', 'manager', 'customer']), loyaltyController.getLoyaltyRewards);

// Create loyalty reward
router.post('/rewards', authorize(['admin']), loyaltyController.createLoyaltyReward);

// Update loyalty reward
router.put('/rewards/:rewardId', authorize(['admin']), loyaltyController.updateLoyaltyReward);

// Delete loyalty reward
router.delete('/rewards/:rewardId', authorize(['admin']), loyaltyController.deleteLoyaltyReward);

module.exports = router;

================
File: src/routes/loyaltyWalletRoutes.js
================
const express = require('express');
const router = express.Router();
const { authenticateToken } = require('../middleware/auth');
const loyaltyWalletController = require('../controllers/loyaltyWalletController');

// Get loyalty wallet
router.get('/:guestId', authenticateToken, loyaltyWalletController.getWallet);

// Add points to the wallet
router.post('/add-points', authenticateToken, loyaltyWalletController.addPoints);

// Redeem a reward
router.post('/redeem', authenticateToken, loyaltyWalletController.redeemReward);

module.exports = router;

================
File: src/routes/menuGroupRoutes.js
================
const express = require('express');
const router = express.Router();
const { authenticateToken, authorizeRoles } = require('../middleware/auth');
const MenuGroup = require('../models/MenuGroup');

// Get all groups for a menu
router.get('/menu/:menuId', authenticateToken, authorizeRoles(1, 2), async (req, res) => {
  try {
    const groups = await MenuGroup.findAll({ where: { menuId: req.params.menuId } });
    res.json(groups);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching groups', error });
  }
});

// Create a new menu group
router.post('/', authenticateToken, authorizeRoles(1, 2), async (req, res) => {
  try {
    const { name, description, menuId } = req.body;
    const group = await MenuGroup.create({ name, description, menuId });
    res.status(201).json(group);
  } catch (error) {
    res.status(500).json({ message: 'Error creating group', error });
  }
});

// Update a menu group
router.put('/:id', authenticateToken, authorizeRoles(1, 2), async (req, res) => {
  try {
    const group = await MenuGroup.findByPk(req.params.id);
    if (!group) return res.status(404).json({ message: 'Group not found' });

    await group.update(req.body);
    res.json(group);
  } catch (error) {
    res.status(500).json({ message: 'Error updating group', error });
  }
});

// Delete a menu group
router.delete('/:id', authenticateToken, authorizeRoles(1, 2), async (req, res) => {
  try {
    const group = await MenuGroup.findByPk(req.params.id);
    if (!group) return res.status(404).json({ message: 'Group not found' });

    await group.destroy();
    res.json({ message: 'Group deleted successfully.' });
  } catch (error) {
    res.status(500).json({ message: 'Error deleting group', error });
  }
});

module.exports = router;

================
File: src/routes/menuItemRoutes.js
================
const express = require('express');
const router = express.Router();
const { authenticateToken, authorizeRoles } = require('../middleware/auth');
const MenuItem = require('../models/MenuItem');

// Get all items for a menu group
router.get('/group/:menuGroupId', authenticateToken, authorizeRoles(1, 2), async (req, res) => {
  try {
    const items = await MenuItem.findAll({ where: { menuGroupId: req.params.menuGroupId } });
    res.json(items);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching items', error });
  }
});

// Create a new menu item
router.post('/', authenticateToken, authorizeRoles(1, 2), async (req, res) => {
  try {
    const { name, description, basePrice, menuGroupId } = req.body;
    const item = await MenuItem.create({ name, description, basePrice, menuGroupId });
    res.status(201).json(item);
  } catch (error) {
    res.status(500).json({ message: 'Error creating item', error });
  }
});

// Update a menu item
router.put('/:id', authenticateToken, authorizeRoles(1, 2), async (req, res) => {
  try {
    const item = await MenuItem.findByPk(req.params.id);
    if (!item) return res.status(404).json({ message: 'Item not found' });

    await item.update(req.body);
    res.json(item);
  } catch (error) {
    res.status(500).json({ message: 'Error updating item', error });
  }
});

// Delete a menu item
router.delete('/:id', authenticateToken, authorizeRoles(1, 2), async (req, res) => {
  try {
    const item = await MenuItem.findByPk(req.params.id);
    if (!item) return res.status(404).json({ message: 'Item not found' });

    await item.destroy();
    res.json({ message: 'Item deleted successfully.' });
  } catch (error) {
    res.status(500).json({ message: 'Error deleting item', error });
  }
});

module.exports = router;

================
File: src/routes/menuRoutes.js
================
const express = require('express');
const { getMenus, updateMenuItem } = require('../controllers/menuController');
const { authMiddleware } = require('../middleware/authMiddleware');

const router = express.Router();

router.get('/clients/:clientId/menus', authMiddleware, getMenus);
router.put('/menus/:menuId/items/:itemId', authMiddleware, updateMenuItem);

module.exports = router;

================
File: src/routes/modifierRoutes.js
================
const express = require('express');
const router = express.Router();
const { authenticateToken, authorizeRoles } = require('../middleware/auth');
const Modifier = require('../models/Modifier');

// Get all modifiers for a menu item
router.get('/item/:menuItemId', authenticateToken, authorizeRoles(1, 2), async (req, res) => {
  try {
    const modifiers = await Modifier.findAll({ where: { menuItemId: req.params.menuItemId } });
    res.json(modifiers);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching modifiers', error });
  }
});

// Create a new modifier
router.post('/', authenticateToken, authorizeRoles(1, 2), async (req, res) => {
  try {
    const { name, price, menuItemId } = req.body;
    const modifier = await Modifier.create({ name, price, menuItemId });
    res.status(201).json(modifier);
  } catch (error) {
    res.status(500).json({ message: 'Error creating modifier', error });
  }
});

// Update a modifier
router.put('/:id', authenticateToken, authorizeRoles(1, 2), async (req, res) => {
  try {
    const modifier = await Modifier.findByPk(req.params.id);
    if (!modifier) return res.status(404).json({ message: 'Modifier not found' });

    await modifier.update(req.body);
    res.json(modifier);
  } catch (error) {
    res.status(500).json({ message: 'Error updating modifier', error });
  }
});

// Delete a modifier
router.delete('/:id', authenticateToken, authorizeRoles(1, 2), async (req, res) => {
  try {
    const modifier = await Modifier.findByPk(req.params.id);
    if (!modifier) return res.status(404).json({ message: 'Modifier not found' });

    await modifier.destroy();
    res.json({ message: 'Modifier deleted successfully.' });
  } catch (error) {
    res.status(500).json({ message: 'Error deleting modifier', error });
  }
});

module.exports = router;

================
File: src/routes/orderHistoryRoutes.js
================
const express = require('express');
const router = express.Router();
const { authenticateToken, authorizeRoles } = require('../middleware/auth');
const Order = require('../models/Order');

// Get order history for a guest
router.get('/guest/:guestId', authenticateToken, authorizeRoles(1, 2), async (req, res) => {
  try {
    const orders = await Order.findAll({ where: { guestId: req.params.guestId } });
    res.json(orders);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching order history', error });
  }
});

module.exports = router;

================
File: src/routes/orderRoutes.js
================
const express = require('express');
const OrderController = require('../controllers/orderController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');

const router = express.Router();

// Order routes
router.get('/history', authenticate, authorize(['User', 'Admin']), OrderController.getOrderHistory);
router.post('/', authenticate, authorize(['User']), OrderController.createOrder); // Changed to createOrder
router.get('/:orderId', authenticate, authorize(['User', 'Admin']), OrderController.getOrderDetails);
router.put('/:orderId/cancel', authenticate, authorize(['User']), OrderController.cancelOrder);
router.put('/:orderId/status', authenticate, authorize(['Admin']), OrderController.updateOrderStatus);

// Add other necessary routes (updateOrder, deleteOrder, etc.)
router.post('/orders', OrderController.createOrder);
router.get('/orders/:id', OrderController.getOrder);

module.exports = router;

================
File: src/routes/orders.js
================
const express = require('express');
const router = express.Router();
const { Order } = require('../models');

// Get all orders
router.get('/', async (req, res) => {
  try {
    const orders = await Order.findAll();
    res.json(orders);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Get a specific order
router.get('/:id', async (req, res) => {
  try {
    const order = await Order.findByPk(req.params.id);
    if (order) {
      res.json(order);
    } else {
      res.status(404).json({ message: 'Order not found' });
    }
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Create a new order
router.post('/', async (req, res) => {
  try {
    const newOrder = await Order.create(req.body);
    res.status(201).json(newOrder);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Update an order
router.put('/:id', async (req, res) => {
  try {
    const [updated] = await Order.update(req.body, {
      where: { id: req.params.id }
    });
    if (updated) {
      const updatedOrder = await Order.findByPk(req.params.id);
      res.status(200).json(updatedOrder);
    } else {
      res.status(404).json({ message: 'Order not found' });
    }
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Delete an order
router.delete('/:id', async (req, res) => {
  try {
    const deleted = await Order.destroy({
      where: { id: req.params.id }
    });
    if (deleted) {
      res.status(204).json({ message: 'Order deleted' });
    } else {
      res.status(404).json({ message: 'Order not found' });
    }
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;

================
File: src/routes/paymentRoutes.js
================
const express = require('express');
const paymentController = require('../controllers/paymentController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticate);

// Process payment
router.post('/process', authorize(['admin', 'manager', 'customer']), paymentController.processPayment);

// Get payment by ID
router.get('/:id', authorize(['admin', 'manager']), paymentController.getPaymentById);

// Refund payment
router.post('/refund', authorize(['admin', 'manager']), paymentController.refundPayment);

// Get payment methods for a client
router.get('/methods/:clientId', authorize(['admin', 'manager', 'customer']), paymentController.getPaymentMethods);

// Add payment method
router.post('/methods', authorize(['admin', 'manager', 'customer']), paymentController.addPaymentMethod);

// Update payment method
router.put('/methods/:methodId', authorize(['admin', 'manager', 'customer']), paymentController.updatePaymentMethod);

// Delete payment method
router.delete('/methods/:methodId', authorize(['admin', 'manager', 'customer']), paymentController.deletePaymentMethod);

module.exports = router;

================
File: src/routes/posIntegrationMappingRoutes.js
================
const express = require('express');
const router = express.Router();
const posIntegrationMappingController = require('../controllers/posIntegrationMappingController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles('Admin', 'Manager'), posIntegrationMappingController.getAllMappings);
router.post('/', authorizeRoles('Admin', 'Manager'), posIntegrationMappingController.createMapping);
router.get('/:id', authorizeRoles('Admin', 'Manager'), posIntegrationMappingController.getMappingById);
router.put('/:id', authorizeRoles('Admin', 'Manager'), posIntegrationMappingController.updateMapping);
router.delete('/:id', authorizeRoles('Admin', 'Manager'), posIntegrationMappingController.deleteMapping);

module.exports = router;

================
File: src/routes/posIntegrationRoutes.js
================
const express = require('express');
const router = express.Router();
const PosIntegrationController = require('../controllers/posIntegrationController');

// Route to trigger menu sync
router.post('/sync/menus', PosIntegrationController.syncMenus);

// Route to trigger order sync
router.post('/sync/orders', PosIntegrationController.syncOrders);

// Route to trigger inventory sync
router.post('/sync/inventory', PosIntegrationController.syncInventory);

// Route to trigger tax rates sync (if applicable)
router.post('/sync/tax-rates', PosIntegrationController.syncTaxRates);

module.exports = router;

================
File: src/routes/posIntegrationSettingsRoutes.js
================
const express = require('express');
const router = express.Router();
const posIntegrationSettingsController = require('../controllers/posIntegrationSettingsController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles('Admin', 'Manager'), posIntegrationSettingsController.getAllPosIntegrationSettings);
router.post('/', authorizeRoles('Admin', 'Manager'), posIntegrationSettingsController.createPosIntegrationSetting);
router.get('/:id', authorizeRoles('Admin', 'Manager'), posIntegrationSettingsController.getPosIntegrationSettingById);
router.put('/:id', authorizeRoles('Admin', 'Manager'), posIntegrationSettingsController.updatePosIntegrationSetting);
router.delete('/:id', authorizeRoles('Admin', 'Manager'), posIntegrationSettingsController.deletePosIntegrationSetting);

module.exports = router;

================
File: src/routes/posRoutes.js
================
const express = require('express');
const PosController = require('../controllers/posController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticate);

// Define routes with appropriate authorization
router.post('/', authorize(['admin']), PosController.createProfile);
router.get('/:id', authorize(['admin']), PosController.getProfile);
router.put('/:id', authorize(['admin']), PosController.updateProfile);
router.delete('/:id', authorize(['admin']), PosController.deleteProfile);
router.post('/sync', authorize(['admin']), PosController.syncData);
router.get('/status/:id', authorize(['admin']), PosController.getStatus);

module.exports = router;

================
File: src/routes/posSyncRoutes.js
================
const express = require('express');
const router = express.Router();
const PosSyncController = require('../controllers/posSyncController');

// Route to sync menus
router.post('/sync/menus', PosSyncController.syncMenus);

// Route to sync orders
router.post('/sync/orders', PosSyncController.syncOrders);

// Route to sync inventory
router.post('/sync/inventory', PosSyncController.syncInventory);

module.exports = router;

================
File: src/routes/pricingUtils.js
================
const roundToNext99 = (price) => {
  const roundedPrice = Math.ceil(price) - 0.01;
  return roundedPrice.toFixed(2);
};

module.exports = { roundToNext99 };

================
File: src/routes/providerIntegrationRoutes.js
================
const express = require('express');
const router = express.Router();
const { authenticateToken, authorizeRoles } = require('../middleware/auth');
const TranslatorService = require('../translator/translatorService');
const providerConfigs = require('../translator/providerConfigs');

// Example route to send a menu to a provider
router.post('/send-menu/:provider', authenticateToken, authorizeRoles(1, 2), async (req, res) => {
  try {
    const { provider } = req.params;
    const providerConfig = providerConfigs[provider];

    if (!providerConfig) {
      return res.status(400).json({ message: 'Invalid provider specified.' });
    }

    const translator = new TranslatorService(providerConfig);
    const translatedMenu = translator.translateMenu(req.body.menuData);

    const response = await translator.sendDataToProvider(translatedMenu);
    res.json({ message: 'Menu sent successfully.', data: response });
  } catch (error) {
    res.status(500).json({ message: 'Error sending menu to provider.', error });
  }
});

module.exports = router;

================
File: src/routes/ProviderPricing.js
================
module.exports = (sequelize, DataTypes) => {
  const ProviderPricing = sequelize.define('ProviderPricing', {
    provider: {
      type: DataTypes.STRING, // e.g., 'DoorDash', 'UberEats'
      allowNull: false,
    },
    upliftPercentage: {
      type: DataTypes.FLOAT,
      allowNull: false, // e.g., 18 for 18%
    },
  });

  ProviderPricing.associate = (models) => {
    ProviderPricing.belongsTo(models.LocationMenuOverride, { foreignKey: 'locationMenuOverrideId' });
  };

  return ProviderPricing;
};

================
File: src/routes/providerPricingRoutes.js
================
const express = require('express');
const router = express.Router();
const { authenticateToken, authorizeRoles } = require('../middleware/auth');
const ProviderPricing = require('../models/ProviderPricing');

// Get all provider-specific pricings for a location menu override
router.get('/override/:locationMenuOverrideId', authenticateToken, authorizeRoles(1, 2), async (req, res) => {
  try {
    const providerPricings = await ProviderPricing.findAll({ where: { locationMenuOverrideId: req.params.locationMenuOverrideId } });
    res.json(providerPricings);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching provider pricings', error });
  }
});

// Create a new provider-specific pricing
router.post('/', authenticateToken, authorizeRoles(1, 2), async (req, res) => {
  try {
    const { provider, upliftPercentage, locationMenuOverrideId, shouldRound } = req.body;
    const providerPricing = await ProviderPricing.create({
      provider,
      upliftPercentage,
      locationMenuOverrideId,
      shouldRound,
    });
    res.status(201).json(providerPricing);
  } catch (error) {
    res.status(500).json({ message: 'Error creating provider pricing', error });
  }
});

// Update provider-specific pricing
router.put('/:id', authenticateToken, authorizeRoles(1, 2), async (req, res) => {
  try {
    const providerPricing = await ProviderPricing.findByPk(req.params.id);
    if (!providerPricing) return res.status(404).json({ message: 'Provider pricing not found' });

    await providerPricing.update(req.body);
    res.json(providerPricing);
  } catch (error) {
    res.status(500).json({ message: 'Error updating provider pricing', error });
  }
});

// Delete provider-specific pricing
router.delete('/:id', authenticateToken, authorizeRoles(1, 2), async (req, res) => {
  try {
    const providerPricing = await ProviderPricing.findByPk(req.params.id);
    if (!providerPricing) return res.status(404).json({ message: 'Provider pricing not found' });

    await providerPricing.destroy();
    res.json({ message: 'Provider pricing deleted successfully.' });
  } catch (error) {
    res.status(500).json({ message: 'Error deleting provider pricing', error });
  }
});

module.exports = router;

================
File: src/routes/providerRoutes.js
================
const express = require('express');
const providerController = require('../controllers/providerController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticate);

// Get all providers
router.get('/', authorize(['admin', 'manager']), providerController.getAllProviders);

// Get a specific provider
router.get('/:id', authorize(['admin', 'manager']), providerController.getProviderById);

// Create a new provider
router.post('/', authorize(['admin']), providerController.createProvider);

// Update a provider
router.put('/:id', authorize(['admin']), providerController.updateProvider);

// Delete a provider
router.delete('/:id', authorize(['admin']), providerController.deleteProvider);

// Get provider settings
router.get('/:id/settings', authorize(['admin', 'manager']), providerController.getProviderSettings);

// Update provider settings
router.put('/:id/settings', authorize(['admin']), providerController.updateProviderSettings);

// Get provider integrations
router.get('/:id/integrations', authorize(['admin', 'manager']), providerController.getProviderIntegrations);

// Add provider integration
router.post('/:id/integrations', authorize(['admin']), providerController.addProviderIntegration);

// Update provider integration
router.put('/:id/integrations/:integrationId', authorize(['admin']), providerController.updateProviderIntegration);

// Delete provider integration
router.delete('/:id/integrations/:integrationId', authorize(['admin']), providerController.deleteProviderIntegration);

// Sync provider data
router.post('/:id/sync', authorize(['admin']), providerController.syncProviderData);

// New routes for provider service
router.get('/providers', providerController.getProviders);
router.get('/providers/:id', providerController.getProvider);
router.post('/providers', providerController.addProvider);
router.put('/providers/:id', providerController.updateProvider);
router.delete('/providers/:id', providerController.deleteProvider);
router.get('/providers/search', providerController.searchProviders);
router.post('/providers/bulk-delete', providerController.bulkDeleteProviders);
router.get('/providers/stats', providerController.getProviderStats);

module.exports = router;

================
File: src/routes/refundRoutes.js
================
const express = require('express');
const refundController = require('../controllers/refundController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticate);

// Process refund
router.post('/', authorize(['admin', 'manager']), refundController.processRefund);

// Get refund by ID
router.get('/:id', authorize(['admin', 'manager']), refundController.getRefundById);

// Get all refunds for an order
router.get('/order/:orderId', authorize(['admin', 'manager']), refundController.getRefundsByOrder);

// Update refund status
router.put('/:id/status', authorize(['admin']), refundController.updateRefundStatus);

// Cancel refund
router.post('/:id/cancel', authorize(['admin']), refundController.cancelRefund);

module.exports = router;

================
File: src/routes/reportRoutes.js
================
const express = require('express');
const reportController = require('../controllers/reportController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticate);

// Generate report
router.post('/generate', authorize(['admin', 'manager']), reportController.generateReport);

// Get report by ID
router.get('/:id', authorize(['admin', 'manager']), reportController.getReportById);

// Get all reports for a client
router.get('/client/:clientId', authorize(['admin', 'manager']), reportController.getClientReports);

// Update report
router.put('/:id', authorize(['admin']), reportController.updateReport);

// Delete report
router.delete('/:id', authorize(['admin']), reportController.deleteReport);

module.exports = router;

================
File: src/routes/reviewRoutes.js
================
const express = require('express');
const reviewController = require('../controllers/reviewController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticate);

// Create a new review
router.post('/', authorize(['customer', 'admin']), reviewController.createReview);

// Get reviews for a menu item
router.get('/menuItem/:menuItemId', reviewController.getReviewsForMenuItem);

// Get a specific review
router.get('/:id', reviewController.getReviewById);

// Update a review
router.put('/:id', authorize(['customer', 'admin']), reviewController.updateReview);

// Delete a review
router.delete('/:id', authorize(['admin']), reviewController.deleteReview);

// Get average rating for a menu item
router.get('/menuItem/:menuItemId/averageRating', reviewController.getAverageRatingForMenuItem);

module.exports = router;

================
File: src/routes/rewardRoutes.js
================
const express = require('express');
const router = express.Router();
const rewardController = require('../controllers/rewardController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles('Admin', 'Manager'), rewardController.getAllRewards);
router.post('/', authorizeRoles('Admin', 'Manager'), rewardController.createReward);
router.get('/:id', authorizeRoles('Admin', 'Manager'), rewardController.getRewardById);

module.exports = router;

================
File: src/routes/roleRoutes.js
================
const express = require('express');
const roleController = require('../controllers/roleController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticate);

// Create a new role
router.post('/create-role', authorize(['Super Admin']), roleController.createRole);

// Get all roles
router.get('/', authorize(['Super Admin', 'Admin']), roleController.getAllRoles);

// Get a specific role
router.get('/:id', authorize(['Super Admin', 'Admin']), roleController.getRoleById);

// Update a role
router.put('/:id', authorize(['Super Admin']), roleController.updateRole);

// Delete a role
router.delete('/:id', authorize(['Super Admin']), roleController.deleteRole);

// Assign a role to a user
router.post('/assign', authorize(['Super Admin', 'Admin']), roleController.assignRole);

// Remove a role from a user
router.post('/remove', authorize(['Super Admin', 'Admin']), roleController.removeRole);

// Get roles for a specific user
router.get('/user/:userId', authorize(['Super Admin', 'Admin']), roleController.getUserRoles);

// Assign permission to a role
router.post('/assign-permission', authorize(['Super Admin']), roleController.assignPermission);

// Get all permissions
router.get('/permissions', authorize(['Super Admin', 'Admin']), roleController.getAllPermissions);

// Assign role template
router.post('/assign-template', authorize(['Super Admin']), roleController.assignRoleTemplate);

module.exports = router;

================
File: src/routes/roleTemplateAssignmentsRoutes.js
================
const express = require('express');
const router = express.Router();
const roleTemplateAssignmentsController = require('../controllers/roleTemplateAssignmentsController');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

router.use(authenticateToken);

router.get('/', authorizeRoles('Admin', 'Manager'), roleTemplateAssignmentsController.getAllRoleTemplateAssignments);
router.post('/', authorizeRoles('Admin', 'Manager'), roleTemplateAssignmentsController.createRoleTemplateAssignment);
router.get('/:id', authorizeRoles('Admin', 'Manager'), roleTemplateAssignmentsController.getRoleTemplateAssignmentById);
router.put('/:id', authorizeRoles('Admin', 'Manager'), roleTemplateAssignmentsController.updateRoleTemplateAssignment);
router.delete('/:id', authorizeRoles('Admin', 'Manager'), roleTemplateAssignmentsController.deleteRoleTemplateAssignment);

module.exports = router;

================
File: src/routes/secureRoutes.js
================
const express = require('express');
const { authenticateToken } = require('../middleware/auth');
const router = express.Router();

router.get('/secure-endpoint', authenticateToken, (req, res) => {
  res.status(200).json({ message: 'Access granted' });
});

module.exports = router;

================
File: src/routes/serviceFeeRoutes.js
================
const express = require('express');
const serviceFeeController = require('../controllers/serviceFeeController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticate);

// Get all service fees
router.get('/', authorize(['admin', 'manager']), serviceFeeController.getAllServiceFees);

// Get a specific service fee
router.get('/:id', authorize(['admin', 'manager']), serviceFeeController.getServiceFeeById);

// Create a new service fee
router.post('/', authorize(['admin']), serviceFeeController.createServiceFee);

// Update a service fee
router.put('/:id', authorize(['admin']), serviceFeeController.updateServiceFee);

// Delete a service fee
router.delete('/:id', authorize(['admin']), serviceFeeController.deleteServiceFee);

// Get service fees for a specific client
router.get('/client/:clientId', authorize(['admin', 'manager']), serviceFeeController.getServiceFeesByClient);

module.exports = router;

================
File: src/routes/tabletRoutes.js
================
const express = require('express');
const tabletController = require('../controllers/tabletController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticate);

// Get all tablets
router.get('/', authorize(['admin', 'manager']), tabletController.getAllTablets);

// Get a specific tablet
router.get('/:id', authorize(['admin', 'manager']), tabletController.getTabletById);

// Create a new tablet
router.post('/', authorize(['admin']), tabletController.createTablet);

// Update a tablet
router.put('/:id', authorize(['admin']), tabletController.updateTablet);

// Delete a tablet
router.delete('/:id', authorize(['admin']), tabletController.deleteTablet);

// Get tablets for a specific location
router.get('/location/:locationId', authorize(['admin', 'manager']), tabletController.getTabletsByLocation);

// Sync tablet data
router.post('/:id/sync', authorize(['admin', 'manager']), tabletController.syncTabletData);

module.exports = router;

================
File: src/routes/tailwind.css
================
/* Add styles for the inventory management and guest-facing features */

.menu-container {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 20px;
  padding: 20px;
}

.menu-item {
  background-color: #fff;
  border: 1px solid #ccc;
  padding: 10px;
  cursor: pointer;
  transition: background-color 0.3s;
}

.menu-item:hover {
  background-color: #f9f9f9;
}

.menu-item.unavailable {
  opacity: 0.5;
  pointer-events: none;
}

.unavailable-overlay {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-weight: bold;
  color: red;
}

.order-page {
  padding: 20px;
}

================
File: src/routes/taxRoutes.js
================
const express = require('express');
const taxController = require('../controllers/taxController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticate);

// Get all tax rates
router.get('/', authorize(['admin', 'manager']), taxController.getAllTaxRates);

// Get a specific tax rate
router.get('/:id', authorize(['admin', 'manager']), taxController.getTaxRateById);

// Create a new tax rate
router.post('/', authorize(['admin']), taxController.createTaxRate);

// Update a tax rate
router.put('/:id', authorize(['admin']), taxController.updateTaxRate);

// Delete a tax rate
router.delete('/:id', authorize(['admin']), taxController.deleteTaxRate);

// Get tax rates for a specific location
router.get('/location/:locationId', authorize(['admin', 'manager']), taxController.getTaxRatesByLocation);

// Calculate tax for an order
router.post('/calculate', authorize(['admin', 'manager', 'customer']), taxController.calculateTax);

module.exports = router;

================
File: src/routes/throttleSettingsRoutes.js
================
const express = require('express');
const router = express.Router();
const { authenticateToken, authorizeRoles } = require('../middleware/auth');
const Location = require('../models/Location');

// Update throttle settings for a location
router.put('/location/:locationId/throttle-settings', authenticateToken, authorizeRoles(1, 2), async (req, res) => {
  try {
    const { locationId } = req.params;
    const { throttleSettings } = req.body;

    const location = await Location.findByPk(locationId);
    if (!location) return res.status(404).json({ message: 'Location not found' });

    location.throttleSettings = throttleSettings;
    await location.save();

    res.json(location);
  } catch (error) {
    res.status(500).json({ message: 'Error updating throttle settings', error });
  }
});

module.exports = router;

================
File: src/routes/tipRoutes.js
================
const express = require('express');
const router = express.Router();
const tipController = require('../controllers/tipController');

router.post('/tips', tipController.createTip);
router.get('/tips', tipController.getTips);

module.exports = router;

================
File: src/routes/toastRoutes.js
================
const express = require('express');
const router = express.Router();
const ToastService = require('../services/ToastService');
const { authenticateToken } = require('../middleware/auth');

// Route to authenticate with Toast and retrieve the token
router.post('/toast/authenticate', authenticateToken, async (req, res) => {
  try {
    const { clientId, clientSecret } = req.body;
    const token = await ToastService.authenticate(clientId, clientSecret);
    res.status(200).json({ token });
  } catch (error) {
    res.status(500).json({ message: 'Authentication failed', error: error.message });
  }
});

// Route to fetch menu data from Toast
router.get('/toast/menu', authenticateToken, async (req, res) => {
  try {
    const { token, restaurantId } = req.query;
    const menuData = await ToastService.getMenu(token, restaurantId);
    res.status(200).json(menuData);
  } catch (error) {
    res.status(500).json({ message: 'Failed to retrieve menu data', error: error.message });
  }
});

module.exports = router;

================
File: src/routes/trackingPixelRoutes.js
================
const express = require('express');
const trackingPixelController = require('../controllers/trackingPixelController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticate);

// Create a new tracking pixel
router.post('/', authorize(['Admin']), trackingPixelController.createPixel);

// Get all tracking pixels
router.get('/', authorize(['Admin']), trackingPixelController.getAllPixels);

// Get a specific tracking pixel
router.get('/:id', authorize(['Admin']), trackingPixelController.getPixelById);

// Update a tracking pixel
router.put('/:id', authorize(['Admin']), trackingPixelController.updatePixel);

// Delete a tracking pixel
router.delete('/:id', authorize(['Admin']), trackingPixelController.deletePixel);

// Trigger a tracking pixel
router.get('/trigger/:id', trackingPixelController.triggerPixel);

module.exports = router;

================
File: src/routes/translatorRoutes.js
================
const express = require('express');
const translatorController = require('../controllers/translatorController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticate);

// Translate text
router.post('/translate', authorize(['admin', 'manager']), translatorController.translateText);

// Get supported languages
router.get('/languages', authorize(['admin', 'manager']), translatorController.getSupportedLanguages);

// Detect language
router.post('/detect', authorize(['admin', 'manager']), translatorController.detectLanguage);

// Translate menu items
router.post('/translate-menu', authorize(['admin']), translatorController.translateMenu);

// Get translation history
router.get('/history', authorize(['admin', 'manager']), translatorController.getTranslationHistory);

module.exports = router;

================
File: src/routes/twoFactorRoutes.js
================
const express = require('express');
const twoFactorController = require('../controllers/twoFactorController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticate);

// Enable 2FA for a user
router.post('/enable', authorize(['user', 'admin']), twoFactorController.enable2FA);

// Disable 2FA for a user
router.post('/disable', authorize(['user', 'admin']), twoFactorController.disable2FA);

// Verify 2FA token
router.post('/verify', twoFactorController.verify2FA);

// Generate backup codes
router.post('/generate-backup-codes', authorize(['user', 'admin']), twoFactorController.generateBackupCodes);

// Verify backup code
router.post('/verify-backup-code', twoFactorController.verifyBackupCode);

// Get 2FA status for a user
router.get('/status', authorize(['user', 'admin']), twoFactorController.get2FAStatus);

module.exports = router;

================
File: src/routes/userRoutes.js
================
const express = require('express');
const UserController = require('../controllers/userController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');

const router = express.Router();

// Check if the method exists before using it
if (UserController.getAllUsers) {
  router.get('/', authenticate, authorize(['Super Admin']), UserController.getAllUsers);
} else {
  console.warn('Warning: UserController.getAllUsers is not defined');
}

if (UserController.getUserById) {
  router.get('/:id', authenticate, authorize(['Super Admin', 'Admin']), UserController.getUserById);
} else {
  console.warn('Warning: UserController.getUserById is not defined');
}

if (UserController.createUser) {
  router.post('/', authenticate, authorize(['Super Admin']), UserController.createUser);
} else {
  console.warn('Warning: UserController.createUser is not defined');
}

if (UserController.updateUser) {
  router.put('/:id', authenticate, authorize(['Super Admin', 'Admin']), UserController.updateUser);
} else {
  console.warn('Warning: UserController.updateUser is not defined');
}

if (UserController.deleteUser) {
  router.delete('/:id', authenticate, authorize(['Super Admin']), UserController.deleteUser);
} else {
  console.warn('Warning: UserController.deleteUser is not defined');
}

module.exports = router;

================
File: src/routes/walletRoutes.js
================
const express = require('express');
const walletController = require('../controllers/walletController');
const { authenticate } = require('../middleware/auth');
const authorize = require('../middleware/authorize');

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticate);

// Get wallet balance
router.get('/balance', authorize(['user', 'admin']), walletController.getWalletBalance);

// Add funds to wallet
router.post('/add-funds', authorize(['user', 'admin']), walletController.addFunds);

// Withdraw funds from wallet
router.post('/withdraw', authorize(['user', 'admin']), walletController.withdrawFunds);

// Get transaction history
router.get('/transactions', authorize(['user', 'admin']), walletController.getTransactionHistory);

// Transfer funds to another user
router.post('/transfer', authorize(['user', 'admin']), walletController.transferFunds);

// Get wallet details
router.get('/:userId', authorize(['admin']), walletController.getWalletDetails);

module.exports = router;

================
File: src/seeders/enterpriseClientSeeder.js
================
const { getRepository, Connection } = require 'typeorm';
const { faker } = require '@faker-js/faker';
const { Client, Location, Guest, MenuItem, LoyaltyReward, Order, Discount, AuditLog, DropOffLocation, DropOffTime } = require '../entities';

export async function seedEnterpriseClient(connection) {
  const client = await seedClient(connection);
  const locations = await seedLocations(connection, client);
  const menuItems = await seedMenuItems(connection, client);
  const guests = await seedGuests(connection, client);
  const loyaltyRewards = await seedLoyaltyRewards(connection, client);
  const discounts = await seedDiscounts(connection, client);
  await seedOrders(connection, client, locations, guests, menuItems, discounts);
  await seedAuditLog(connection, client);

  console.log('Enterprise client data seeded successfully');
}

async function seedClient(connection) {
  const clientRepository = getRepository(Client);
  const client = clientRepository.create({
    name: 'Enterprise Foods Inc.',
    subdomain: 'enterprise-foods',
    active,
  });
  return await clientRepository.save(client);
}

async function seedLocations(connection, client)[]> {
  const locationRepository = getRepository(Location);
  const locations[] = [];

  for (let i = 0; i < 15; i++) {
    const location = locationRepository.create({
      name: `${faker.address.city()} Branch`,
      address.address.streetAddress(),
      city.address.city(),
      state.address.state(),
      zipCode.address.zipCode(),
      phoneNumber.phone.phoneNumber(),
      email.internet.email(),
      latitude(faker.address.latitude()),
      longitude(faker.address.longitude()),
      client,
      isDropoffSite.datatype.boolean(),
    });
    locations.push(await locationRepository.save(location));

    if (location.isDropoffSite) {
      await seedDropOffLocations(connection, location);
    }
  }

  return locations;
}

async function seedDropOffLocations(connection, parentLocation) {
  const dropOffLocationRepository = getRepository(DropOffLocation);
  const dropOffTimeRepository = getRepository(DropOffTime);

  for (let i = 0; i < faker.datatype.number({ min: 1, max: 3 }); i++) {
    const dropOffLocation = dropOffLocationRepository.create({
      name: `${faker.company.companyName()} Drop-off`,
      address.address.streetAddress(),
      city.address.city(),
      state.address.state(),
      zipCode.address.zipCode(),
      parentLocation,
    });
    const savedDropOffLocation = await dropOffLocationRepository.save(dropOffLocation);

    for (let j = 0; j < faker.datatype.number({ min: 1, max: 5 }); j++) {
      const dropOffTime = dropOffTimeRepository.create({
        time.date.future().toTimeString().slice(0, 5),
        dropOffLocation,
      });
      await dropOffTimeRepository.save(dropOffTime);
    }
  }
}

async function seedMenuItems(connection, client)[]> {
  const menuItemRepository = getRepository(MenuItem);
  const menuItems[] = [];

  const categories = ['Appetizers', 'Main Courses', 'Desserts', 'Drinks'];

  for (let i = 0; i < 50; i++) {
    const menuItem = menuItemRepository.create({
      name.commerce.productName(),
      description.lorem.sentence(),
      price(faker.commerce.price()),
      category.random.arrayElement(categories),
      client,
    });
    menuItems.push(await menuItemRepository.save(menuItem));
  }

  return menuItems;
}

// ... (implement other seeding functions, seedLoyaltyRewards, seedDiscounts, seedOrders, seedAuditLog)

================
File: src/seeders/YYYYMMDDHHMMSS-seed-enterprise-client.js
================
'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
    // Seed Client
    const [client] = await queryInterface.bulkInsert('Clients', [{
      name: 'Enterprise Foods Inc.',
      createdAt: new Date(),
      updatedAt: new Date()
    }], { returning: true });

    // Seed ClientBranding
    await queryInterface.bulkInsert('ClientBrandings', [{
      clientId: client.id,
      logo: 'https://example.com/logo.png',
      favicon: 'https://example.com/favicon.ico',
      primaryColor: '#1976D2',
      secondaryColor: '#424242',
      accentColor: '#82B1FF',
      fontFamily: 'Roboto, sans-serif',
      buttonStyle: 'rounded',
      headerStyle: 'centered',
      footerContent: ' 2023 Enterprise Foods Inc. All rights reserved.',
      createdAt: new Date(),
      updatedAt: new Date()
    }]);

    // Seed ClientFeatures
    await queryInterface.bulkInsert('ClientFeatures', [{
      clientId: client.id,
      loyalty: true,
      onlineOrdering: true,
      tableReservations: false,
      createdAt: new Date(),
      updatedAt: new Date()
    }]);

    // Seed Users
    await queryInterface.bulkInsert('Users', [
      {
        clientId: client.id,
        email: 'admin@enterprisefoods.com',
        password: '$2b$10$xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx', // Hashed password
        role: 'admin',
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        clientId: client.id,
        email: 'manager@enterprisefoods.com',
        password: '$2b$10$xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx', // Hashed password
        role: 'manager',
        createdAt: new Date(),
        updatedAt: new Date()
      }
    ]);

    // Seed Locations
    const locations = await queryInterface.bulkInsert('Locations', [
      {
        clientId: client.id,
        name: 'Downtown Branch',
        address: '123 Main St, Metropolis, NY 10001',
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        clientId: client.id,
        name: 'Uptown Branch',
        address: '456 Park Ave, Metropolis, NY 10002',
        createdAt: new Date(),
        updatedAt: new Date()
      }
    ], { returning: true });

    // Seed Menu Items
    const menuItems = await queryInterface.bulkInsert('MenuItems', [
      {
        locationId: locations[0].id,
        name: 'Enterprise Burger',
        description: 'Our signature burger with secret sauce',
        price: 9.99,
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        locationId: locations[0].id,
        name: 'Veggie Delight',
        description: 'Plant-based burger for vegetarians',
        price: 8.99,
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        locationId: locations[1].id,
        name: 'Gourmet Pizza',
        description: 'Artisanal pizza with premium toppings',
        price: 12.99,
        createdAt: new Date(),
        updatedAt: new Date()
      }
    ], { returning: true });

    // Seed Modifiers
    await queryInterface.bulkInsert('Modifiers', [
      {
        menuItemId: menuItems[0].id,
        name: 'Extra Cheese',
        price: 1.00,
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        menuItemId: menuItems[0].id,
        name: 'Bacon',
        price: 1.50,
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        menuItemId: menuItems[2].id,
        name: 'Gluten-Free Crust',
        price: 2.00,
        createdAt: new Date(),
        updatedAt: new Date()
      }
    ]);

    // Seed POS Settings
    await queryInterface.bulkInsert('POSSettings', [
      {
        clientId: client.id,
        modifierSendMethod: 'list',
        createdAt: new Date(),
        updatedAt: new Date()
      }
    ]);

    // Seed A/B Tests
    await queryInterface.bulkInsert('ABTests', [
      {
        clientId: client.id,
        name: 'Burger Name Test',
        description: 'Testing different names for our signature burger',
        status: 'active',
        startDate: new Date(),
        endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days from now
        variantA: 'Enterprise Burger',
        variantB: 'Signature Deluxe Burger',
        createdAt: new Date(),
        updatedAt: new Date()
      }
    ]);
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.bulkDelete('ABTests', null, {});
    await queryInterface.bulkDelete('POSSettings', null, {});
    await queryInterface.bulkDelete('Modifiers', null, {});
    await queryInterface.bulkDelete('MenuItems', null, {});
    await queryInterface.bulkDelete('Locations', null, {});
    await queryInterface.bulkDelete('Users', null, {});
    await queryInterface.bulkDelete('ClientFeatures', null, {}); // Add this line
    await queryInterface.bulkDelete('ClientBrandings', null, {});
    await queryInterface.bulkDelete('Clients', null, {});
  }
};

================
File: src/services/integrations/basePosService.js
================
const { MenuItem, Order, InventoryItem } = require('../../models');

class BasePosService {
  constructor(coreProfile, locationProfile) {
    this.coreProfile = coreProfile;
    this.locationProfile = locationProfile;
  }

  async processAndSaveMenuItems(menuItems) {
    for (const item of menuItems) {
      await MenuItem.upsert({
        externalId: item.id,
        name: item.name,
        description: item.description,
        price: item.price,
        locationId: this.locationProfile.id,
      });
    }
  }

  async processAndSaveOrders(orders) {
    for (const order of orders) {
      await Order.upsert({
        externalId: order.id,
        total: order.total,
        status: order.status,
        createdAt: order.createdAt,
        locationId: this.locationProfile.id,
      });
    }
  }

  async processAndSaveInventory(inventoryItems) {
    for (const item of inventoryItems) {
      await InventoryItem.upsert({
        externalId: item.id,
        name: item.name,
        quantity: item.quantity,
        locationId: this.locationProfile.id,
      });
    }
  }
}

module.exports = BasePosService;

================
File: src/services/integrations/brinkService.js
================
const BasePosService = require('./basePosService');
const axios = require('axios');
const rateLimit = require('axios-rate-limit');
const pRetry = require('p-retry');

class BrinkService extends BasePosService {
  constructor(coreProfile, locationProfile) {
    super(coreProfile, locationProfile);
    this.api = rateLimit(axios.create({
      baseURL: this.coreProfile.apiEndpoint,
      headers: { 
        'X-API-Key': this.coreProfile.apiKey,
        'Content-Type': 'application/json',
      },
    }), { maxRequests: 5, perMilliseconds: 1000 });
  }

  async syncMenuItems() {
    try {
      const fetchMenuItems = async (page = 1) => {
        const response = await this.api.get(`/api/v1/menu?page=${page}`);
        return response.data;
      };

      let allMenuItems = [];
      let page = 1;
      let hasMore = true;

      while (hasMore) {
        const data = await pRetry(() => fetchMenuItems(page), { retries: 3 });
        allMenuItems = allMenuItems.concat(data.items);
        hasMore = data.hasNextPage;
        page++;
      }

      await this.processAndSaveMenuItems(allMenuItems);
      console.log(`Synced ${allMenuItems.length} menu items from Brink`);
    } catch (error) {
      console.error('Error syncing Brink menu items:', error);
      throw error;
    }
  }

  async syncOrders() {
    try {
      const fetchOrders = async (page = 1) => {
        const startDate = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();
        const response = await this.api.get(`/api/v1/orders?start_date=${startDate}&page=${page}`);
        return response.data;
      };

      let allOrders = [];
      let page = 1;
      let hasMore = true;

      while (hasMore) {
        const data = await pRetry(() => fetchOrders(page), { retries: 3 });
        allOrders = allOrders.concat(data.orders);
        hasMore = data.hasNextPage;
        page++;
      }

      await this.processAndSaveOrders(allOrders);
      console.log(`Synced ${allOrders.length} orders from Brink`);
    } catch (error) {
      console.error('Error syncing Brink orders:', error);
      throw error;
    }
  }

  async syncInventory() {
    try {
      const fetchInventory = async (page = 1) => {
        const response = await this.api.get(`/api/v1/inventory?page=${page}`);
        return response.data;
      };

      let allInventoryItems = [];
      let page = 1;
      let hasMore = true;

      while (hasMore) {
        const data = await pRetry(() => fetchInventory(page), { retries: 3 });
        allInventoryItems = allInventoryItems.concat(data.items);
        hasMore = data.hasNextPage;
        page++;
      }

      await this.processAndSaveInventory(allInventoryItems);
      console.log(`Synced ${allInventoryItems.length} inventory items from Brink`);
    } catch (error) {
      console.error('Error syncing Brink inventory:', error);
      throw error;
    }
  }
}

module.exports = BrinkService;

================
File: src/services/integrations/revelService.js
================
const BasePosService = require('./basePosService');
const axios = require('axios');
const rateLimit = require('axios-rate-limit');
const pRetry = require('p-retry');

class RevelService extends BasePosService {
  constructor(coreProfile, locationProfile) {
    super(coreProfile, locationProfile);
    this.api = rateLimit(axios.create({
      baseURL: this.coreProfile.apiEndpoint,
      auth: {
        username: this.coreProfile.settings.username,
        password: this.coreProfile.settings.password,
      },
      headers: { 'Content-Type': 'application/json' },
    }), { maxRequests: 5, perMilliseconds: 1000 });
  }

  async syncMenuItems() {
    try {
      const fetchMenuItems = async (offset = 0) => {
        const response = await this.api.get(`/resources/Product?limit=100&offset=${offset}`);
        return response.data;
      };

      let allMenuItems = [];
      let offset = 0;
      let hasMore = true;

      while (hasMore) {
        const data = await pRetry(() => fetchMenuItems(offset), { retries: 3 });
        allMenuItems = allMenuItems.concat(data.objects);
        hasMore = data.meta.next !== null;
        offset += 100;
      }

      await this.processAndSaveMenuItems(allMenuItems);
      console.log(`Synced ${allMenuItems.length} menu items from Revel`);
    } catch (error) {
      console.error('Error syncing Revel menu items:', error);
      throw error;
    }
  }

  async syncOrders() {
    try {
      const fetchOrders = async (offset = 0) => {
        const startDate = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();
        const response = await this.api.get(`/resources/Order?limit=100&offset=${offset}&created_date__gte=${startDate}`);
        return response.data;
      };

      let allOrders = [];
      let offset = 0;
      let hasMore = true;

      while (hasMore) {
        const data = await pRetry(() => fetchOrders(offset), { retries: 3 });
        allOrders = allOrders.concat(data.objects);
        hasMore = data.meta.next !== null;
        offset += 100;
      }

      await this.processAndSaveOrders(allOrders);
      console.log(`Synced ${allOrders.length} orders from Revel`);
    } catch (error) {
      console.error('Error syncing Revel orders:', error);
      throw error;
    }
  }

  async syncInventory() {
    try {
      const fetchInventory = async (offset = 0) => {
        const response = await this.api.get(`/resources/Inventory?limit=100&offset=${offset}`);
        return response.data;
      };

      let allInventoryItems = [];
      let offset = 0;
      let hasMore = true;

      while (hasMore) {
        const data = await pRetry(() => fetchInventory(offset), { retries: 3 });
        allInventoryItems = allInventoryItems.concat(data.objects);
        hasMore = data.meta.next !== null;
        offset += 100;
      }

      await this.processAndSaveInventory(allInventoryItems);
      console.log(`Synced ${allInventoryItems.length} inventory items from Revel`);
    } catch (error) {
      console.error('Error syncing Revel inventory:', error);
      throw error;
    }
  }
}

module.exports = RevelService;

================
File: src/services/integrations/squareService.js
================
const BasePosService = require('./basePosService');
const { Client, Environment } = require('square');
const pRetry = require('p-retry');

class SquareService extends BasePosService {
  constructor(coreProfile, locationProfile) {
    super(coreProfile, locationProfile);
    this.client = new Client({
      accessToken: this.coreProfile.apiKey,
      environment: Environment.Production, // or Environment.Sandbox for testing
    });
  }

  async syncMenuItems() {
    try {
      const fetchMenuItems = async (cursor) => {
        const response = await this.client.catalogApi.listCatalog(cursor, 'ITEM');
        return response.result;
      };

      let allMenuItems = [];
      let cursor;
      do {
        const data = await pRetry(() => fetchMenuItems(cursor), { retries: 3 });
        allMenuItems = allMenuItems.concat(data.objects);
        cursor = data.cursor;
      } while (cursor);

      await this.processAndSaveMenuItems(allMenuItems);
      console.log(`Synced ${allMenuItems.length} menu items from Square`);
    } catch (error) {
      console.error('Error syncing Square menu items:', error);
      throw error;
    }
  }

  async syncOrders() {
    try {
      const { ordersApi } = this.client;
      const startDate = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();

      const fetchOrders = async (cursor) => {
        const response = await ordersApi.searchOrders({
          locationIds: [this.locationProfile.settings.squareLocationId],
          query: {
            filter: {
              dateTimeFilter: {
                createdAt: {
                  startAt: startDate,
                },
              },
            },
          },
          cursor: cursor,
        });
        return response.result;
      };

      let allOrders = [];
      let cursor;
      do {
        const data = await pRetry(() => fetchOrders(cursor), { retries: 3 });
        allOrders = allOrders.concat(data.orders || []);
        cursor = data.cursor;
      } while (cursor);

      await this.processAndSaveOrders(allOrders);
      console.log(`Synced ${allOrders.length} orders from Square`);
    } catch (error) {
      console.error('Error syncing Square orders:', error);
      throw error;
    }
  }

  async syncInventory() {
    try {
      const fetchInventory = async (cursor) => {
        const response = await this.client.inventoryApi.retrieveInventoryCounts({
          locationIds: [this.locationProfile.settings.squareLocationId],
          cursor: cursor,
        });
        return response.result;
      };

      let allInventoryItems = [];
      let cursor;
      do {
        const data = await pRetry(() => fetchInventory(cursor), { retries: 3 });
        allInventoryItems = allInventoryItems.concat(data.counts || []);
        cursor = data.cursor;
      } while (cursor);

      await this.processAndSaveInventory(allInventoryItems);
      console.log(`Synced ${allInventoryItems.length} inventory items from Square`);
    } catch (error) {
      console.error('Error syncing Square inventory:', error);
      throw error;
    }
  }
}

module.exports = SquareService;

================
File: src/services/integrations/toastService.js
================
const BasePosService = require('./basePosService');
const axios = require('axios');
const rateLimit = require('axios-rate-limit');
const pRetry = require('p-retry');

class ToastService extends BasePosService {
  constructor(coreProfile, locationProfile) {
    super(coreProfile, locationProfile);
    this.api = rateLimit(axios.create({
      baseURL: this.coreProfile.apiEndpoint,
      headers: { 
        'Authorization': `Bearer ${this.coreProfile.apiKey}`,
        'Content-Type': 'application/json',
      },
    }), { maxRequests: 5, perMilliseconds: 1000 });
  }

  async syncMenuItems() {
    try {
      const fetchMenuItems = async (page = 1) => {
        const response = await this.api.get(`/v2/menus?page=${page}`);
        return response.data;
      };

      let allMenuItems = [];
      let page = 1;
      let hasMore = true;

      while (hasMore) {
        const data = await pRetry(() => fetchMenuItems(page), { retries: 3 });
        allMenuItems = allMenuItems.concat(data.items);
        hasMore = data.hasMore;
        page++;
      }

      await this.processAndSaveMenuItems(allMenuItems);
      console.log(`Synced ${allMenuItems.length} menu items from Toast`);
    } catch (error) {
      console.error('Error syncing Toast menu items:', error);
      throw error;
    }
  }

  async syncOrders() {
    try {
      const fetchOrders = async (page = 1) => {
        const startDate = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();
        const response = await this.api.get(`/v2/orders?startDate=${startDate}&page=${page}`);
        return response.data;
      };

      let allOrders = [];
      let page = 1;
      let hasMore = true;

      while (hasMore) {
        const data = await pRetry(() => fetchOrders(page), { retries: 3 });
        allOrders = allOrders.concat(data.orders);
        hasMore = data.hasMore;
        page++;
      }

      await this.processAndSaveOrders(allOrders);
      console.log(`Synced ${allOrders.length} orders from Toast`);
    } catch (error) {
      console.error('Error syncing Toast orders:', error);
      throw error;
    }
  }

  async syncInventory() {
    try {
      const fetchInventory = async (page = 1) => {
        const response = await this.api.get(`/v2/inventory/items?page=${page}`);
        return response.data;
      };

      let allInventoryItems = [];
      let page = 1;
      let hasMore = true;

      while (hasMore) {
        const data = await pRetry(() => fetchInventory(page), { retries: 3 });
        allInventoryItems = allInventoryItems.concat(data.items);
        hasMore = data.hasMore;
        page++;
      }

      await this.processAndSaveInventory(allInventoryItems);
      console.log(`Synced ${allInventoryItems.length} inventory items from Toast`);
    } catch (error) {
      console.error('Error syncing Toast inventory:', error);
      throw error;
    }
  }
}

module.exports = ToastService;

================
File: src/services/abTestMetricsService.js
================
const { ABTestMetric } = require '../models/ABTestMetric';
const { AppError } = require '../utils/errorHandler';

const trackABTestMetric = async (testId, variant: 'A' | 'B', metricType, value) => {
  const metric = await ABTestMetric.create({
    testId,
    variant,
    metricType,
    value,
  });
  return metric;
};

const getABTestMetrics = async (testId) => {
  const metrics = await ABTestMetric.findAll({
    where: { testId },
    group: ['variant', 'metricType'],
    attributes: [
      'variant',
      'metricType',
      [sequelize.fn('AVG', sequelize.col('value')), 'averageValue'],
      [sequelize.fn('COUNT', sequelize.col('id')), 'count'],
    ],
  });
  return metrics;
};

================
File: src/services/abTestService.js
================
const { ABTest, ABTestVariant, ABTestMetric } = require('../models');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const createABTest = async (testData) => {
  try {
    const abTest = await ABTest.create(testData, {
      include: [{ model: ABTestVariant, as: 'variants' }]
    });
    logger.info(`A/B Test created with ID: ${abTest.id}`);
    return abTest;
  } catch (error) {
    logger.error('Error creating A/B Test:', error);
    throw new AppError('Failed to create A/B Test', 500);
  }
};

const getABTest = async (id) => {
  try {
    const abTest = await ABTest.findByPk(id, {
      include: [{ model: ABTestVariant, as: 'variants' }]
    });
    if (!abTest) {
      throw new AppError('A/B Test not found', 404);
    }
    return abTest;
  } catch (error) {
    logger.error(`Error fetching A/B Test with ID ${id}:`, error);
    throw error;
  }
};

const updateABTest = async (id, updateData) => {
  try {
    const abTest = await getABTest(id);
    const updatedTest = await abTest.update(updateData);
    logger.info(`A/B Test updated with ID: ${id}`);
    return updatedTest;
  } catch (error) {
    logger.error(`Error updating A/B Test with ID ${id}:`, error);
    throw error;
  }
};

const deleteABTest = async (id) => {
  try {
    const abTest = await getABTest(id);
    await abTest.destroy();
    logger.info(`A/B Test deleted with ID: ${id}`);
  } catch (error) {
    logger.error(`Error deleting A/B Test with ID ${id}:`, error);
    throw error;
  }
};

const getABTestResults = async (id) => {
  try {
    const metrics = await ABTestMetric.findAll({
      where: { abTestId: id },
      include: [{ model: ABTestVariant, as: 'variant' }]
    });
    return metrics;
  } catch (error) {
    logger.error(`Error fetching A/B Test results for ID ${id}:`, error);
    throw new AppError('Failed to fetch A/B Test results', 500);
  }
};

const startABTest = async (id) => {
  try {
    const abTest = await getABTest(id);
    await abTest.update({ status: 'RUNNING', startDate: new Date() });
    logger.info(`A/B Test started with ID: ${id}`);
    return abTest;
  } catch (error) {
    logger.error(`Error starting A/B Test with ID ${id}:`, error);
    throw error;
  }
};

const stopABTest = async (id) => {
  try {
    const abTest = await getABTest(id);
    await abTest.update({ status: 'COMPLETED', endDate: new Date() });
    logger.info(`A/B Test stopped with ID: ${id}`);
    return abTest;
  } catch (error) {
    logger.error(`Error stopping A/B Test with ID ${id}:`, error);
    throw error;
  }
};

const recordMetric = async (abTestId, variantId, metricName, metricValue) => {
  try {
    const metric = await ABTestMetric.create({
      abTestId,
      variantId,
      metricName,
      metricValue
    });
    logger.info(`Metric recorded for A/B Test ID: ${abTestId}, Variant ID: ${variantId}`);
    return metric;
  } catch (error) {
    logger.error(`Error recording metric for A/B Test ID: ${abTestId}:`, error);
    throw new AppError('Failed to record metric', 500);
  }
};

module.exports = {
  createABTest,
  getABTest,
  updateABTest,
  deleteABTest,
  getABTestResults,
  startABTest,
  stopABTest,
  recordMetric
};

================
File: src/services/adminService.js
================
const { User } = require('../models');
const logger = require('../utils/logger');
const { AppError } = require('../utils/errorHandler');

const getUsers = async (query) => {
  try {
    const users = await User.findAll({
      where: query,
      attributes: { exclude: ['password'] }
    });
    return users;
  } catch (error) {
    logger.error('Error fetching users:', error);
    throw new AppError('Error fetching users', 500);
  }
};

const createUser = async (userData) => {
  try {
    const newUser = await User.create(userData);
    return newUser;
  } catch (error) {
    logger.error('Error creating user:', error);
    throw new AppError('Error creating user', 500);
  }
};

const updateUser = async (userId, userData) => {
  try {
    const user = await User.findByPk(userId);
    if (!user) {
      throw new AppError('User not found', 404);
    }
    const updatedUser = await user.update(userData);
    return updatedUser;
  } catch (error) {
    logger.error(`Error updating user ${userId}:`, error);
    throw new AppError('Error updating user', 500);
  }
};

const deleteUser = async (userId) => {
  try {
    const user = await User.findByPk(userId);
    if (!user) {
      throw new AppError('User not found', 404);
    }
    await user.destroy();
  } catch (error) {
    logger.error(`Error deleting user ${userId}:`, error);
    throw new AppError('Error deleting user', 500);
  }
};

const getSystemLogs = async (query) => {
  // Implement system log retrieval logic
  // This might involve querying a logs table or reading log files
  throw new AppError('System logs retrieval not implemented', 501);
};

const getSystemHealth = async () => {
  // Implement system health check logic
  // This might involve checking database connection, API endpoints, etc.
  throw new AppError('System health check not implemented', 501);
};

const backupDatabase = async () => {
  // Implement database backup logic
  throw new AppError('Database backup not implemented', 501);
};

const restoreDatabase = async (backupId) => {
  // Implement database restore logic
  throw new AppError('Database restore not implemented', 501);
};

module.exports = {
  getUsers,
  createUser,
  updateUser,
  deleteUser,
  getSystemLogs,
  getSystemHealth,
  backupDatabase,
  restoreDatabase
};

================
File: src/services/analyticsService.js
================
const { Order, User, MenuItem } = require('../models');
const { Op } = require('sequelize');

const getRevenueData = async (startDate, endDate) => {
  const revenue = await Order.sum('total', {
    where: {
      createdAt: {
        [Op.between]: [startDate, endDate]
      }
    }
  });

  return { revenue };
};

const getCustomerMetrics = async () => {
  const totalCustomers = await User.count();
  const newCustomers = await User.count({
    where: {
      createdAt: {
        [Op.gte]: new Date(new Date().setDate(new Date().getDate() - 30))
      }
    }
  });

  return { totalCustomers, newCustomers };
};

const getRealtimeMetrics = async () => {
  const currentDate = new Date();
  const startOfDay = new Date(currentDate.setHours(0,0,0,0));

  const ordersToday = await Order.count({
    where: {
      createdAt: {
        [Op.gte]: startOfDay
      }
    }
  });

  const revenueToday = await Order.sum('total', {
    where: {
      createdAt: {
        [Op.gte]: startOfDay
      }
    }
  });

  const topSellingItems = await MenuItem.findAll({
    attributes: [
      'id',
      'name',
      [sequelize.fn('SUM', sequelize.col('OrderItems.quantity')), 'totalSold']
    ],
    include: [{
      model: OrderItem,
      attributes: [],
      where: {
        createdAt: {
          [Op.gte]: startOfDay
        }
      }
    }],
    group: ['MenuItem.id'],
    order: [[sequelize.literal('totalSold'), 'DESC']],
    limit: 5
  });

  return {
    ordersToday,
    revenueToday,
    topSellingItems
  };
};

module.exports = {
  getRevenueData,
  getCustomerMetrics,
  getRealtimeMetrics
};

================
File: src/services/analyticsService.Js
================
import { Order, Customer, Product } from '../models';
import { Op, Sequelize } from 'sequelize';
import { redisClient } from '../config/redis';

export const getRevenueData = async (startDate: Date, endDate: Date) => {
  const cacheKey = `revenue:${startDate.toISOString()}:${endDate.toISOString()}`;
  const cachedData = await redisClient.get(cacheKey);

  if (cachedData) {
    return JSON.parse(cachedData);
  }

  const revenue = await Order.findAll({
    where: {
      createdAt: {
        [Op.between]: [startDate, endDate]
      }
    },
    attributes: [
      [Sequelize.fn('date', Sequelize.col('createdAt')), 'date'],
      [Sequelize.fn('sum', Sequelize.col('total')), 'amount']
    ],
    group: [Sequelize.fn('date', Sequelize.col('createdAt'))],
    order: [[Sequelize.fn('date', Sequelize.col('createdAt')), 'ASC']]
  });

  await redisClient.set(cacheKey, JSON.stringify(revenue), 'EX', 3600); // Cache for 1 hour

  return revenue;
};

export const getCustomerMetrics = async () => {
  const cacheKey = 'customer_metrics';
  const cachedData = await redisClient.get(cacheKey);

  if (cachedData) {
    return JSON.parse(cachedData);
  }

  const [totalCustomers, newCustomers, repeatCustomers, averageOrderValue] = await Promise.all([
    Customer.count(),
    Customer.count({
      where: {
        createdAt: {
          [Op.gte]: new Date(new Date().setDate(new Date().getDate() - 30))
        }
      }
    }),
    Order.count({
      distinct: true,
      col: 'customerId',
      where: {
        createdAt: {
          [Op.gte]: new Date(new Date().setDate(new Date().getDate() - 30))
        }
      },
      having: Sequelize.literal('COUNT(DISTINCT(createdAt)) > 1')
    }),
    Order.findOne({
      attributes: [[Sequelize.fn('AVG', Sequelize.col('total')), 'averageOrderValue']],
      raw: true
    })
  ]);

  const metrics = {
    totalCustomers,
    newCustomers,
    repeatCustomers,
    averageOrderValue: averageOrderValue?.averageOrderValue || 0
  };

  await redisClient.set(cacheKey, JSON.stringify(metrics), 'EX', 300); // Cache for 5 minutes

  return metrics;
};

export const getRealtimeMetricsData = async () => {
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  const [todaySales, todayOrders, newGuests, returningGuests, mostPopularItem] = await Promise.all([
    Order.sum('total', { where: { createdAt: { [Op.gte]: today } } }),
    Order.count({ where: { createdAt: { [Op.gte]: today } } }),
    Customer.count({ where: { createdAt: { [Op.gte]: today } } }),
    Order.count({
      distinct: true,
      col: 'customerId',
      where: {
        createdAt: { [Op.gte]: today },
        '$customer.createdAt$': { [Op.lt]: today }
      },
      include: [{ model: Customer, attributes: [] }]
    }),
    Product.findOne({
      attributes: ['name'],
      include: [{
        model: Order,
        attributes: [],
        where: { createdAt: { [Op.gte]: today } }
      }],
      order: [[Sequelize.fn('COUNT', Sequelize.col('orders.id')), 'DESC']],
      group: ['Product.id'],
      limit: 1
    })
  ]);

  const averageOrderValue = todayOrders > 0 ? todaySales / todayOrders : 0;

  return {
    todaySales,
    todayOrders,
    averageOrderValue,
    newGuests,
    returningGuests,
    mostPopularItem: mostPopularItem?.name || ''
  };
};

import { Order, MenuItem, User } from '../models';
import { Op } from 'sequelize';

export const generateSalesReport = async (startDate: Date, endDate: Date) => {
  const orders = await Order.findAll({
    where: {
      createdAt: {
        [Op.between]: [startDate, endDate]
      }
    },
    include: [{ model: MenuItem }]
  });

  // Process orders and generate report
  // ...

  return {
    totalSales: orders.reduce((sum, order) => sum + order.total, 0),
    orderCount: orders.length,
    // Add more metrics as needed
  };
};

export const generateForecast = async () => {
  // Implement forecasting logic based on historical data
  // ...
};

================
File: src/services/auditLogService.js
================
const { AuditLog, Op } = require('../models');
const logger = require('../logger');

// Function to create an audit log entry
exports.createAuditLog = async (action, details, userId) => {
  try {
    // Log using Winston
    logger.info(`Action: ${action}, Details: ${JSON.stringify(details)}, User ID: ${userId}`);
    
    // Create the audit log entry in the database
    await AuditLog.create({ action, details, userId });
  } catch (error) {
    logger.error(`Error creating audit log: ${error.message}`);
  }
};

// Function to fetch audit logs with optional filters
exports.fetchAuditLogs = async (filters) => {
  try {
    const whereClause = {};

    // Apply filters for userId, action, and date range
    if (filters.userId) whereClause.userId = filters.userId;
    if (filters.action) whereClause.action = filters.action;
    if (filters.dateRangeStart && filters.dateRangeEnd) {
      whereClause.timestamp = {
        [Op.between]: [filters.dateRangeStart, filters.dateRangeEnd],
      };
    }

    // Fetch the audit logs based on filters
    return await AuditLog.findAll({ where: whereClause, order: [['timestamp', 'DESC']] });
  } catch (error) {
    logger.error(`Error fetching audit logs: ${error.message}`);
    throw new Error('Error fetching audit logs');
  }
};

================
File: src/services/authService.js
================
const speakeasy = require 'speakeasy';
const { User } = require '../models';

const generateTwoFactorSecret = () => {
  return speakeasy.generateSecret({ length: 32 });
};

const verifyTwoFactor = (token, secret) => {
  return speakeasy.totp.verify({
    secret,
    encoding: 'base32',
    token,
  });
};

const enableTwoFactor = async (userId, secret) => {
  await User.update({ twoFactorSecret, twoFactorEnabled }, { where: { id } });
};

const disableTwoFactor = async (userId) => {
  await User.update({ twoFactorSecret, twoFactorEnabled }, { where: { id } });
};

================
File: src/services/brandingService.js
================
const { BrandingProfile } = require('../models');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const getBrandingProfiles = async (clientId) => {
  if (!clientId) {
    throw new AppError('Client ID is required', 400);
  }
  return await BrandingProfile.findAll({ where: { clientId } });
};

const getBrandingProfileById = async (id) => {
  if (!id) {
    throw new AppError('Profile ID is required', 400);
  }
  const profile = await BrandingProfile.findByPk(id);
  if (!profile) {
    throw new AppError('Branding profile not found', 404);
  }
  return profile;
};

const createBrandingProfile = async (profileData) => {
  if (!profileData || !profileData.clientId) {
    throw new AppError('Invalid profile data', 400);
  }
  try {
    return await BrandingProfile.create(profileData);
  } catch (error) {
    logger.error('Error creating branding profile:', error);
    throw new AppError('Failed to create branding profile', 500);
  }
};

const updateBrandingProfile = async (id, profileData) => {
  if (!id || !profileData) {
    throw new AppError('Invalid update data', 400);
  }
  const profile = await getBrandingProfileById(id);
  try {
    return await profile.update(profileData);
  } catch (error) {
    logger.error(`Error updating branding profile ${id}:`, error);
    throw new AppError('Failed to update branding profile', 500);
  }
};

const deleteBrandingProfile = async (id) => {
  if (!id) {
    throw new AppError('Profile ID is required', 400);
  }
  const profile = await getBrandingProfileById(id);
  try {
    await profile.destroy();
  } catch (error) {
    logger.error(`Error deleting branding profile ${id}:`, error);
    throw new AppError('Failed to delete branding profile', 500);
  }
};

module.exports = {
  getBrandingProfiles,
  getBrandingProfileById,
  createBrandingProfile,
  updateBrandingProfile,
  deleteBrandingProfile
};

================
File: src/services/campaignResultService.js
================
const { CampaignResult } = require('../models');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const getAllCampaignResults = async () => {
  return await CampaignResult.findAll();
};

const getCampaignResultById = async (id) => {
  return await CampaignResult.findByPk(id);
};

const createCampaignResult = async (data) => {
  return await CampaignResult.create(data);
};

const updateCampaignResult = async (id, data) => {
  const result = await CampaignResult.findByPk(id);
  if (!result) {
    return null;
  }
  return await result.update(data);
};

const deleteCampaignResult = async (id) => {
  const result = await CampaignResult.findByPk(id);
  if (!result) {
    return false;
  }
  await result.destroy();
  return true;
};

module.exports = {
  getAllCampaignResults,
  getCampaignResultById,
  createCampaignResult,
  updateCampaignResult,
  deleteCampaignResult
};

================
File: src/services/cartService.js
================
const Cart = require('../models/Cart');
const DiscountService = require('./DiscountService');
const LoyaltyService = require('./LoyaltyService');

class CartService {
  static async calculateCart(cartId) {
    const cart = await Cart.findByPk(cartId, {
      include: ['Items', 'Discounts', 'LoyaltyRewards'],
    });

    let cartTotal = 0;

    // Calculate item totals
    cart.Items.forEach(item => {
      cartTotal += item.price;
      item.Modifiers.forEach(modifier => {
        if (modifier.price > 0) {
          cartTotal += modifier.price;
        }
      });
    });

    // Apply discounts
    cartTotal = await DiscountService.applyDiscounts(cart, cartTotal);

    // Apply loyalty rewards
    cartTotal = await LoyaltyService.applyLoyaltyRewards(cart, cartTotal);

    // Apply service fees, taxes, etc.

    return {
      cartTotal,
      breakdown: {
        items: cart.Items,
        discounts: cart.Discounts,
        loyaltyRewards: cart.LoyaltyRewards,
      },
    };
  }
}

module.exports = CartService;

================
File: src/services/categoryService.js
================
const { Category } = require('../models');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const getAllCategories = async (clientId) => {
  try {
    return await Category.findAll({ where: { clientId } });
  } catch (error) {
    logger.error('Error fetching all categories:', error);
    throw new AppError('Failed to fetch categories', 500);
  }
};

const getCategoryById = async (id, clientId) => {
  try {
    const category = await Category.findOne({ where: { id, clientId } });
    if (!category) {
      throw new AppError('Category not found', 404);
    }
    return category;
  } catch (error) {
    logger.error(`Error fetching category with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to fetch category', 500);
  }
};

const createCategory = async (categoryData, clientId) => {
  try {
    const newCategory = await Category.create({ ...categoryData, clientId });
    logger.info(`New category created with ID: ${newCategory.id}`);
    return newCategory;
  } catch (error) {
    logger.error('Error creating category:', error);
    throw new AppError('Failed to create category', 500);
  }
};

const updateCategory = async (id, categoryData, clientId) => {
  try {
    const category = await getCategoryById(id, clientId);
    const updatedCategory = await category.update(categoryData);
    logger.info(`Category updated with ID: ${id}`);
    return updatedCategory;
  } catch (error) {
    logger.error(`Error updating category with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to update category', 500);
  }
};

const deleteCategory = async (id, clientId) => {
  try {
    const category = await getCategoryById(id, clientId);
    await category.destroy();
    logger.info(`Category deleted with ID: ${id}`);
    return true;
  } catch (error) {
    logger.error(`Error deleting category with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to delete category', 500);
  }
};

module.exports = {
  getAllCategories,
  getCategoryById,
  createCategory,
  updateCategory,
  deleteCategory
};

================
File: src/services/cateringOrderService.js
================
const db = require('../models');
const logger = require('../services/logger');
const TaxService = require('./taxService');
const PaymentService = require('./paymentService');
const LoyaltyService = require('./loyaltyService'); // In case loyalty points are involved

class CateringOrderService {
  // Calculate the total price for a catering order
  calculateOrderTotal(items, fees = {}, tips = {}) {
    const itemTotal = items.reduce((sum, item) => sum + item.price * item.quantity, 0);

    // Calculate fees and tips
    const serviceFee = fees.serviceFee || 0;
    const packagingFee = fees.packagingFee || 0;
    const deliveryFee = fees.deliveryFee || 0;
    const kitchenTip = tips.kitchenTip || 0;
    const driverTip = tips.driverTip || 0;

    // Calculate the grand total
    const total = itemTotal + serviceFee + packagingFee + deliveryFee + kitchenTip + driverTip;

    return parseFloat(total.toFixed(2));
  }

  // Create a new catering order with all logic
  async createCateringOrder(orderData) {
    try {
      const {
        guestId,
        houseAccountId,
        orderDate,
        scheduledDate,
        locationId,
        items,
        fees,
        tips,
        provider,
      } = orderData;

      // Fetch applicable tax using the TaxService
      const taxDetails = await TaxService.getApplicableTax(locationId, provider, guestId);

      // Calculate the subtotal and then the total with tax
      const subtotal = this.calculateOrderTotal(items, fees, tips);
      const totalWithTax = subtotal + (subtotal * taxDetails.rate) / 100;

      // Handle loyalty points if applicable
      if (orderData.loyaltyPointsUsed) {
        await LoyaltyService.deductPoints(guestId, orderData.loyaltyPointsUsed);
      }

      // Create the catering order
      const order = await db.CateringOrder.create({
        guestId,
        houseAccountId,
        orderDate,
        scheduledDate,
        totalPrice: totalWithTax,
        orderDetails: items,
        taxExempt: taxDetails.rate === 0,
        taxIdNumber: taxDetails.taxId,
      });

      // Handle payment if required
      if (orderData.paymentData) {
        await PaymentService.processPayment({
          amount: totalWithTax,
          currency: 'usd', // or another currency
          paymentMethod: orderData.paymentData.paymentMethod,
          guestId,
          locationId,
        });
      }

      logger.info(`Catering order created: ID ${order.id} for guest ID ${guestId}`);
      return order;
    } catch (error) {
      logger.error(`Error creating catering order: ${error.message}`);
      throw new Error('Error creating catering order');
    }
  }

  // Fetch all catering orders by house account
  async getCateringOrdersByHouseAccount(houseAccountId) {
    try {
      const orders = await db.CateringOrder.findAll({
        where: { houseAccountId },
      });
      return orders;
    } catch (error) {
      logger.error(`Error fetching catering orders for house account ID ${houseAccountId}: ${error.message}`);
      throw new Error('Error fetching catering orders');
    }
  }

  // Fetch all catering orders by guest
  async getCateringOrdersByGuest(guestId) {
    try {
      const orders = await db.CateringOrder.findAll({
        where: { guestId },
      });
      return orders;
    } catch (error) {
      logger.error(`Error fetching catering orders for guest ID ${guestId}: ${error.message}`);
      throw new Error('Error fetching catering orders');
    }
  }

  // Handle catering order invoicing
  async handleCateringInvoicing(orderId) {
    try {
      const order = await db.CateringOrder.findByPk(orderId);
      if (!order) throw new Error('Catering order not found');

      // Invoicing logic: calculate invoice total, apply discounts, etc.
      const invoiceTotal = order.totalPrice; // Can be extended to handle discounts and additional charges

      logger.info(`Catering invoicing processed for order ID ${orderId}`);
      return { success: true, message: 'Invoicing processed successfully', invoiceTotal };
    } catch (error) {
      logger.error(`Error handling catering invoicing for order ID ${orderId}: ${error.message}`);
      throw new Error('Error handling catering invoicing');
    }
  }
}

module.exports = new CateringOrderService();

================
File: src/services/cateringService.js
================
const db = require('../models');
const { Op } = require('sequelize');
const logger = require('../utils/logger');

class CateringService {
  // Function to schedule future catering orders
  static async scheduleCateringOrder(orderData) {
    try {
      const cateringOrder = await db.CateringOrder.create(orderData);
      logger.info(`Catering order scheduled successfully. Order ID: ${cateringOrder.id}`);
      return cateringOrder;
    } catch (error) {
      logger.error('Error scheduling catering order:', error);
      throw error;
    }
  }

  // Function to retrieve all scheduled catering orders within a given time range
  static async getScheduledOrders(startDate, endDate) {
    try {
      const orders = await db.CateringOrder.findAll({
        where: {
          scheduledDate: {
            [Op.between]: [startDate, endDate],
          },
        },
        include: [{ model: db.Guest }],
      });
      logger.info(`Retrieved ${orders.length} scheduled catering orders.`);
      return orders;
    } catch (error) {
      logger.error('Error fetching scheduled catering orders:', error);
      throw error;
    }
  }

  // Function to handle cancellations with notice period enforcement
  static async cancelCateringOrder(orderId, noticeHours = 24) {
    try {
      const order = await db.CateringOrder.findByPk(orderId);
      if (!order) {
        throw new Error('Order not found');
      }

      const now = new Date();
      const scheduledTime = new Date(order.scheduledDate);
      const timeDifference = (scheduledTime - now) / (1000 * 60 * 60); // Convert to hours

      if (timeDifference < noticeHours) {
        throw new Error(`Cannot cancel. Orders require a minimum of ${noticeHours} hours notice.`);
      }

      await order.destroy();
      logger.info(`Catering order ID ${orderId} cancelled successfully.`);
      return { message: 'Order cancelled successfully' };
    } catch (error) {
      logger.error(`Error cancelling catering order ID ${orderId}:`, error);
      throw error;
    }
  }

  // Function to process scheduled catering orders
  static async handleScheduledOrders() {
    try {
      const orders = await db.CateringOrder.findAll({
        where: {
          status: 'scheduled',
          scheduledDate: { [Op.lte]: new Date() },
        },
      });

      for (const order of orders) {
        // Logic to mark the order as "in-progress"
        order.status = 'in-progress';
        await order.save();

        // Trigger necessary preparations (e.g., kitchen, delivery, etc.)
        logger.info(`Processing scheduled catering order: Order ID ${order.id}`);

        // Mark the order as "completed"
        order.status = 'completed';
        await order.save();

        logger.info(`Catering order ID ${order.id} completed.`);
      }
    } catch (error) {
      logger.error('Error handling scheduled catering orders:', error);
      throw error;
    }
  }
}

module.exports = CateringService;

================
File: src/services/checkoutService.js
================
const { Order, OrderItem, Coupon } = require('../models');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const initializeCheckout = async (checkoutData, clientId) => {
  try {
    // Implement checkout initialization logic
    // This might involve creating a temporary order or checkout session
    logger.info(`Checkout initialized for client: ${clientId}`);
    return { checkoutId: 'temp-id', ...checkoutData };
  } catch (error) {
    logger.error('Error initializing checkout:', error);
    throw new AppError('Failed to initialize checkout', 500);
  }
};

const processPayment = async (paymentData, clientId) => {
  try {
    // Implement payment processing logic
    // This might involve calling a payment gateway
    logger.info(`Payment processed for client: ${clientId}`);
    return { success: true, transactionId: 'mock-transaction-id' };
  } catch (error) {
    logger.error('Error processing payment:', error);
    throw new AppError('Failed to process payment', 500);
  }
};

const confirmOrder = async (orderData, clientId) => {
  try {
    // Implement order confirmation logic
    const order = await Order.create({ ...orderData, clientId });
    logger.info(`Order confirmed for client: ${clientId}, Order ID: ${order.id}`);
    return order;
  } catch (error) {
    logger.error('Error confirming order:', error);
    throw new AppError('Failed to confirm order', 500);
  }
};

const getCheckoutStatus = async (checkoutId, clientId) => {
  try {
    // Implement logic to fetch checkout status
    // This might involve querying the database for the current state of the order
    logger.info(`Fetched checkout status for ID: ${checkoutId}, Client: ${clientId}`);
    return { status: 'pending', checkoutId };
  } catch (error) {
    logger.error(`Error fetching checkout status for ID ${checkoutId}:`, error);
    throw new AppError('Failed to fetch checkout status', 500);
  }
};

const applyCoupon = async (checkoutId, couponCode, clientId) => {
  try {
    // Implement coupon application logic
    const coupon = await Coupon.findOne({ where: { code: couponCode, clientId } });
    if (!coupon) {
      throw new AppError('Invalid coupon code', 400);
    }
    logger.info(`Coupon applied to checkout: ${checkoutId}, Client: ${clientId}`);
    return { success: true, discount: coupon.discountAmount };
  } catch (error) {
    logger.error('Error applying coupon:', error);
    throw error instanceof AppError ? error : new AppError('Failed to apply coupon', 500);
  }
};

const removeCoupon = async (checkoutId, clientId) => {
  try {
    // Implement coupon removal logic
    logger.info(`Coupon removed from checkout: ${checkoutId}, Client: ${clientId}`);
    return { success: true };
  } catch (error) {
    logger.error('Error removing coupon:', error);
    throw new AppError('Failed to remove coupon', 500);
  }
};

const updateShippingAddress = async (checkoutId, address, clientId) => {
  try {
    // Implement shipping address update logic
    logger.info(`Shipping address updated for checkout: ${checkoutId}, Client: ${clientId}`);
    return { success: true, updatedAddress: address };
  } catch (error) {
    logger.error('Error updating shipping address:', error);
    throw new AppError('Failed to update shipping address', 500);
  }
};

const getPaymentMethods = async (clientId) => {
  try {
    // Implement logic to fetch available payment methods
    // This might involve querying a database or external payment service
    logger.info(`Fetched payment methods for client: ${clientId}`);
    return ['credit_card', 'paypal', 'apple_pay']; // Example payment methods
  } catch (error) {
    logger.error('Error fetching payment methods:', error);
    throw new AppError('Failed to fetch payment methods', 500);
  }
};

module.exports = {
  initializeCheckout,
  processPayment,
  confirmOrder,
  getCheckoutStatus,
  applyCoupon,
  removeCoupon,
  updateShippingAddress,
  getPaymentMethods
};

================
File: src/services/clientBrandingService.js
================
const ClientBranding = require '../models/ClientBranding';
const { AppError } = require '../utils/errorHandler';

const getClientBranding = async (clientId) => {
  const branding = await ClientBranding.findOne({ where: { clientId } });
  if (!branding) {
    throw new AppError('Client branding not found', 404);
  }
  return branding;
};

const updateClientBranding = async (clientId, brandingData) => {
  const branding = await ClientBranding.findOne({ where: { clientId } });
  if (!branding) {
    throw new AppError('Client branding not found', 404);
  }
  await branding.update(brandingData);
  return branding;
};

================
File: src/services/clientService.js
================
const { Client, ClientSettings } = require('../models');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const getAllClients = async () => {
  try {
    return await Client.findAll();
  } catch (error) {
    logger.error('Error fetching all clients:', error);
    throw new AppError('Failed to fetch clients', 500);
  }
};

const getClientById = async (id) => {
  try {
    const client = await Client.findByPk(id);
    if (!client) {
      throw new AppError('Client not found', 404);
    }
    return client;
  } catch (error) {
    logger.error(`Error fetching client with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to fetch client', 500);
  }
};

const createClient = async (clientData) => {
  try {
    const newClient = await Client.create(clientData);
    logger.info(`New client created with ID: ${newClient.id}`);
    return newClient;
  } catch (error) {
    logger.error('Error creating client:', error);
    throw new AppError('Failed to create client', 500);
  }
};

const updateClient = async (id, clientData) => {
  try {
    const client = await getClientById(id);
    const updatedClient = await client.update(clientData);
    logger.info(`Client updated with ID: ${id}`);
    return updatedClient;
  } catch (error) {
    logger.error(`Error updating client with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to update client', 500);
  }
};

const deleteClient = async (id) => {
  try {
    const client = await getClientById(id);
    await client.destroy();
    logger.info(`Client deleted with ID: ${id}`);
    return true;
  } catch (error) {
    logger.error(`Error deleting client with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to delete client', 500);
  }
};

const getClientSettings = async (clientId) => {
  try {
    const settings = await ClientSettings.findOne({ where: { clientId } });
    if (!settings) {
      throw new AppError('Client settings not found', 404);
    }
    return settings;
  } catch (error) {
    logger.error(`Error fetching settings for client ${clientId}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to fetch client settings', 500);
  }
};

const updateClientSettings = async (clientId, settingsData) => {
  try {
    const [settings, created] = await ClientSettings.findOrCreate({
      where: { clientId },
      defaults: settingsData
    });

    if (!created) {
      await settings.update(settingsData);
    }

    logger.info(`Settings updated for client: ${clientId}`);
    return settings;
  } catch (error) {
    logger.error(`Error updating settings for client ${clientId}:`, error);
    throw new AppError('Failed to update client settings', 500);
  }
};

module.exports = {
  getAllClients,
  getClientById,
  createClient,
  updateClient,
  deleteClient,
  getClientSettings,
  updateClientSettings
};

================
File: src/services/commissaryKitchenService.js
================
const { CommissaryKitchen, Inventory } = require('../models');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const getAllCommissaryKitchens = async (clientId) => {
  try {
    return await CommissaryKitchen.findAll({ where: { clientId } });
  } catch (error) {
    logger.error('Error fetching all commissary kitchens:', error);
    throw new AppError('Failed to fetch commissary kitchens', 500);
  }
};

const getCommissaryKitchenById = async (id, clientId) => {
  try {
    const kitchen = await CommissaryKitchen.findOne({ where: { id, clientId } });
    if (!kitchen) {
      throw new AppError('Commissary kitchen not found', 404);
    }
    return kitchen;
  } catch (error) {
    logger.error(`Error fetching commissary kitchen with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to fetch commissary kitchen', 500);
  }
};

const createCommissaryKitchen = async (kitchenData, clientId) => {
  try {
    const newKitchen = await CommissaryKitchen.create({ ...kitchenData, clientId });
    logger.info(`New commissary kitchen created with ID: ${newKitchen.id}`);
    return newKitchen;
  } catch (error) {
    logger.error('Error creating commissary kitchen:', error);
    throw new AppError('Failed to create commissary kitchen', 500);
  }
};

const updateCommissaryKitchen = async (id, kitchenData, clientId) => {
  try {
    const kitchen = await getCommissaryKitchenById(id, clientId);
    const updatedKitchen = await kitchen.update(kitchenData);
    logger.info(`Commissary kitchen updated with ID: ${id}`);
    return updatedKitchen;
  } catch (error) {
    logger.error(`Error updating commissary kitchen with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to update commissary kitchen', 500);
  }
};

const deleteCommissaryKitchen = async (id, clientId) => {
  try {
    const kitchen = await getCommissaryKitchenById(id, clientId);
    await kitchen.destroy();
    logger.info(`Commissary kitchen deleted with ID: ${id}`);
    return true;
  } catch (error) {
    logger.error(`Error deleting commissary kitchen with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to delete commissary kitchen', 500);
  }
};

const getCommissaryKitchenInventory = async (kitchenId, clientId) => {
  try {
    await getCommissaryKitchenById(kitchenId, clientId); // Ensure kitchen exists
    const inventory = await Inventory.findAll({ where: { commissaryKitchenId: kitchenId } });
    return inventory;
  } catch (error) {
    logger.error(`Error fetching inventory for commissary kitchen ${kitchenId}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to fetch commissary kitchen inventory', 500);
  }
};

const updateCommissaryKitchenInventory = async (kitchenId, inventoryData, clientId) => {
  try {
    await getCommissaryKitchenById(kitchenId, clientId); // Ensure kitchen exists
    const updatedInventory = await Promise.all(
      inventoryData.map(async (item) => {
        const [inventoryItem, created] = await Inventory.findOrCreate({
          where: { commissaryKitchenId: kitchenId, itemId: item.itemId },
          defaults: { ...item, commissaryKitchenId: kitchenId }
        });
        if (!created) {
          await inventoryItem.update(item);
        }
        return inventoryItem;
      })
    );
    logger.info(`Inventory updated for commissary kitchen with ID: ${kitchenId}`);
    return updatedInventory;
  } catch (error) {
    logger.error(`Error updating inventory for commissary kitchen ${kitchenId}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to update commissary kitchen inventory', 500);
  }
};

module.exports = {
  getAllCommissaryKitchens,
  getCommissaryKitchenById,
  createCommissaryKitchen,
  updateCommissaryKitchen,
  deleteCommissaryKitchen,
  getCommissaryKitchenInventory,
  updateCommissaryKitchenInventory
};

================
File: src/services/corePosProfileService.js
================
const { CorePOSProfile, LocationPOSProfile } = require('../models');
const ToastService = require('./integrations/toastService');
const BrinkService = require('./integrations/brinkService');
const RevelService = require('./integrations/revelService');
const SquareService = require('./integrations/squareService');

class CorePosProfileService {
  async getAll() {
    return CorePOSProfile.findAll({ where: { isActive: true } });
  }

  async getById(id) {
    return CorePOSProfile.findByPk(id);
  }

  async create(data) {
    return CorePOSProfile.create(data);
  }

  async update(id, data) {
    const profile = await CorePOSProfile.findByPk(id);
    if (profile) {
      return profile.update(data);
    }
    return null;
  }

  async delete(id) {
    await CorePOSProfile.update({ isActive: false }, { where: { id } });
  }

  async syncLocation(locationProfileId) {
    const locationProfile = await LocationPOSProfile.findByPk(locationProfileId, {
      include: [CorePOSProfile],
    });
    if (!locationProfile) {
      throw new Error('Location POS profile not found');
    }

    const coreProfile = locationProfile.CorePOSProfile;

    let integrationService;
    switch (coreProfile.posType) {
      case 'TOAST':
        integrationService = new ToastService(coreProfile, locationProfile);
        break;
      case 'BRINK':
        integrationService = new BrinkService(coreProfile, locationProfile);
        break;
      case 'REVEL':
        integrationService = new RevelService(coreProfile, locationProfile);
        break;
      case 'SQUARE':
        integrationService = new SquareService(coreProfile, locationProfile);
        break;
      default:
        throw new Error('Unsupported POS type');
    }

    try {
      await locationProfile.update({ lastSyncStatus: 'IN_PROGRESS' });

      await integrationService.syncMenuItems();
      await integrationService.syncOrders();
      await integrationService.syncInventory();
      
      await locationProfile.update({
        lastSyncStatus: 'SUCCESS',
        lastSyncError: null,
        lastSyncTimestamp: new Date(),
      });
    } catch (error) {
      await locationProfile.update({
        lastSyncStatus: 'FAILED',
        lastSyncError: error.message,
        lastSyncTimestamp: new Date(),
      });
      throw error;
    }
  }
}

module.exports = new CorePosProfileService();

================
File: src/services/currencyService.js
================
const axios = require 'axios';

const API_KEY = process.env.CURRENCY_API_KEY;
const BASE_URL = 'https://api.exchangeratesapi.io/latest';

const convertCurrency = async (amount, from, to) => {
  const response = await axios.get(`${BASE_URL}?base=${from}&symbols=${to}&access_key=${API_KEY}`);
  const rate = response.data.rates[to];
  return amount * rate;
};

================
File: src/services/dashboardService.js
================
const { Order, MenuItem } = require('../models');
const { Op } = require('sequelize');
const { io } = require('../socket');

const getDashboardData = async () => {
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  const orders = await Order.findAll({
    where: {
      createdAt: {
        [Op.gte]: today
      }
    },
    include: [{ model: MenuItem }]
  });

  const totalRevenue = orders.reduce((sum, order) => sum + order.total, 0);
  const totalOrders = orders.length;
  const averageOrderValue = totalOrders > 0 ? totalRevenue / totalOrders : 0;

  const itemSales = orders.flatMap(order => 
    order.items.map(item => ({
      name: item.name,
      quantity: item.quantity,
      revenue: item.price * item.quantity
    }))
  );

  const topSellingItems = Object.values(itemSales.reduce((acc, item) => {
    if (!acc[item.name]) {
      acc[item.name] = { name: item.name, quantity: 0, revenue: 0 };
    }
    acc[item.name].quantity += item.quantity;
    acc[item.name].revenue += item.revenue;
    return acc;
  }, {})).sort((a, b) => b.quantity - a.quantity).slice(0, 5);

  const recentOrders = orders
    .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())
    .slice(0, 10)
    .map(order => ({
      id: order.id,
      total: order.total,
      status: order.status
    }));

  return {
    totalRevenue,
    totalOrders,
    averageOrderValue,
    topSellingItems,
    recentOrders
  };
};

const emitDashboardUpdate = async () => {
  const dashboardData = await getDashboardData();
  io.emit('dashboard-update', dashboardData);
};

const emitNewOrder = (order) => {
  io.emit('new-order', {
    id: order.id,
    total: order.total,
    status: order.status
  });
};

module.exports = {
  getDashboardData,
  emitDashboardUpdate,
  emitNewOrder
};

================
File: src/services/deliveryDriverService.js
================
const { DeliveryDriver, Order } = require('../models');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const getAllDeliveryDrivers = async (clientId) => {
  try {
    return await DeliveryDriver.findAll({ where: { clientId } });
  } catch (error) {
    logger.error('Error fetching all delivery drivers:', error);
    throw new AppError('Failed to fetch delivery drivers', 500);
  }
};

const getDeliveryDriverById = async (id, clientId) => {
  try {
    const driver = await DeliveryDriver.findOne({ where: { id, clientId } });
    if (!driver) {
      throw new AppError('Delivery driver not found', 404);
    }
    return driver;
  } catch (error) {
    logger.error(`Error fetching delivery driver with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to fetch delivery driver', 500);
  }
};

const createDeliveryDriver = async (driverData, clientId) => {
  try {
    const newDriver = await DeliveryDriver.create({ ...driverData, clientId });
    logger.info(`New delivery driver created with ID: ${newDriver.id}`);
    return newDriver;
  } catch (error) {
    logger.error('Error creating delivery driver:', error);
    throw new AppError('Failed to create delivery driver', 500);
  }
};

const updateDeliveryDriver = async (id, driverData, clientId) => {
  try {
    const driver = await getDeliveryDriverById(id, clientId);
    const updatedDriver = await driver.update(driverData);
    logger.info(`Delivery driver updated with ID: ${id}`);
    return updatedDriver;
  } catch (error) {
    logger.error(`Error updating delivery driver with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to update delivery driver', 500);
  }
};

const deleteDeliveryDriver = async (id, clientId) => {
  try {
    const driver = await getDeliveryDriverById(id, clientId);
    await driver.destroy();
    logger.info(`Delivery driver deleted with ID: ${id}`);
    return true;
  } catch (error) {
    logger.error(`Error deleting delivery driver with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to delete delivery driver', 500);
  }
};

const getActiveDeliveries = async (driverId, clientId) => {
  try {
    await getDeliveryDriverById(driverId, clientId); // Ensure driver exists
    const activeDeliveries = await Order.findAll({
      where: { driverId, status: 'in_progress', clientId }
    });
    return activeDeliveries;
  } catch (error) {
    logger.error(`Error fetching active deliveries for driver ${driverId}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to fetch active deliveries', 500);
  }
};

const updateDeliveryStatus = async (driverId, deliveryId, status, clientId) => {
  try {
    await getDeliveryDriverById(driverId, clientId); // Ensure driver exists
    const delivery = await Order.findOne({ where: { id: deliveryId, driverId, clientId } });
    if (!delivery) {
      throw new AppError('Delivery not found', 404);
    }
    const updatedDelivery = await delivery.update({ status });
    logger.info(`Delivery status updated for delivery ID: ${deliveryId}`);
    return updatedDelivery;
  } catch (error) {
    logger.error(`Error updating delivery status for delivery ${deliveryId}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to update delivery status', 500);
  }
};

module.exports = {
  getAllDeliveryDrivers,
  getDeliveryDriverById,
  createDeliveryDriver,
  updateDeliveryDriver,
  deleteDeliveryDriver,
  getActiveDeliveries,
  updateDeliveryStatus
};

================
File: src/services/discountService.js
================
const { Discount } = require('../models');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const getAllDiscounts = async (clientId) => {
  try {
    return await Discount.findAll({ where: { clientId } });
  } catch (error) {
    logger.error('Error fetching all discounts:', error);
    throw new AppError('Failed to fetch discounts', 500);
  }
};

const getDiscountById = async (id, clientId) => {
  try {
    const discount = await Discount.findOne({ where: { id, clientId } });
    if (!discount) {
      throw new AppError('Discount not found', 404);
    }
    return discount;
  } catch (error) {
    logger.error(`Error fetching discount with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to fetch discount', 500);
  }
};

const createDiscount = async (discountData, clientId) => {
  try {
    const newDiscount = await Discount.create({ ...discountData, clientId });
    logger.info(`New discount created with ID: ${newDiscount.id}`);
    return newDiscount;
  } catch (error) {
    logger.error('Error creating discount:', error);
    throw new AppError('Failed to create discount', 500);
  }
};

const updateDiscount = async (id, discountData, clientId) => {
  try {
    const discount = await getDiscountById(id, clientId);
    const updatedDiscount = await discount.update(discountData);
    logger.info(`Discount updated with ID: ${id}`);
    return updatedDiscount;
  } catch (error) {
    logger.error(`Error updating discount with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to update discount', 500);
  }
};

const deleteDiscount = async (id, clientId) => {
  try {
    const discount = await getDiscountById(id, clientId);
    await discount.destroy();
    logger.info(`Discount deleted with ID: ${id}`);
    return true;
  } catch (error) {
    logger.error(`Error deleting discount with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to delete discount', 500);
  }
};

const getDiscountsByLocation = async (locationId, clientId) => {
  try {
    return await Discount.findAll({ where: { locationId, clientId } });
  } catch (error) {
    logger.error(`Error fetching discounts for location ${locationId}:`, error);
    throw new AppError('Failed to fetch discounts for location', 500);
  }
};

module.exports = {
  getAllDiscounts,
  getDiscountById,
  createDiscount,
  updateDiscount,
  deleteDiscount,
  getDiscountsByLocation
};

================
File: src/services/DiscountService.js
================
const { Discount } = require('../models');
const discountUtils = require('../utils/discountUtils');

class DiscountService {
  static async createDiscount(discountData) {
    return await Discount.create(discountData);
  }

  static async getDiscountsByLocation(locationId) {
    return await Discount.findAll({
      where: { locationId },
    });
  }

  static async validateAndApplyDiscounts(order, guestId) {
    const applicableDiscounts = await discountUtils.getApplicableDiscounts(order, guestId);
    return discountUtils.applyBestDiscount(applicableDiscounts, order);
  }
}

module.exports = DiscountService;

================
File: src/services/featureManagementService.js
================
const { Feature, ClientFeature } = require('../models');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const getClientFeatures = async (clientId) => {
  try {
    const clientFeatures = await ClientFeature.findAll({
      where: { clientId },
      include: [{ model: Feature, attributes: ['name', 'description'] }]
    });
    return clientFeatures;
  } catch (error) {
    logger.error(`Error fetching features for client ${clientId}:`, error);
    throw new AppError('Failed to fetch client features', 500);
  }
};

const updateClientFeatures = async (clientId, featureUpdates) => {
  try {
    const updatedFeatures = await Promise.all(
      featureUpdates.map(async (update) => {
        const [clientFeature, created] = await ClientFeature.findOrCreate({
          where: { clientId, featureId: update.featureId },
          defaults: { isEnabled: update.isEnabled }
        });
        if (!created) {
          await clientFeature.update({ isEnabled: update.isEnabled });
        }
        return clientFeature;
      })
    );
    return updatedFeatures;
  } catch (error) {
    logger.error(`Error updating features for client ${clientId}:`, error);
    throw new AppError('Failed to update client features', 500);
  }
};

const getAllAvailableFeatures = async () => {
  try {
    return await Feature.findAll();
  } catch (error) {
    logger.error('Error fetching all available features:', error);
    throw new AppError('Failed to fetch available features', 500);
  }
};

const createFeature = async (featureData) => {
  try {
    const newFeature = await Feature.create(featureData);
    logger.info(`New feature created with ID: ${newFeature.id}`);
    return newFeature;
  } catch (error) {
    logger.error('Error creating new feature:', error);
    throw new AppError('Failed to create feature', 500);
  }
};

const updateFeature = async (featureId, featureData) => {
  try {
    const feature = await Feature.findByPk(featureId);
    if (!feature) {
      throw new AppError('Feature not found', 404);
    }
    const updatedFeature = await feature.update(featureData);
    return updatedFeature;
  } catch (error) {
    logger.error(`Error updating feature ${featureId}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to update feature', 500);
  }
};

const deleteFeature = async (featureId) => {
  try {
    const feature = await Feature.findByPk(featureId);
    if (!feature) {
      throw new AppError('Feature not found', 404);
    }
    await feature.destroy();
    logger.info(`Feature deleted with ID: ${featureId}`);
    return true;
  } catch (error) {
    logger.error(`Error deleting feature ${featureId}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to delete feature', 500);
  }
};

module.exports = {
  getClientFeatures,
  updateClientFeatures,
  getAllAvailableFeatures,
  createFeature,
  updateFeature,
  deleteFeature
};

================
File: src/services/GlobalSettingsService.js
================
const GlobalSetting = require('../models/GlobalSetting');

class GlobalSettingsService {
  static async getSetting(key) {
    const setting = await GlobalSetting.findOne({ where: { key } });
    return setting ? setting.value : null;
  }

  static async updateSetting(key, value) {
    const setting = await GlobalSetting.findOne({ where: { key } });
    if (setting) {
      setting.value = value;
      await setting.save();
    } else {
      await GlobalSetting.create({ key, value });
    }
  }
}

module.exports = GlobalSettingsService;

================
File: src/services/guestService.js
================
const db = require('../models');
const logger = require('../services/logger');

class GuestService {
  // Create a new guest profile
  async createGuestProfile(guestData) {
    try {
      const guest = await db.Guest.create(guestData);
      logger.info(`Guest profile created: ID ${guest.id}`);
      return guest;
    } catch (error) {
      logger.error(`Error creating guest profile: ${error.message}`);
      throw error;
    }
  }

  // Update guest profile (e.g., after an order)
  async updateGuestProfile(guestId, updates) {
    try {
      const guest = await db.Guest.findByPk(guestId);
      if (!guest) throw new Error('Guest not found');

      await guest.update(updates);
      logger.info(`Guest profile updated: ID ${guest.id}`);
      return guest;
    } catch (error) {
      logger.error(`Error updating guest profile: ${error.message}`);
      throw error;
    }
  }

  // Fetch guest order history
  async getGuestOrderHistory(guestId) {
    try {
      const orders = await db.Order.findAll({
        where: { guestId },
        include: [{ model: db.OrderItem }, { model: db.Location }],
      });
      return orders;
    } catch (error) {
      logger.error(`Error fetching guest order history: ${error.message}`);
      throw error;
    }
  }

  // Manage loyalty points (e.g., add points after an order)
  async manageLoyaltyPoints(guestId, points, operation = 'add') {
    try {
      const guest = await db.Guest.findByPk(guestId);
      if (!guest) throw new Error('Guest not found');

      guest.loyaltyPoints = operation === 'add' ? guest.loyaltyPoints + points : guest.loyaltyPoints - points;
      await guest.save();

      logger.info(`Loyalty points ${operation}ed for guest ID ${guest.id}`);
      return guest.loyaltyPoints;
    } catch (error) {
      logger.error(`Error managing loyalty points: ${error.message}`);
      throw error;
    }
  }

  // Calculate engagement metrics for a guest
  async calculateEngagementMetrics(guestId) {
    try {
      const orders = await this.getGuestOrderHistory(guestId);
      const totalOrders = orders.length;
      const totalSpend = orders.reduce((sum, order) => sum + order.totalAmount, 0);

      const engagementScore = totalSpend * totalOrders; // Example formula
      logger.info(`Engagement score calculated for guest ID ${guestId}: ${engagementScore}`);

      return { totalOrders, totalSpend, engagementScore };
    } catch (error) {
      logger.error(`Error calculating engagement metrics: ${error.message}`);
      throw error;
    }
  }
}

module.exports = new GuestService();

================
File: src/services/houseAccountService.js
================
const { HouseAccount, Transaction } = require('../models');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const getHouseAccountsByClient = async (clientId) => {
  try {
    return await HouseAccount.findAll({ where: { clientId } });
  } catch (error) {
    logger.error(`Error fetching house accounts for client ${clientId}:`, error);
    throw new AppError('Failed to fetch house accounts', 500);
  }
};

const getHouseAccountById = async (id) => {
  try {
    const account = await HouseAccount.findByPk(id);
    if (!account) {
      throw new AppError('House account not found', 404);
    }
    return account;
  } catch (error) {
    logger.error(`Error fetching house account with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to fetch house account', 500);
  }
};

const createHouseAccount = async (accountData) => {
  try {
    const newAccount = await HouseAccount.create(accountData);
    logger.info(`New house account created with ID: ${newAccount.id}`);
    return newAccount;
  } catch (error) {
    logger.error('Error creating house account:', error);
    throw new AppError('Failed to create house account', 500);
  }
};

const updateHouseAccount = async (id, accountData) => {
  try {
    const account = await getHouseAccountById(id);
    const updatedAccount = await account.update(accountData);
    logger.info(`House account updated with ID: ${id}`);
    return updatedAccount;
  } catch (error) {
    logger.error(`Error updating house account with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to update house account', 500);
  }
};

const deleteHouseAccount = async (id) => {
  try {
    const account = await getHouseAccountById(id);
    await account.destroy();
    logger.info(`House account deleted with ID: ${id}`);
    return true;
  } catch (error) {
    logger.error(`Error deleting house account with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to delete house account', 500);
  }
};

const addFunds = async (id, amount) => {
  try {
    const account = await getHouseAccountById(id);
    account.balance += amount;
    await account.save();
    await Transaction.create({ houseAccountId: id, amount, type: 'credit' });
    logger.info(`Funds added to house account ${id}: ${amount}`);
    return account;
  } catch (error) {
    logger.error(`Error adding funds to house account ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to add funds', 500);
  }
};

const deductFunds = async (id, amount) => {
  try {
    const account = await getHouseAccountById(id);
    if (account.balance < amount) {
      throw new AppError('Insufficient funds', 400);
    }
    account.balance -= amount;
    await account.save();
    await Transaction.create({ houseAccountId: id, amount, type: 'debit' });
    logger.info(`Funds deducted from house account ${id}: ${amount}`);
    return account;
  } catch (error) {
    logger.error(`Error deducting funds from house account ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to deduct funds', 500);
  }
};

const getTransactionHistory = async (id) => {
  try {
    await getHouseAccountById(id); // Ensure account exists
    const transactions = await Transaction.findAll({ where: { houseAccountId: id } });
    return transactions;
  } catch (error) {
    logger.error(`Error fetching transaction history for house account ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to fetch transaction history', 500);
  }
};

module.exports = {
  getHouseAccountsByClient,
  getHouseAccountById,
  createHouseAccount,
  updateHouseAccount,
  deleteHouseAccount,
  addFunds,
  deductFunds,
  getTransactionHistory
};

================
File: src/services/imageService.js
================
const sharp = require('sharp');

const optimizeImage = async (buffer) => {
  return sharp(buffer)
    .resize(1000, 1000, { fit: 'inside', withoutEnlargement: true })
    .jpeg({ quality: 80 })
    .toBuffer();
};

module.exports = {
  optimizeImage
};

================
File: src/services/integrationService.js
================
const axios = require 'axios';

const syncWithPOS = async (posSystem, data) => {
  // Implement POS integration logic
  // ...
};

const syncWithAccounting = async (accountingSoftware, data) => {
  // Implement accounting software integration logic
  // ...
};

const syncWithCRM = async (crmSystem, data) => {
  // Implement CRM integration logic
  // ...
};

================
File: src/services/inventoryService.js
================
const { InventoryItem } = require('../models');
const { AppError } = require('../utils/errorHandler');

const getInventoryItems = async () => {
  return await InventoryItem.findAll();
};

const getInventoryItemById = async (id) => {
  const item = await InventoryItem.findByPk(id);
  if (!item) {
    throw new AppError('Inventory item not found', 404);
  }
  return item;
};

const createInventoryItem = async (itemData) => {
  return await InventoryItem.create(itemData);
};

const updateInventoryItem = async (id, itemData) => {
  const item = await getInventoryItemById(id);
  return await item.update(itemData);
};

const deleteInventoryItem = async (id) => {
  const item = await getInventoryItemById(id);
  await item.destroy();
};

const updateInventoryQuantity = async (id, quantity) => {
  const item = await getInventoryItemById(id);
  item.quantity += quantity;
  if (item.quantity < 0) {
    throw new AppError('Insufficient inventory', 400);
  }
  return await item.save();
};

module.exports = {
  getInventoryItems,
  getInventoryItemById,
  createInventoryItem,
  updateInventoryItem,
  deleteInventoryItem,
  updateInventoryQuantity
};

================
File: src/services/inventorySyncService.js
================
const axios = require('axios');
const db = require('../models');
const logger = require('./logger');

class InventorySyncService {
  async syncInventory(posProfile) {
    try {
      const inventory = await db.Inventory.findAll({
        where: { locationId: posProfile.locationId },
        attributes: ['itemName', 'quantity', 'sku'],
      });

      const formattedInventory = inventory.map((item) => ({
        itemName: item.itemName,
        quantity: item.quantity,
        sku: item.sku,
      }));

      const response = await axios.post(`${posProfile.apiBaseUrl}/inventory`, formattedInventory, {
        headers: {
          Authorization: `Bearer ${posProfile.clientSecret}`,
          'Content-Type': posProfile.contentType || 'application/json',
        },
      });

      if (response.status === 200) {
        logger.info(`Inventory sync successful for location ${posProfile.locationId}`);
      } else {
        logger.error(`Inventory sync failed: ${response.data.message}`);
      }
    } catch (error) {
      logger.error(`Error syncing inventory: ${error.message}`);
      throw error;
    }
  }

  // Check inventory levels and trigger alerts if low
  async checkLowInventory(locationId) {
    try {
      const lowStockItems = await db.Inventory.findAll({
        where: {
          locationId,
          quantity: { [db.Sequelize.Op.lt]: 10 }, // Example threshold for low stock
        },
      });

      if (lowStockItems.length > 0) {
        logger.warn(`Low stock alert for location ID ${locationId}`);
        // Example: Trigger notification or restock order
      }

      return lowStockItems;
    } catch (error) {
      logger.error(`Error checking low inventory: ${error.message}`);
      throw error;
    }
  }
}

module.exports = new InventorySyncService();

================
File: src/services/invoiceService.js
================
const { Invoice, Order } = require('../models');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const generateInvoice = async (invoiceData) => {
  try {
    const newInvoice = await Invoice.create(invoiceData);
    logger.info(`New invoice generated with ID: ${newInvoice.id}`);
    return newInvoice;
  } catch (error) {
    logger.error('Error generating invoice:', error);
    throw new AppError('Failed to generate invoice', 500);
  }
};

const getInvoiceById = async (id) => {
  try {
    const invoice = await Invoice.findByPk(id, {
      include: [{ model: Order, as: 'orders' }]
    });
    if (!invoice) {
      throw new AppError('Invoice not found', 404);
    }
    return invoice;
  } catch (error) {
    logger.error(`Error fetching invoice with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to fetch invoice', 500);
  }
};

const getClientInvoices = async (clientId) => {
  try {
    return await Invoice.findAll({
      where: { clientId },
      include: [{ model: Order, as: 'orders' }]
    });
  } catch (error) {
    logger.error(`Error fetching invoices for client ${clientId}:`, error);
    throw new AppError('Failed to fetch client invoices', 500);
  }
};

const updateInvoice = async (id, invoiceData) => {
  try {
    const invoice = await Invoice.findByPk(id);
    if (!invoice) {
      throw new AppError('Invoice not found', 404);
    }
    const updatedInvoice = await invoice.update(invoiceData);
    logger.info(`Invoice updated with ID: ${id}`);
    return updatedInvoice;
  } catch (error) {
    logger.error(`Error updating invoice with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to update invoice', 500);
  }
};

const deleteInvoice = async (id) => {
  try {
    const invoice = await Invoice.findByPk(id);
    if (!invoice) {
      throw new AppError('Invoice not found', 404);
    }
    await invoice.destroy();
    logger.info(`Invoice deleted with ID: ${id}`);
    return true;
  } catch (error) {
    logger.error(`Error deleting invoice with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to delete invoice', 500);
  }
};

module.exports = {
  generateInvoice,
  getInvoiceById,
  getClientInvoices,
  updateInvoice,
  deleteInvoice
};

================
File: src/services/InvoiceService.js
================
class InvoiceService {
  static generateInvoice(orderDetails, options = {}) {
    // Placeholder logic for generating invoices
    // You can use libraries like pdfkit to create a PDF invoice
    const invoiceData = {
      ...orderDetails,
      generatedAt: new Date(),
      dueDate: options.dueDate || new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // default to 7 days later
    };

    return invoiceData;
  }

  static storeInvoice(invoiceData, clientId) {
    // Placeholder logic for storing invoices in the database
    // This could involve saving the invoice to a storage service or database
    console.log(`Storing invoice for client ${clientId}:`, invoiceData);
    return true;
  }

  static retrieveInvoice(invoiceId) {
    // Placeholder logic for retrieving an invoice by its ID
    return {
      invoiceId,
      status: 'pending',
      amount: 100.0,
      issuedAt: new Date(),
    };
  }

  static listInvoices(clientId) {
    // Placeholder logic for listing all invoices for a specific client
    console.log(`Listing invoices for client ${clientId}`);
    return [
      {
        invoiceId: 1,
        status: 'paid',
        amount: 150.0,
        issuedAt: new Date(),
      },
      {
        invoiceId: 2,
        status: 'pending',
        amount: 200.0,
        issuedAt: new Date(),
      },
    ];
  }
}

module.exports = InvoiceService;

================
File: src/services/locationService.js
================
const { Location, MenuItem } = require('../models');
const { scheduleJob } = require('node-schedule');
const LocationProfile = require('../models/LocationProfile');
const { AppError } = require('../utils/errorHandler');

const updateLocationStatus = async (locationId, isOpen) => {
  const location = await Location.findByPk(locationId);
  if (!location) {
    throw new AppError('Location not found', 404);
  }
  location.isOpen = isOpen;
  await location.save();
  return location;
};

const getLocations = async () => {
  return await Location.findAll();
};

const createLocation = async (locationData) => {
  const location = await Location.create(locationData);
  await setupInventoryReset(location.id);
  return location;
};

const updateLocation = async (locationData) => {
  const location = await Location.findByPk(locationData.id);
  if (!location) throw new AppError('Location not found', 404);

  await location.update(locationData);
  await setupInventoryReset(location.id);
  return location;
};

const getLocationProfiles = async () => {
  return await LocationProfile.findAll();
};

const setupInventoryReset = async (locationId) => {
  const location = await Location.findByPk(locationId);
  if (!location || !location.inventoryResetTime) return;

  const [hours, minutes] = location.inventoryResetTime.split(':').map(Number);

  scheduleJob(`${minutes} ${hours} * * *`, async () => {
    const menuItems = await MenuItem.findAll({ where: { locationId } });
    for (const item of menuItems) {
      await item.update({ onlineInventoryOffset: 0 });
    }
  });
};

module.exports = {
  updateLocationStatus,
  getLocations,
  createLocation,
  updateLocation,
  getLocationProfiles,
  setupInventoryReset
};

================
File: src/services/logger.js
================
const winston = require('winston');

// Customize log levels
const levels = {
  error: 0,
  warn: 1,
  info: 2,
  http: 3,
  verbose: 4,
  debug: 5,
  silly: 6,
};

// Set up log level based on environment
const level = () => {
  return process.env.NODE_ENV === 'development' ? 'debug' : 'info';
};

// Configure the Winston logger
const logger = winston.createLogger({
  level: level(),
  levels,
  format: winston.format.combine(
    winston.format.colorize(),
    winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
    winston.format.printf((info) => `${info.timestamp} [${info.level}]: ${info.message}`)
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'logs/app.log', level: 'info' }),
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
  ],
});

// Middleware to add request ID and user information to log metadata
logger.add(new winston.transports.Console({
  format: winston.format.printf(({ level, message, timestamp, ...meta }) => {
    const requestId = meta.req && meta.req.headers['x-request-id'];
    const userId = meta.req && meta.req.user && meta.req.user.id;
    return `${timestamp} [${level}] [Request ID: ${requestId || 'N/A'}] [User ID: ${userId || 'N/A'}]: ${message}`;
  }),
}));

module.exports = logger;

================
File: src/services/loyaltyService.js
================
const { User, Order, LoyaltyProgram } = require ('../models');

const calculatePoints = async (orderId) => {
  const order = await Order.findByPk(orderId);
  const loyaltyProgram = await LoyaltyProgram.findOne();
  
  const points = Math.floor(order.total * loyaltyProgram.pointsPerDollar);
  
  await User.increment('loyaltyPoints', { by: points, where: { id: order.userId } });
};

const checkAndUpdateTier = async (userId) => {
  const user = await User.findByPk(userId);
  const loyaltyProgram = await LoyaltyProgram.findOne();
  
  const newTier = loyaltyProgram.tiers.find(tier => user.loyaltyPoints >= tier.minPoints);
  
  if (newTier && newTier.name !== user.loyaltyTier) {
    await user.update({ loyaltyTier: newTier.name });
  }
};

================
File: src/services/menuItemService.js
================
const { MenuItem, Modifier } = require '../models';
const { AppError } = require '../utils/errorHandler';

const getMenuItemsByLocation = async (locationId) => {
  const menuItems = await MenuItem.findAll({
    where: { locationId },
    include: [
      {
        model,
        as: 'modifiers',
      },
      {
        model,
        as: 'defaultModifiers',
      },
    ],
  });

  if (!menuItems) {
    throw new AppError('No menu items found for this location', 404);
  }

  return menuItems;
};

================
File: src/services/menuService.js
================
const { MenuItem } = require('../models/index');
const { getIO } = require('../socket');

const updateInventory = async (menuItemId, quantity) => {
  const menuItem = await MenuItem.findByPk(menuItemId);
  if (menuItem) {
    await menuItem.update({
      onlineInventoryOffset: menuItem.onlineInventoryOffset - quantity,
    });

    const io = getIO();
    io.to(`location-${menuItem.locationId}`).emit('inventory-update', {
      menuItemId: menuItem.id,
      newInventory: menuItem.onlineInventoryOffset,
    });
  }
};

module.exports = {
  updateInventory
};

================
File: src/services/menuSyncEnhancements.js
================
const axios = require('axios');
const db = require('../models');
const logger = require('./logger');

class MenuSyncEnhancements {
  async syncMenuData(posProfile) {
    try {
      const menuData = await db.Menu.findAll({
        where: { locationId: posProfile.locationId },
        include: [
          { model: db.MenuGroup, include: [{ model: db.MenuItem, include: [db.Modifier] }] },
        ],
      });

      const formattedMenuData = menuData.map((menu) => ({
        name: menu.name,
        groups: menu.MenuGroups.map((group) => ({
          name: group.name,
          items: group.MenuItems.map((item) => ({
            name: item.name,
            price: item.basePrice,
            pointsPrice: item.pointsPrice || null,
            availability: item.isAvailable,
            modifiers: item.Modifiers.map((modifier) => ({
              name: modifier.name,
              price: modifier.price,
            })),
            tags: item.tags || [],
          })),
        })),
      }));

      const response = await axios.post(`${posProfile.apiBaseUrl}/menus`, formattedMenuData, {
        headers: {
          Authorization: `Bearer ${posProfile.clientSecret}`,
          'Content-Type': posProfile.contentType || 'application/json',
        },
      });

      if (response.status === 200) {
        logger.info(`Menu sync successful for location ${posProfile.locationId}`);
      } else {
        logger.error(`Menu sync failed: ${response.data.message}`);
      }
    } catch (error) {
      logger.error(`Error syncing menu data: ${error.message}`);
      throw error;
    }
  }

  // Additional logic for syncing modifiers and item availability
  async syncModifiersAndAvailability(posProfile) {
    try {
      // Implement modifier-specific sync logic here
      logger.info(`Modifiers and availability synced for profile ${posProfile.id}`);
    } catch (error) {
      logger.error(`Error syncing modifiers and availability: ${error.message}`);
      throw error;
    }
  }
}

module.exports = new MenuSyncEnhancements();

================
File: src/services/notificationService.js
================
const db = require('../models');
const logger = require('./logger');
const twilio = require('twilio')(process.env.TWILIO_ACCOUNT_SID, process.env.TWILIO_AUTH_TOKEN);
const nodemailer = require('nodemailer');

class NotificationService {
  // Send email or SMS based on the notification type
  async sendNotification(recipient, message, notificationType) {
    try {
      if (notificationType === 'email') {
        await this.sendEmail(recipient, message);
      } else if (notificationType === 'sms') {
        await this.sendSMS(recipient, message);
      }

      // Update the notification status in the database
      await db.Notification.update({ status: 'sent' }, { where: { recipient } });

      logger.info(`Notification sent: ${notificationType} to ${recipient}`);
    } catch (error) {
      await db.Notification.update({ status: 'failed' }, { where: { recipient } });
      logger.error(`Error sending notification: ${error.message}`);
      throw error;
    }
  }

  // Send an email
  async sendEmail(recipient, message) {
    const transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
        user: process.env.EMAIL_USERNAME,
        pass: process.env.EMAIL_PASSWORD,
      },
    });

    const mailOptions = {
      from: process.env.EMAIL_USERNAME,
      to: recipient,
      subject: 'Notification',
      text: message,
    };

    await transporter.sendMail(mailOptions);
  }

  // Send an SMS
  async sendSMS(recipient, message) {
    await twilio.messages.create({
      body: message,
      from: process.env.TWILIO_PHONE_NUMBER,
      to: recipient,
    });
  }
}

module.exports = new NotificationService();

================
File: src/services/orderPrepService.js
================
const { MenuItem } = require('../models/MenuItem');
const { Location } = require('../models/Location');
const { Order } = require('../models/Order');

const calculatePrepTime = async (order) => {
  const location = await Location.findByPk(order.locationId);
  const menuItems = await MenuItem.findAll({
    where: { id: order.items.map(item => item.menuItemId) }
  });

  const maxPrepTime = Math.max(
    ...menuItems.map(item => item.prepTime),
    location?.defaultPrepTime || 15
  );

  return maxPrepTime;
};

const formatEstimatedTime = (minutes) => {
  const now = new Date();
  const estimatedTime = new Date(now.getTime() + minutes * 60000);
  
  // Round to nearest 5 minutes
  estimatedTime.setMinutes(Math.round(estimatedTime.getMinutes() / 5) * 5);
  
  const start = new Date(estimatedTime);
  const end = new Date(estimatedTime.getTime() + 15 * 60000);

  return `${formatTime(start)}-${formatTime(end)}`;
};

const formatTime = (date) => {
  return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
};

const checkInventory = async (orderItems) => {
  for (const item of orderItems) {
    const menuItem = await MenuItem.findByPk(item.menuItemId);
    if (!menuItem) continue;

    const availableStock = await getAvailableStock(menuItem);
    if (item.quantity > availableStock) {
      return false;
    }
  }
  return true;
};

const getAvailableStock = async (menuItem) => {
  // This is a placeholder. In a real scenario, you'd fetch the actual stock from your POS system.
  const posStock = 10; // Example value
  return Math.max(0, posStock + menuItem.onlineInventoryOffset);
};

module.exports = {
  calculatePrepTime,
  formatEstimatedTime,
  checkInventory,
  getAvailableStock
};

================
File: src/services/orderProviderService.js
================
const OrderProvider = require '../models/OrderProvider';
const LocationMenu = require '../models/LocationMenu';
const { AppError } = require '../utils/errorHandler';
const { sendMenuToProvider, handleIncomingOrder, sendDoordashSSIOUpdate } = require '../utils/orderProviderIntegration';
const { scheduleMenuSync } = require '../utils/menuSyncScheduler';
const ScheduledOrder = require '../models/ScheduledOrder';
const { scheduleJob } = require 'node-schedule';

const createOrderProvider = async (locationId, providerData) => {
  const newProvider = await OrderProvider.create({ ...providerData, locationId });
  await sendMenuToProvider(newProvider);
  scheduleMenuSync(newProvider);
  return newProvider;
};

const updateOrderProvider = async (id, providerData) => {
  const provider = await OrderProvider.findByPk(id);
  if (!provider) {
    throw new AppError('Order provider not found', 404);
  }
  await provider.update(providerData);
  await sendMenuToProvider(provider);
  scheduleMenuSync(provider);
  return provider;
};

const getOrderProviders = async (locationId) => {
  return await OrderProvider.findAll({ where: { locationId } });
};

const deleteOrderProvider = async (id) => {
  const provider = await OrderProvider.findByPk(id);
  if (!provider) {
    throw new AppError('Order provider not found', 404);
  }
  await provider.destroy();
};

const processIncomingOrder = async (providerId, orderData) => {
  const provider = await OrderProvider.findByPk(providerId);
  if (!provider) {
    throw new AppError('Order provider not found', 404);
  }

  const transformedOrder = transformOrderData(orderData);
  const order = await Order.create(transformedOrder);

  if (orderData.scheduledTime && provider.handleScheduledOrders) {
    const scheduledTime = new Date(orderData.scheduledTime);
    const prepTime = new Date(scheduledTime.getTime() - provider.scheduledOrderLeadTime * 60000);

    await ScheduledOrder.create({
      orderId.id,
      scheduledTime,
    });

    scheduleJob(prepTime, async () => {
      await sendOrderToPOS(order);
      await ScheduledOrder.update({ sentToPOS }, { where: { orderId.id } });
    });
  } else {
    await sendOrderToPOS(order);
  }

  return order;
};

const syncMenuForProvider = async (providerId) => {
  const provider = await OrderProvider.findByPk(providerId);
  if (!provider) {
    throw new AppError('Order provider not found', 404);
  }
  const locationMenu = await LocationMenu.findOne({ 
    where: { locationId.locationId, isActive } 
  });
  if (!locationMenu) {
    throw new AppError('Active menu not found for this location', 404);
  }
  await sendMenuToProvider(provider, locationMenu.items);
  provider.lastMenuSync = new Date();
  await provider.save();
};

const createLocationMenu = async (locationId, menuData) => {
  const newMenu = await LocationMenu.create({ ...menuData, locationId });
  return newMenu;
};

const updateLocationMenu = async (id, menuData) => {
  const menu = await LocationMenu.findByPk(id);
  if (!menu) {
    throw new AppError('Menu not found', 404);
  }
  await menu.update(menuData);
  return menu;
};

const getLocationMenus = async (locationId) => {
  return await LocationMenu.findAll({ where: { locationId } });
};

const deleteLocationMenu = async (id) => {
  const menu = await LocationMenu.findByPk(id);
  if (!menu) {
    throw new AppError('Menu not found', 404);
  }
  await menu.destroy();
};

const updateDoordashSSIOSettings = async (providerId, ssioSettings) => {
  const provider = await OrderProvider.findByPk(providerId);
  if (!provider) {
    throw new AppError('Order provider not found', 404);
  }
  await provider.update(ssioSettings);
  await sendDoordashSSIOUpdate(provider);
  return provider;
};

const syncDoordashSSIOMenu = async (providerId) => {
  const provider = await OrderProvider.findByPk(providerId);
  if (!provider) {
    throw new AppError('Order provider not found', 404);
  }
  const locationMenu = await LocationMenu.findOne({ 
    where: { locationId.locationId, isActive } 
  });
  if (!locationMenu) {
    throw new AppError('Active menu not found for this location', 404);
  }
  await sendDoordashSSIOUpdate(provider, locationMenu.items);
  provider.lastMenuSync = new Date();
  await provider.save();
};

function transformOrderData(orderData) {
    throw new Error('Function not implemented.');
}


function sendOrderToPOS(order) {
    throw new Error('Function not implemented.');
}

================
File: src/services/orderService.js
================
const { Counter, Histogram } = require('prom-client');
const { Order, OrderItem, MenuItem } = require('../models/Order');
const { calculatePrepTime, formatEstimatedTime, checkInventory } = require('./orderPrepService');
const { emitDashboardUpdate, emitNewOrder } = require('./dashboardService'); // Changed from './dashboardService1' to './dashboardService'
const { emitOrderUpdate } = require('../socket');
const { io } = require('../socket');
const { sendNotification } = require('../utils/notificationService');

const orderCounter = new Counter({
  name: 'pos_orders_total',
  help: 'Total number of orders'
});

const orderValueHistogram = new Histogram({
  name: 'pos_order_value',
  help: 'Distribution of order values'
});

const createOrder = async (orderData) => {
  const order = await Order.create(orderData);

  for (const item of orderData.items) {
    const menuItem = await MenuItem.findByPk(item.menuItemId);
    if (!menuItem) {
      throw new Error(`Menu item not found: ${item.menuItemId}`);
    }

    await OrderItem.create({
      orderId: order.id,
      menuItemId: menuItem.id,
      name: menuItem.name,
      quantity: item.quantity,
      price: item.price || menuItem.price, // Use provided price or default to menu price
      specialInstructions: item.specialInstructions
    });
  }

  return order;
};

// ... other order-related functions ...

const getActiveOrders = async () => {
  return await Order.findAll({
    where: {
      status: ['pending', 'in-progress'],
    },
    order: [['promiseTime', 'ASC']],
  });
};

const cancelOrder = async (orderId) => {
  const order = await Order.findByPk(orderId);
  if (!order) {
    throw new Error('Order not found');
  }
  await order.update({ status: 'cancelled' });
  
  // Notify guest
  await sendNotification(order.guestId, 'Your order has been cancelled');
  
  // Notify provider (if applicable)
  if (order.providerId) {
    await sendNotification(order.providerId, `Order #${order.id} has been cancelled`);
  }
  
  // Notify driver (if applicable)
  if (order.driverId) {
    await sendNotification(order.driverId, `Order #${order.id} has been cancelled`);
  }
  
  emitOrderUpdate(order);
};

const markItemOutOfStock = async (itemId) => {
  const menuItem = await MenuItem.findByPk(itemId);
  if (!menuItem) {
    throw new Error('Menu item not found');
  }
  await menuItem.update({ isAvailable: false });
  
  // Emit event to update all channels
  io.emit('menu-item-update', { itemId, isAvailable: false });
  
  // Update third-party delivery services
  await updateThirdPartyMenus(itemId, false);
};

const updateThirdPartyMenus = async (itemId, isAvailable) => {
  // Implement logic to update menus on third-party delivery services
  // This might involve calling APIs for services like DoorDash, Uber Eats, etc.
};

module.exports = {
  createOrder,
  getActiveOrders,
  cancelOrder,
  markItemOutOfStock,
  updateThirdPartyMenus
};

================
File: src/services/orderThrottleService.js
================
const Location = require('../models/Location');

class OrderThrottleService {
  static async adjustReadyTime(locationId) {
    const location = await Location.findByPk(locationId);
    const { throttleSettings } = location;

    // Logic to determine the new ready time based on sales volume, item count, etc.
    if (throttleSettings && throttleSettings.orderThreshold) { // Assuming some condition to adjust time
      location.readyTime += 10; // Example adjustment
    }

    await location.save();
  }
}

module.exports = OrderThrottleService;

================
File: src/services/paymentService.js
================
const { Payment, Order } = require('../models');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

// Define payment gateways as an object instead of an enum
const PaymentGateway = {
  STRIPE: 'stripe',
  PAYPAL: 'paypal',
  SQUARE: 'square'
};

const processPayment = async (orderId, amount, gateway, paymentDetails) => {
  try {
    // Validate the order
    const order = await Order.findByPk(orderId);
    if (!order) {
      throw new AppError('Order not found', 404);
    }

    // Process payment based on the gateway
    let paymentResult;
    switch (gateway) {
      case PaymentGateway.STRIPE:
        paymentResult = await processStripePayment(amount, paymentDetails);
        break;
      case PaymentGateway.PAYPAL:
        paymentResult = await processPayPalPayment(amount, paymentDetails);
        break;
      case PaymentGateway.SQUARE:
        paymentResult = await processSquarePayment(amount, paymentDetails);
        break;
      default:
        throw new AppError('Invalid payment gateway', 400);
    }

    // Create a payment record
    const payment = await Payment.create({
      orderId,
      amount,
      gateway,
      status: paymentResult.status,
      transactionId: paymentResult.transactionId
    });

    // Update order status
    await order.update({ paymentStatus: 'paid' });

    logger.info(`Payment processed successfully for order ${orderId}`);
    return payment;
  } catch (error) {
    logger.error(`Error processing payment for order ${orderId}:`, error);
    throw error instanceof AppError ? error : new AppError('Payment processing failed', 500);
  }
};

const processStripePayment = async (amount, paymentDetails) => {
  // Implement Stripe payment logic here
  // This is a placeholder implementation
  return { status: 'success', transactionId: 'stripe_' + Date.now() };
};

const processPayPalPayment = async (amount, paymentDetails) => {
  // Implement PayPal payment logic here
  // This is a placeholder implementation
  return { status: 'success', transactionId: 'paypal_' + Date.now() };
};

const processSquarePayment = async (amount, paymentDetails) => {
  // Implement Square payment logic here
  // This is a placeholder implementation
  return { status: 'success', transactionId: 'square_' + Date.now() };
};

const getPaymentById = async (paymentId) => {
  try {
    const payment = await Payment.findByPk(paymentId);
    if (!payment) {
      throw new AppError('Payment not found', 404);
    }
    return payment;
  } catch (error) {
    logger.error(`Error fetching payment ${paymentId}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to fetch payment', 500);
  }
};

const refundPayment = async (paymentId, amount) => {
  try {
    const payment = await getPaymentById(paymentId);
    
    // Process refund based on the original payment gateway
    let refundResult;
    switch (payment.gateway) {
      case PaymentGateway.STRIPE:
        refundResult = await processStripeRefund(payment.transactionId, amount);
        break;
      case PaymentGateway.PAYPAL:
        refundResult = await processPayPalRefund(payment.transactionId, amount);
        break;
      case PaymentGateway.SQUARE:
        refundResult = await processSquareRefund(payment.transactionId, amount);
        break;
      default:
        throw new AppError('Invalid payment gateway', 400);
    }

    // Update payment record
    await payment.update({
      refundedAmount: (payment.refundedAmount || 0) + amount,
      status: amount === payment.amount ? 'refunded' : 'partially_refunded'
    });

    logger.info(`Refund processed successfully for payment ${paymentId}`);
    return payment;
  } catch (error) {
    logger.error(`Error processing refund for payment ${paymentId}:`, error);
    throw error instanceof AppError ? error : new AppError('Refund processing failed', 500);
  }
};

const processStripeRefund = async (transactionId, amount) => {
  // Implement Stripe refund logic here
  // This is a placeholder implementation
  return { status: 'success', refundId: 'stripe_refund_' + Date.now() };
};

const processPayPalRefund = async (transactionId, amount) => {
  // Implement PayPal refund logic here
  // This is a placeholder implementation
  return { status: 'success', refundId: 'paypal_refund_' + Date.now() };
};

const processSquareRefund = async (transactionId, amount) => {
  // Implement Square refund logic here
  // This is a placeholder implementation
  return { status: 'success', refundId: 'square_refund_' + Date.now() };
};

module.exports = {
  PaymentGateway,
  processPayment,
  getPaymentById,
  refundPayment
};

================
File: src/services/permissionService.js
================
const Permission = require('../models/Permission');

exports.createPermission = async (permissionData) => {
  try {
    const permission = await Permission.create(permissionData);
    return permission;
  } catch (error) {
    throw new Error('Error creating permission: ' + error.message);
  }
};

exports.getAllPermissions = async () => {
  try {
    const permissions = await Permission.findAll();
    return permissions;
  } catch (error) {
    throw new Error('Error fetching permissions: ' + error.message);
  }
};

exports.updatePermission = async (permissionId, updatedData) => {
  try {
    const permission = await Permission.findByPk(permissionId);
    if (!permission) throw new Error('Permission not found');

    await permission.update(updatedData);
    return permission;
  } catch (error) {
    throw new Error('Error updating permission: ' + error.message);
  }
};

================
File: src/services/posAlertService.js
================
const { POSAlert } = require '../models/POSAlert';

const createPOSAlert = async (alertData) => {
  return await POSAlert.create(alertData);
};

const getPOSAlerts = async ()[]> => {
  return await POSAlert.findAll({
    order: [['timestamp', 'DESC']],
    limit: 50 // Limit to the most recent 50 alerts
  });
};

================
File: src/services/posIntegrationService.js
================
const axios = require('axios');
const db = require('../models');
const logger = require('../utils/logger');

class PosIntegrationService {
  // Method to sync menus with external POS
  static async syncMenus(locationId, provider) {
    try {
      const menuData = await db.Menu.findAll({
        where: { locationId },
        include: [
          { model: db.MenuGroup, include: [{ model: db.MenuItem }] }
        ],
      });

      const response = await axios.post(`https://api.${provider}.com/sync/menus`, menuData);

      if (response.status === 200) {
        logger.info(`Menu sync successful for provider ${provider} at location ${locationId}`);
      } else {
        logger.error(`Menu sync failed for provider ${provider}: ${response.data.message}`);
      }
    } catch (error) {
      logger.error(`Error syncing menus for provider ${provider}:`, error);
      throw error;
    }
  }

  // Method to sync orders with external POS
  static async syncOrders(locationId, provider) {
    try {
      const orders = await db.Order.findAll({
        where: { locationId, status: 'pending' },
      });

      const response = await axios.post(`https://api.${provider}.com/sync/orders`, orders);

      if (response.status === 200) {
        logger.info(`Order sync successful for provider ${provider} at location ${locationId}`);
      } else {
        logger.error(`Order sync failed for provider ${provider}: ${response.data.message}`);
      }
    } catch (error) {
      logger.error(`Error syncing orders for provider ${provider}:`, error);
      throw error;
    }
  }
}

module.exports = PosIntegrationService;

================
File: src/services/posProfileService.js
================
const db = require('../models');

class PosProfileService {
  async getPosProfileByLocation(locationId) {
    return await db.PosProfile.findOne({ where: { locationId } });
  }

  async updatePosProfile(locationId, posProfileDetails) {
    let posProfile = await this.getPosProfileByLocation(locationId);

    if (posProfile) {
      posProfile = await posProfile.update(posProfileDetails);
    } else {
      posProfile = await db.PosProfile.create({ locationId, ...posProfileDetails });
    }

    return posProfile;
  }
}

module.exports = new PosProfileService();

================
File: src/services/posService.js
================
const { PosProfile } = require('../models');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const createProfile = async (profileData) => {
  try {
    const profile = await PosProfile.create(profileData);
    logger.info(`POS profile created with ID: ${profile.id}`);
    return profile;
  } catch (error) {
    logger.error('Error creating POS profile:', error);
    throw new AppError('Failed to create POS profile', 500);
  }
};

const getProfile = async (id) => {
  try {
    const profile = await PosProfile.findByPk(id);
    if (!profile) {
      throw new AppError('POS profile not found', 404);
    }
    return profile;
  } catch (error) {
    logger.error(`Error fetching POS profile with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to fetch POS profile', 500);
  }
};

const updateProfile = async (id, profileData) => {
  try {
    const profile = await getProfile(id);
    const updatedProfile = await profile.update(profileData);
    logger.info(`POS profile updated with ID: ${id}`);
    return updatedProfile;
  } catch (error) {
    logger.error(`Error updating POS profile with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to update POS profile', 500);
  }
};

const deleteProfile = async (id) => {
  try {
    const profile = await getProfile(id);
    await profile.destroy();
    logger.info(`POS profile deleted with ID: ${id}`);
  } catch (error) {
    logger.error(`Error deleting POS profile with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to delete POS profile', 500);
  }
};

const syncData = async (syncData) => {
  try {
    // Implement your sync logic here
    // This could involve updating multiple models or calling external APIs
    logger.info('POS data sync initiated');
    // Example: await SomeModel.bulkCreate(syncData.someData, { updateOnDuplicate: ['field1', 'field2'] });
    return { message: 'Data synced successfully' };
  } catch (error) {
    logger.error('Error syncing POS data:', error);
    throw new AppError('Failed to sync POS data', 500);
  }
};

const getStatus = async (id) => {
  try {
    const profile = await getProfile(id);
    // Implement logic to determine POS status
    // This could involve checking connection status, last sync time, etc.
    const status = {
      isOnline: true, // Example status
      lastSyncTime: profile.lastSyncTime,
      // Add other relevant status information
    };
    return status;
  } catch (error) {
    logger.error(`Error fetching POS status for profile ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to fetch POS status', 500);
  }
};

module.exports = {
  createProfile,
  getProfile,
  updateProfile,
  deleteProfile,
  syncData,
  getStatus
};

================
File: src/services/posSettingsService.js
================
const POSSettings = require '../models/POSSettings';
const { AppError } = require '../utils/errorHandler';

const getPOSSettings = async (clientId) => {
  const settings = await POSSettings.findOne({ where: { clientId } });
  if (!settings) {
    throw new AppError('POS settings not found', 404);
  }
  return settings;
};

const updatePOSSettings = async (clientId, updates: { modifierSendMethod }) => {
  const settings = await POSSettings.findOne({ where: { clientId } });
  if (!settings) {
    throw new AppError('POS settings not found', 404);
  }
  await settings.update(updates);
  return settings;
};

================
File: src/services/posSyncService.js
================
const axios = require('axios');
const db = require('../models');
const logger = require('./logger');
const { applyRoundingIfNeeded } = require('../utils/pricingUtils');

class PosSyncService {
  async syncMenus(locationPosProfile, corePosProfile) {
    try {
      const menuData = await db.Menu.findAll({
        where: { locationId: locationPosProfile.locationId },
        include: [
          { model: db.MenuGroup, include: [{ model: db.MenuItem, include: [db.Modifier] }] },
        ],
      });

      const formattedMenuData = menuData.map((menu) => ({
        name: menu.name,
        groups: menu.MenuGroups.map((group) => ({
          name: group.name,
          items: group.MenuItems.map((item) => ({
            name: item.name,
            price: applyRoundingIfNeeded(item.basePrice, locationPosProfile.roundingOption),
            pointsPrice: item.pointsPrice || null,
            modifiers: item.Modifiers.map((modifier) => ({
              name: modifier.name,
              price: applyRoundingIfNeeded(modifier.price, locationPosProfile.roundingOption),
            })),
          })),
        })),
      }));

      const response = await axios.post(`${corePosProfile.defaultAPISettings.apiBaseUrl}/menus`, formattedMenuData, {
        headers: {
          Authorization: `Bearer ${corePosProfile.defaultAPISettings.apiKey}`,
          'Content-Type': corePosProfile.defaultAPISettings.contentType || 'application/json',
        },
      });

      if (response.status === 200) {
        logger.info(`Menu sync successful for location ${locationPosProfile.locationId}`);
      } else {
        logger.error(`Menu sync failed: ${response.data.message}`);
      }
    } catch (error) {
      logger.error(`Error syncing menus: ${error.message}`);
      throw error;
    }
  }

  async syncOrders(locationPosProfile, corePosProfile, orderData) {
    try {
      const deconstructedOrder = orderData.items.map((item) => {
        const originalPrice = item.upliftedPrice / (1 + locationPosProfile.flatUpliftPercentage / 100);
        return {
          ...item,
          originalPrice,
          uplift: item.upliftedPrice - originalPrice,
        };
      });

      const orderWithServiceFee = {
        ...orderData,
        serviceFees: deconstructedOrder.reduce((total, item) => total + item.uplift, 0),
        items: deconstructedOrder.map((item) => ({
          ...item,
          price: item.originalPrice,
        })),
      };

      const response = await axios.post(`${corePosProfile.defaultAPISettings.apiBaseUrl}/orders`, orderWithServiceFee, {
        headers: {
          Authorization: `Bearer ${corePosProfile.defaultAPISettings.apiKey}`,
          'Content-Type': corePosProfile.defaultAPISettings.contentType || 'application/json',
        },
      });

      if (response.status === 200) {
        logger.info(`Order sync successful for location ${locationPosProfile.locationId}`);
      } else {
        logger.error(`Order sync failed: ${response.data.message}`);
      }
    } catch (error) {
      logger.error(`Error syncing orders: ${error.message}`);
      throw error;
    }
  }

  async syncInventory(locationPosProfile, corePosProfile) {
    try {
      const inventory = await db.Inventory.findAll({
        where: { locationId: locationPosProfile.locationId },
        attributes: ['itemName', 'quantity', 'sku'],
      });

      const formattedInventory = inventory.map((item) => ({
        itemName: item.itemName,
        quantity: item.quantity,
        sku: item.sku,
      }));

      const response = await axios.post(`${corePosProfile.defaultAPISettings.apiBaseUrl}/inventory`, formattedInventory, {
        headers: {
          Authorization: `Bearer ${corePosProfile.defaultAPISettings.apiKey}`,
          'Content-Type': corePosProfile.defaultAPISettings.contentType || 'application/json',
        },
      });

      if (response.status === 200) {
        logger.info(`Inventory sync successful for location ${locationPosProfile.locationId}`);
      } else {
        logger.error(`Inventory sync failed: ${response.data.message}`);
      }
    } catch (error) {
      logger.error(`Error syncing inventory: ${error.message}`);
      throw error;
    }
  }
}

module.exports = new PosSyncService();

================
File: src/services/pricingUtils.js
================
/**
 * Utility functions for pricing-related operations.
 */

/**
 * Applies rounding logic to a price based on the provided options.
 * @param {number} price - The original price before rounding.
 * @param {Object} roundingOption - Rounding options.
 * @param {boolean} roundingOption.enabled - If rounding is enabled.
 * @param {string} roundingOption.type - Type of rounding: "up", "down", or "nearest".
 * @param {number} roundingOption.increment - The increment to round to (e.g., 0.05, 0.10, 0.99).
 * @returns {number} - The rounded price.
 */
function applyRoundingIfNeeded(price, roundingOption) {
  if (!roundingOption || !roundingOption.enabled) {
    return price; // Return the original price if rounding is disabled.
  }

  const { type, increment } = roundingOption;

  switch (type) {
    case 'up':
      return Math.ceil(price / increment) * increment;
    case 'down':
      return Math.floor(price / increment) * increment;
    case 'nearest':
    default:
      return Math.round(price / increment) * increment;
  }
}

module.exports = {
  applyRoundingIfNeeded,
};

================
File: src/services/providerIntegrationService.js
================
const axios = require('axios');
const logger = require('./logger');

class ProviderIntegrationService {
  async syncData(provider) {
    try {
      const apiSettings = provider.apiSettings;
      const response = await axios.post(`${apiSettings.baseUrl}/sync`, {}, {
        headers: {
          Authorization: `Bearer ${apiSettings.apiKey}`,
          'Content-Type': 'application/json',
        },
      });

      if (response.status === 200) {
        logger.info(`Provider data synced successfully for provider ${provider.name}`);
      } else {
        logger.error(`Provider data sync failed: ${response.data.message}`);
      }
    } catch (error) {
      logger.error(`Error syncing provider data: ${error.message}`);
      throw new Error('Error syncing provider data');
    }
  }
}

module.exports = new ProviderIntegrationService();

================
File: src/services/providerService.js
================
const { Provider, ProviderSettings, ProviderIntegration } = require('../models');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const getAllProviders = async (clientId) => {
  try {
    return await Provider.findAll({ where: { clientId } });
  } catch (error) {
    logger.error('Error fetching all providers:', error);
    throw new AppError('Failed to fetch providers', 500);
  }
};

const getProviderById = async (id) => {
  try {
    const provider = await Provider.findByPk(id);
    if (!provider) {
      throw new AppError('Provider not found', 404);
    }
    return provider;
  } catch (error) {
    logger.error(`Error fetching provider with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to fetch provider', 500);
  }
};

const createProvider = async (providerData) => {
  try {
    const newProvider = await Provider.create(providerData);
    logger.info(`New provider created with ID: ${newProvider.id}`);
    return newProvider;
  } catch (error) {
    logger.error('Error creating provider:', error);
    throw new AppError('Failed to create provider', 500);
  }
};

const updateProvider = async (id, providerData) => {
  try {
    const provider = await getProviderById(id);
    const updatedProvider = await provider.update(providerData);
    logger.info(`Provider updated with ID: ${id}`);
    return updatedProvider;
  } catch (error) {
    logger.error(`Error updating provider with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to update provider', 500);
  }
};

const deleteProvider = async (id) => {
  try {
    const provider = await getProviderById(id);
    await provider.destroy();
    logger.info(`Provider deleted with ID: ${id}`);
    return true;
  } catch (error) {
    logger.error(`Error deleting provider with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to delete provider', 500);
  }
};

const syncProviderData = async (id) => {
  try {
    const provider = await getProviderById(id);
    // Implement provider-specific sync logic here
    logger.info(`Provider data synced for ID: ${id}`);
    return true;
  } catch (error) {
    logger.error(`Error syncing provider data for ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to sync provider data', 500);
  }
};

const getProviderSettings = async (id) => {
  try {
    const settings = await ProviderSettings.findOne({ where: { providerId: id } });
    if (!settings) {
      throw new AppError('Provider settings not found', 404);
    }
    return settings;
  } catch (error) {
    logger.error(`Error fetching settings for provider ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to fetch provider settings', 500);
  }
};

const updateProviderSettings = async (id, settingsData) => {
  try {
    const [settings, created] = await ProviderSettings.findOrCreate({
      where: { providerId: id },
      defaults: settingsData
    });
    if (!created) {
      await settings.update(settingsData);
    }
    logger.info(`Provider settings updated for ID: ${id}`);
    return settings;
  } catch (error) {
    logger.error(`Error updating settings for provider ${id}:`, error);
    throw new AppError('Failed to update provider settings', 500);
  }
};

const getProviderIntegrations = async (id) => {
  try {
    return await ProviderIntegration.findAll({ where: { providerId: id } });
  } catch (error) {
    logger.error(`Error fetching integrations for provider ${id}:`, error);
    throw new AppError('Failed to fetch provider integrations', 500);
  }
};

const addProviderIntegration = async (id, integrationData) => {
  try {
    const newIntegration = await ProviderIntegration.create({ ...integrationData, providerId: id });
    logger.info(`New integration added for provider ID: ${id}`);
    return newIntegration;
  } catch (error) {
    logger.error(`Error adding integration for provider ${id}:`, error);
    throw new AppError('Failed to add provider integration', 500);
  }
};

const updateProviderIntegration = async (providerId, integrationId, integrationData) => {
  try {
    const integration = await ProviderIntegration.findOne({
      where: { id: integrationId, providerId }
    });
    if (!integration) {
      throw new AppError('Provider integration not found', 404);
    }
    const updatedIntegration = await integration.update(integrationData);
    logger.info(`Integration updated for provider ID: ${providerId}, integration ID: ${integrationId}`);
    return updatedIntegration;
  } catch (error) {
    logger.error(`Error updating integration ${integrationId} for provider ${providerId}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to update provider integration', 500);
  }
};

const deleteProviderIntegration = async (providerId, integrationId) => {
  try {
    const integration = await ProviderIntegration.findOne({
      where: { id: integrationId, providerId }
    });
    if (!integration) {
      throw new AppError('Provider integration not found', 404);
    }
    await integration.destroy();
    logger.info(`Integration deleted for provider ID: ${providerId}, integration ID: ${integrationId}`);
    return true;
  } catch (error) {
    logger.error(`Error deleting integration ${integrationId} for provider ${providerId}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to delete provider integration', 500);
  }
};

module.exports = {
  getAllProviders,
  getProviderById,
  createProvider,
  updateProvider,
  deleteProvider,
  syncProviderData,
  getProviderSettings,
  updateProviderSettings,
  getProviderIntegrations,
  addProviderIntegration,
  updateProviderIntegration,
  deleteProviderIntegration
};

================
File: src/services/reportingService.js
================
const { Order, OrderItem, Product } = require '../models';
const { Op } = require 'sequelize';

const getSalesByCategory = async (startDate, endDate) => {
  const sales = await OrderItem.findAll({
    include: [
      {
        model,
        where: {
          createdAt: {
            [Op.between]: [startDate, endDate],
          },
        },
      },
      {
        model,
        include: ['Category'],
      },
    ],
    attributes: [
      'Product.Category.name',
      [sequelize.fn('SUM', sequelize.col('OrderItem.quantity')), 'totalQuantity'],
      [sequelize.fn('SUM', sequelize.col('OrderItem.price')), 'totalSales'],
    ],
    group: ['Product.Category.name'],
  });

  return sales;
};

const getTopSellingItems = async (startDate, endDate, limit = 10) => {
  const topItems = await OrderItem.findAll({
    include: [
      {
        model,
        where: {
          createdAt: {
            [Op.between]: [startDate, endDate],
          },
        },
      },
      {
        model,
      },
    ],
    attributes: [
      'Product.name',
      [sequelize.fn('SUM', sequelize.col('OrderItem.quantity')), 'totalQuantity'],
      [sequelize.fn('SUM', sequelize.col('OrderItem.price')), 'totalSales'],
    ],
    group: ['Product.id'],
    order: [[sequelize.fn('SUM', sequelize.col('OrderItem.quantity')), 'DESC']],
    limit,
  });

  return topItems;
};

================
File: src/services/reportService.js
================
const { Report } = require('../models');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const generateReport = async (reportData) => {
  try {
    const newReport = await Report.create(reportData);
    logger.info(`New report generated with ID: ${newReport.id}`);
    return newReport;
  } catch (error) {
    logger.error('Error generating report:', error);
    throw new AppError('Failed to generate report', 500);
  }
};

const getReportById = async (id) => {
  try {
    const report = await Report.findByPk(id);
    if (!report) {
      throw new AppError('Report not found', 404);
    }
    return report;
  } catch (error) {
    logger.error(`Error fetching report with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to fetch report', 500);
  }
};

const getClientReports = async (clientId) => {
  try {
    return await Report.findAll({ where: { clientId } });
  } catch (error) {
    logger.error(`Error fetching reports for client ${clientId}:`, error);
    throw new AppError('Failed to fetch client reports', 500);
  }
};

const updateReport = async (id, reportData) => {
  try {
    const report = await Report.findByPk(id);
    if (!report) {
      throw new AppError('Report not found', 404);
    }
    const updatedReport = await report.update(reportData);
    logger.info(`Report updated with ID: ${id}`);
    return updatedReport;
  } catch (error) {
    logger.error(`Error updating report with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to update report', 500);
  }
};

const deleteReport = async (id) => {
  try {
    const report = await Report.findByPk(id);
    if (!report) {
      throw new AppError('Report not found', 404);
    }
    await report.destroy();
    logger.info(`Report deleted with ID: ${id}`);
    return true;
  } catch (error) {
    logger.error(`Error deleting report with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to delete report', 500);
  }
};

module.exports = {
  generateReport,
  getReportById,
  getClientReports,
  updateReport,
  deleteReport
};

================
File: src/services/reviewService.js
================
const { Review, MenuItem } = require('../models');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const createReview = async (reviewData) => {
  try {
    const newReview = await Review.create(reviewData);
    logger.info(`New review created with ID: ${newReview.id}`);
    return newReview;
  } catch (error) {
    logger.error('Error creating review:', error);
    throw new AppError('Failed to create review', 500);
  }
};

const getReviewsForMenuItem = async (menuItemId) => {
  try {
    const reviews = await Review.findAll({
      where: { menuItemId },
      include: [{ model: MenuItem, as: 'menuItem' }]
    });
    return reviews;
  } catch (error) {
    logger.error(`Error fetching reviews for menu item ${menuItemId}:`, error);
    throw new AppError('Failed to fetch reviews for menu item', 500);
  }
};

const getReviewById = async (id) => {
  try {
    const review = await Review.findByPk(id, {
      include: [{ model: MenuItem, as: 'menuItem' }]
    });
    if (!review) {
      throw new AppError('Review not found', 404);
    }
    return review;
  } catch (error) {
    logger.error(`Error fetching review with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to fetch review', 500);
  }
};

const updateReview = async (id, reviewData) => {
  try {
    const review = await Review.findByPk(id);
    if (!review) {
      throw new AppError('Review not found', 404);
    }
    const updatedReview = await review.update(reviewData);
    logger.info(`Review updated with ID: ${id}`);
    return updatedReview;
  } catch (error) {
    logger.error(`Error updating review with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to update review', 500);
  }
};

const deleteReview = async (id) => {
  try {
    const review = await Review.findByPk(id);
    if (!review) {
      throw new AppError('Review not found', 404);
    }
    await review.destroy();
    logger.info(`Review deleted with ID: ${id}`);
    return true;
  } catch (error) {
    logger.error(`Error deleting review with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to delete review', 500);
  }
};

const getAverageRatingForMenuItem = async (menuItemId) => {
  try {
    const result = await Review.findAll({
      where: { menuItemId },
      attributes: [
        [Review.sequelize.fn('AVG', Review.sequelize.col('rating')), 'averageRating']
      ]
    });
    return result[0].get('averageRating') || 0;
  } catch (error) {
    logger.error(`Error calculating average rating for menu item ${menuItemId}:`, error);
    throw new AppError('Failed to calculate average rating', 500);
  }
};

module.exports = {
  createReview,
  getReviewsForMenuItem,
  getReviewById,
  updateReview,
  deleteReview,
  getAverageRatingForMenuItem
};

================
File: src/services/roleService.js
================
const Role = require('../models/Role');
const Permission = require('../models/Permission');

exports.createRole = async (roleData) => {
  try {
    const role = await Role.create(roleData);
    return role;
  } catch (error) {
    throw new Error('Error creating role: ' + error.message);
  }
};

exports.assignPermissionsToRole = async (roleId, permissionIds) => {
  try {
    const role = await Role.findByPk(roleId);
    if (!role) throw new Error('Role not found');

    const permissions = await Permission.findAll({ where: { id: permissionIds } });
    await role.setPermissions(permissions);
    return role;
  } catch (error) {
    throw new Error('Error assigning permissions: ' + error.message);
  }
};

================
File: src/services/s3Service.js
================
const AWS = require('aws-sdk');
const { v4: uuidv4 } = require('uuid');

const s3 = new AWS.S3({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY
});

const uploadToS3 = async (buffer, originalname, tenantId) => {
  const key = `${tenantId}/${uuidv4()}-${originalname}`;
  const params = {
    Bucket: process.env.S3_BUCKET_NAME,
    Key: key,
    Body: buffer
  };

  const { Location } = await s3.upload(params).promise();
  return Location;
};

const deleteFromS3 = async (url) => {
  const key = url.split('/').slice(-1)[0];
  const params = {
    Bucket: process.env.S3_BUCKET_NAME,
    Key: key
  };

  await s3.deleteObject(params).promise();
};

module.exports = {
  uploadToS3,
  deleteFromS3
};

================
File: src/services/scheduledOrderService.js
================
const { Op } = require 'sequelize';
const ScheduledOrder = require '../models/ScheduledOrder';
const Order = require '../models/Order';
const { sendOrderToPOS } = require '../utils/posIntegration';

const processScheduledOrders = async () => {
  const now = new Date();
  const scheduledOrders = await ScheduledOrder.findAll({
    where: {
      scheduledTime: {
        [Op.lte],
      },
      sentToPOS,
    },
    include: [Order],
  });

  for (const scheduledOrder of scheduledOrders) {
    await sendOrderToPOS(scheduledOrder.Order);
    await scheduledOrder.update({ sentToPOS });
  }
};

================
File: src/services/schedulingService.js
================
const { TimeSlot, Order } = require '../models';
const { Op } = require 'sequelize';

const getAvailableTimeSlots = async (date) => {
  const startOfDay = new Date(date.setHours(0, 0, 0, 0));
  const endOfDay = new Date(date.setHours(23, 59, 59, 999));

  return TimeSlot.findAll({
    where: {
      startTime: {
        [Op.between]: [startOfDay, endOfDay],
      },
      bookedCount: {
        [Op.lt].col('capacity'),
      },
    },
  });
};

const bookTimeSlot = async (timeSlotId, orderId) => {
  const timeSlot = await TimeSlot.findByPk(timeSlotId);
  if (!timeSlot || timeSlot.bookedCount >= timeSlot.capacity) {
    throw new Error('Time slot not available');
  }

  await timeSlot.increment('bookedCount');
  await Order.update({ timeSlotId }, { where: { id } });
};

================
File: src/services/serviceFeeService.js
================
const { ServiceFee } = require('../models');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const getAllServiceFees = async () => {
  try {
    return await ServiceFee.findAll();
  } catch (error) {
    logger.error('Error fetching all service fees:', error);
    throw new AppError('Failed to fetch service fees', 500);
  }
};

const getServiceFeeById = async (id) => {
  try {
    const serviceFee = await ServiceFee.findByPk(id);
    if (!serviceFee) {
      throw new AppError('Service fee not found', 404);
    }
    return serviceFee;
  } catch (error) {
    logger.error(`Error fetching service fee with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to fetch service fee', 500);
  }
};

const createServiceFee = async (serviceFeeData) => {
  try {
    const newServiceFee = await ServiceFee.create(serviceFeeData);
    logger.info(`New service fee created with ID: ${newServiceFee.id}`);
    return newServiceFee;
  } catch (error) {
    logger.error('Error creating service fee:', error);
    throw new AppError('Failed to create service fee', 500);
  }
};

const updateServiceFee = async (id, serviceFeeData) => {
  try {
    const serviceFee = await ServiceFee.findByPk(id);
    if (!serviceFee) {
      throw new AppError('Service fee not found', 404);
    }
    const updatedServiceFee = await serviceFee.update(serviceFeeData);
    logger.info(`Service fee updated with ID: ${id}`);
    return updatedServiceFee;
  } catch (error) {
    logger.error(`Error updating service fee with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to update service fee', 500);
  }
};

const deleteServiceFee = async (id) => {
  try {
    const serviceFee = await ServiceFee.findByPk(id);
    if (!serviceFee) {
      throw new AppError('Service fee not found', 404);
    }
    await serviceFee.destroy();
    logger.info(`Service fee deleted with ID: ${id}`);
    return true;
  } catch (error) {
    logger.error(`Error deleting service fee with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to delete service fee', 500);
  }
};

const getServiceFeesByClient = async (clientId) => {
  try {
    return await ServiceFee.findAll({ where: { clientId } });
  } catch (error) {
    logger.error(`Error fetching service fees for client ${clientId}:`, error);
    throw new AppError('Failed to fetch service fees for client', 500);
  }
};

module.exports = {
  getAllServiceFees,
  getServiceFeeById,
  createServiceFee,
  updateServiceFee,
  deleteServiceFee,
  getServiceFeesByClient
};

================
File: src/services/subscriptionService.js
================
const { Subscription, Order } = require '../models';
const { createOrder } = require './orderService';

const createSubscription = async (userId, planId) => {
  const nextBillingDate = new Date();
  nextBillingDate.setMonth(nextBillingDate.getMonth() + 1);

  return await Subscription.create({
    userId,
    planId,
    status: 'active',
    nextBillingDate,
  });
};

const processSubscriptions = async () => {
  const activeSubscriptions = await Subscription.findAll({
    where: {
      status: 'active',
      nextBillingDate: {
        [Op.lte] Date(),
      },
    },
  });

  for (const subscription of activeSubscriptions) {
    await createOrder({
      userId.userId,
      items: [{ id.planId, quantity: 1 }],
      isSubscription,
    });

    const nextBillingDate = new Date(subscription.nextBillingDate);
    nextBillingDate.setMonth(nextBillingDate.getMonth() + 1);
    await subscription.update({ nextBillingDate });
  }
};

================
File: src/services/syncEngine.js
================
const PosSyncService = require('./posSyncService');
const ToastService = require('./toastService');
const db = require('../models');

class SyncEngine {
  static async syncMenus(locationId) {
    try {
      const posProfiles = await db.PosProfile.findAll({ where: { locationId } });

      for (const profile of posProfiles) {
        if (profile.posSystem === 'toast') {
          const toastService = new ToastService();
          await toastService.syncMenus(profile);
        } else {
          await PosSyncService.syncMenus(profile);
        }
      }
      console.log(`Menus synced successfully for location ${locationId}`);
    } catch (error) {
      console.error(`Error syncing menus for location ${locationId}:`, error);
    }
  }

  static async syncMenuGroups(locationId) {
    try {
      const posProfiles = await db.PosProfile.findAll({ where: { locationId } });

      for (const profile of posProfiles) {
        if (profile.posSystem === 'toast') {
          const toastService = new ToastService();
          await toastService.syncMenuGroups(profile);
        } else {
          await PosSyncService.syncMenuGroups(profile);
        }
      }
      console.log(`Menu groups synced successfully for location ${locationId}`);
    } catch (error) {
      console.error(`Error syncing menu groups for location ${locationId}:`, error);
    }
  }

  static async syncMenuItems(locationId) {
    try {
      const posProfiles = await db.PosProfile.findAll({ where: { locationId } });

      for (const profile of posProfiles) {
        if (profile.posSystem === 'toast') {
          const toastService = new ToastService();
          await toastService.syncMenuItems(profile);
        } else {
          await PosSyncService.syncMenuItems(profile);
        }
      }
      console.log(`Menu items synced successfully for location ${locationId}`);
    } catch (error) {
      console.error(`Error syncing menu items for location ${locationId}:`, error);
    }
  }
}

module.exports = SyncEngine;

================
File: src/services/syncService.js
================
const logger = require('../utils/logger'); // Assuming you have a logger utility in place

class SyncService {
  // Method to start all data sync jobs
  static async startDataSyncJobs() {
    try {
      logger.info('Starting data sync jobs...');

      // Run each sync job sequentially
      await this.syncPosData();
      await this.syncProviderData();

      logger.info('Data sync jobs completed successfully.');
    } catch (error) {
      logger.error('Error during data sync jobs:', error);
      throw error; // Re-throw to allow handling at higher levels if needed
    }
  }

  // Example of a method to sync POS data
  static async syncPosData() {
    try {
      logger.info('Syncing POS data...');
      // Placeholder for your POS data sync logic
      // Your sync logic here
      logger.info('POS data sync completed.');
    } catch (error) {
      logger.error('Error syncing POS data:', error);
      throw error;
    }
  }

  // Example of a method to sync provider data
  static async syncProviderData() {
    try {
      logger.info('Syncing provider data...');
      // Placeholder for your provider data sync logic
      // Your sync logic here
      logger.info('Provider data sync completed.');
    } catch (error) {
      logger.error('Error syncing provider data:', error);
      throw error;
    }
  }

  // You can add more sync methods here as needed for different data types
}

module.exports = SyncService;

================
File: src/services/tabletService.js
================
const { Tablet } = require('../models');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const getAllTablets = async () => {
  try {
    return await Tablet.findAll();
  } catch (error) {
    logger.error('Error fetching all tablets:', error);
    throw new AppError('Failed to fetch tablets', 500);
  }
};

const getTabletById = async (id) => {
  try {
    const tablet = await Tablet.findByPk(id);
    if (!tablet) {
      throw new AppError('Tablet not found', 404);
    }
    return tablet;
  } catch (error) {
    logger.error(`Error fetching tablet with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to fetch tablet', 500);
  }
};

const createTablet = async (tabletData) => {
  try {
    const newTablet = await Tablet.create(tabletData);
    logger.info(`New tablet created with ID: ${newTablet.id}`);
    return newTablet;
  } catch (error) {
    logger.error('Error creating tablet:', error);
    throw new AppError('Failed to create tablet', 500);
  }
};

const updateTablet = async (id, tabletData) => {
  try {
    const tablet = await getTabletById(id);
    const updatedTablet = await tablet.update(tabletData);
    logger.info(`Tablet updated with ID: ${id}`);
    return updatedTablet;
  } catch (error) {
    logger.error(`Error updating tablet with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to update tablet', 500);
  }
};

const deleteTablet = async (id) => {
  try {
    const tablet = await getTabletById(id);
    await tablet.destroy();
    logger.info(`Tablet deleted with ID: ${id}`);
    return true;
  } catch (error) {
    logger.error(`Error deleting tablet with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to delete tablet', 500);
  }
};

const getTabletsByLocation = async (locationId) => {
  try {
    return await Tablet.findAll({ where: { locationId } });
  } catch (error) {
    logger.error(`Error fetching tablets for location ${locationId}:`, error);
    throw new AppError('Failed to fetch tablets for location', 500);
  }
};

const syncTabletData = async (id) => {
  try {
    const tablet = await getTabletById(id);
    // Implement sync logic here
    logger.info(`Data synced for tablet with ID: ${id}`);
    return { message: 'Tablet data synced successfully' };
  } catch (error) {
    logger.error(`Error syncing data for tablet with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to sync tablet data', 500);
  }
};

module.exports = {
  getAllTablets,
  getTabletById,
  createTablet,
  updateTablet,
  deleteTablet,
  getTabletsByLocation,
  syncTabletData
};

================
File: src/services/taxService.js
================
const { TaxRate, LocationTaxConfig } = require('../models');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const getAllTaxRates = async () => {
  try {
    return await TaxRate.findAll();
  } catch (error) {
    logger.error('Error fetching all tax rates:', error);
    throw new AppError('Failed to fetch tax rates', 500);
  }
};

const getTaxRateById = async (id) => {
  try {
    const taxRate = await TaxRate.findByPk(id);
    if (!taxRate) {
      throw new AppError('Tax rate not found', 404);
    }
    return taxRate;
  } catch (error) {
    logger.error(`Error fetching tax rate with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to fetch tax rate', 500);
  }
};

const createTaxRate = async (taxRateData) => {
  try {
    const newTaxRate = await TaxRate.create(taxRateData);
    logger.info(`New tax rate created with ID: ${newTaxRate.id}`);
    return newTaxRate;
  } catch (error) {
    logger.error('Error creating tax rate:', error);
    throw new AppError('Failed to create tax rate', 500);
  }
};

const updateTaxRate = async (id, taxRateData) => {
  try {
    const taxRate = await getTaxRateById(id);
    const updatedTaxRate = await taxRate.update(taxRateData);
    logger.info(`Tax rate updated with ID: ${id}`);
    return updatedTaxRate;
  } catch (error) {
    logger.error(`Error updating tax rate with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to update tax rate', 500);
  }
};

const deleteTaxRate = async (id) => {
  try {
    const taxRate = await getTaxRateById(id);
    await taxRate.destroy();
    logger.info(`Tax rate deleted with ID: ${id}`);
    return true;
  } catch (error) {
    logger.error(`Error deleting tax rate with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to delete tax rate', 500);
  }
};

const getTaxRatesByLocation = async (locationId) => {
  try {
    return await TaxRate.findAll({ where: { locationId } });
  } catch (error) {
    logger.error(`Error fetching tax rates for location ${locationId}:`, error);
    throw new AppError('Failed to fetch tax rates for location', 500);
  }
};

const calculateTax = async (locationId, items) => {
  try {
    const taxRates = await getTaxRatesByLocation(locationId);
    const totalAmount = items.reduce((sum, item) => sum + item.price * item.quantity, 0);
    const taxAmount = taxRates.reduce((sum, rate) => sum + totalAmount * (rate.percentage / 100), 0);
    return Number(taxAmount.toFixed(2));
  } catch (error) {
    logger.error(`Error calculating tax for location ${locationId}:`, error);
    throw new AppError('Failed to calculate tax', 500);
  }
};

const getApplicableTax = async (locationId, provider, guestId = null) => {
  try {
    const locationTaxConfig = await LocationTaxConfig.findOne({
      where: { locationId, provider },
    });

    if (guestId) {
      const guest = await Guest.findByPk(guestId);
      if (guest && guest.taxExempt) {
        return { rate: 0, taxId: guest.taxIdNumber };
      }
    }

    if (!locationTaxConfig) {
      return { rate: 0, taxId: null };
    }

    return { rate: locationTaxConfig.taxRate, taxId: locationTaxConfig.taxIdNumber };
  } catch (error) {
    logger.error('Error fetching applicable tax:', error);
    throw new AppError('Failed to fetch applicable tax', 500);
  }
};

const updateTaxSettings = async (locationId, provider, taxRate, taxIdNumber = null) => {
  try {
    const [taxConfig, created] = await LocationTaxConfig.findOrCreate({
      where: { locationId, provider },
      defaults: { taxRate, taxIdNumber },
    });

    if (!created) {
      taxConfig.taxRate = taxRate;
      taxConfig.taxIdNumber = taxIdNumber;
      await taxConfig.save();
    }

    return taxConfig;
  } catch (error) {
    logger.error('Error updating tax settings:', error);
    throw new AppError('Failed to update tax settings', 500);
  }
};

module.exports = {
  getAllTaxRates,
  getTaxRateById,
  createTaxRate,
  updateTaxRate,
  deleteTaxRate,
  getTaxRatesByLocation,
  calculateTax,
  getApplicableTax,
  updateTaxSettings
};

================
File: src/services/toastService.js
================
const axios = require('axios');
const logger = require('../utils/logger');
const db = require('../models');

class ToastService {
  async authenticate(clientId, clientSecret) {
    try {
      const response = await axios.post('https://api.toasttab.com/authentication/v1/authentication/login', {
        clientId,
        clientSecret,
        userAccessType: 'TOAST_MACHINE_CLIENT',
      }, {
        headers: { 'Content-Type': 'application/json' },
      });

      return response.data;
    } catch (error) {
      logger.error('Error during Toast authentication:', error);
      throw error;
    }
  }

  async getMenu(token, restaurantId) {
    try {
      const response = await axios.get(`https://api.toasttab.com/menus/v3/menus`, {
        headers: {
          'Toast-Restaurant-External-ID': restaurantId,
          Authorization: `Bearer ${token}`,
        },
      });

      const data = response.data;

      return data.map(menu => ({
        ...menu,
        groups: menu.groups.map(group => ({
          ...group,
          imageUrl: group.images?.[0]?.url || null,
          items: group.items.map(item => ({
            ...item,
            imageUrl: item.images?.[0]?.url || null,
          })),
        })),
      }));
    } catch (error) {
      logger.error('Error fetching menu from Toast:', error);
      throw error;
    }
  }

  async handleMenusUpdated(payload) {
    try {
      const { restaurantGuid, publishedDate } = payload;
      const menuData = await this.getMenu(restaurantGuid); // Fetch menu data

      // Log the received menu data for debugging
      logger.info(`Received menu data: ${JSON.stringify(menuData)}`);

      // Process and store the menu data in the database
      await db.Menu.update({ updatedAt: publishedDate }, {
        where: { restaurantGuid },
      });

      // Additional processing or storage logic for menuData can be added here
      logger.info(`Successfully updated menu for restaurant ${restaurantGuid}`);
    } catch (error) {
      logger.error(`Error handling menus_updated webhook:`, error);
      throw error;
    }
  }
}

module.exports = new ToastService();

================
File: src/services/trackingPixelService.js
================
const { TrackingPixel } = require('../models');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const createPixel = async (pixelData) => {
  try {
    const newPixel = await TrackingPixel.create(pixelData);
    logger.info(`New tracking pixel created with ID: ${newPixel.id}`);
    return newPixel;
  } catch (error) {
    logger.error('Error creating tracking pixel:', error);
    throw new AppError('Failed to create tracking pixel', 500);
  }
};

const getAllPixels = async () => {
  try {
    return await TrackingPixel.findAll();
  } catch (error) {
    logger.error('Error fetching all tracking pixels:', error);
    throw new AppError('Failed to fetch tracking pixels', 500);
  }
};

const getPixelById = async (id) => {
  try {
    const pixel = await TrackingPixel.findByPk(id);
    if (!pixel) {
      throw new AppError('Tracking pixel not found', 404);
    }
    return pixel;
  } catch (error) {
    logger.error(`Error fetching tracking pixel with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to fetch tracking pixel', 500);
  }
};

const updatePixel = async (id, pixelData) => {
  try {
    const pixel = await getPixelById(id);
    const updatedPixel = await pixel.update(pixelData);
    logger.info(`Tracking pixel updated with ID: ${id}`);
    return updatedPixel;
  } catch (error) {
    logger.error(`Error updating tracking pixel with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to update tracking pixel', 500);
  }
};

const deletePixel = async (id) => {
  try {
    const pixel = await getPixelById(id);
    await pixel.destroy();
    logger.info(`Tracking pixel deleted with ID: ${id}`);
    return true;
  } catch (error) {
    logger.error(`Error deleting tracking pixel with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to delete tracking pixel', 500);
  }
};

const triggerPixel = async (id) => {
  try {
    const pixel = await getPixelById(id);
    // Implement pixel triggering logic here
    logger.info(`Tracking pixel triggered with ID: ${id}`);
    return { message: 'Tracking pixel triggered successfully' };
  } catch (error) {
    logger.error(`Error triggering tracking pixel with ID ${id}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to trigger tracking pixel', 500);
  }
};

module.exports = {
  createPixel,
  getAllPixels,
  getPixelById,
  updatePixel,
  deletePixel,
  triggerPixel
};

================
File: src/services/translatorService.js
================
const { Translation } = require('../models');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');
// Import your preferred translation API library here

const translateText = async (text, targetLanguage, sourceLanguage = 'auto') => {
  try {
    // Implement translation logic here using your preferred translation API
    // This is a placeholder implementation
    const translatedText = `Translated: ${text}`;
    
    // Save translation to history
    await Translation.create({
      originalText: text,
      translatedText,
      sourceLanguage,
      targetLanguage
    });

    return translatedText;
  } catch (error) {
    logger.error('Error translating text:', error);
    throw new AppError('Failed to translate text', 500);
  }
};

const getSupportedLanguages = async () => {
  try {
    // Implement logic to fetch supported languages from your translation API
    // This is a placeholder implementation
    return ['en', 'es', 'fr', 'de', 'it'];
  } catch (error) {
    logger.error('Error fetching supported languages:', error);
    throw new AppError('Failed to fetch supported languages', 500);
  }
};

const detectLanguage = async (text) => {
  try {
    // Implement language detection logic here
    // This is a placeholder implementation
    return 'en';
  } catch (error) {
    logger.error('Error detecting language:', error);
    throw new AppError('Failed to detect language', 500);
  }
};

const translateMenu = async (menuId, targetLanguage) => {
  try {
    // Implement menu translation logic here
    // This is a placeholder implementation
    return { menuId, targetLanguage, status: 'translated' };
  } catch (error) {
    logger.error('Error translating menu:', error);
    throw new AppError('Failed to translate menu', 500);
  }
};

const getTranslationHistory = async (query) => {
  try {
    return await Translation.findAll({
      where: query,
      order: [['createdAt', 'DESC']],
      limit: 100
    });
  } catch (error) {
    logger.error('Error fetching translation history:', error);
    throw new AppError('Failed to fetch translation history', 500);
  }
};

module.exports = {
  translateText,
  getSupportedLanguages,
  detectLanguage,
  translateMenu,
  getTranslationHistory
};

================
File: src/services/twoFactorService.js
================
const speakeasy = require('speakeasy');
const { User, ClientSettings, Location } = require('../models');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

const generateSecret = () => {
  return speakeasy.generateSecret({ length: 32 });
};

const verifyToken = (secret, token) => {
  return speakeasy.totp.verify({
    secret,
    encoding: 'base32',
    token,
  });
};

const enableTwoFactor = async (userId) => {
  try {
    const secret = generateSecret();
    await User.update(
      { 
        twoFactorSecret: secret.base32, 
        twoFactorEnabled: true 
      },
      { where: { id: userId } }
    );
    return secret.otpauth_url;
  } catch (error) {
    logger.error(`Error enabling 2FA for user ${userId}:`, error);
    throw new AppError('Failed to enable 2FA', 500);
  }
};

const disableTwoFactor = async (userId) => {
  try {
    await User.update(
      { 
        twoFactorSecret: null, 
        twoFactorEnabled: false 
      },
      { where: { id: userId } }
    );
  } catch (error) {
    logger.error(`Error disabling 2FA for user ${userId}:`, error);
    throw new AppError('Failed to disable 2FA', 500);
  }
};

const isTwoFactorRequired = async (userId, locationId) => {
  try {
    const user = await User.findByPk(userId);
    if (!user) {
      throw new AppError('User not found', 404);
    }

    const clientSettings = await ClientSettings.findOne({ where: { clientId: user.clientId } });
    if (!clientSettings) {
      throw new AppError('Client settings not found', 404);
    }

    const location = await Location.findByPk(locationId);

    if (!clientSettings.twoFactorRequired) {
      return false;
    }

    if (location && location.twoFactorException) {
      return false;
    }

    return true;
  } catch (error) {
    logger.error(`Error checking if 2FA is required for user ${userId} at location ${locationId}:`, error);
    throw error instanceof AppError ? error : new AppError('Failed to check 2FA requirement', 500);
  }
};

const validateTwoFactor = async (userId, token, locationId) => {
  try {
    const user = await User.findByPk(userId);
    if (!user || !user.twoFactorSecret) {
      return false;
    }

    const isRequired = await isTwoFactorRequired(userId, locationId);
    if (!isRequired) {
      return true; // 2FA is not required, so we consider it valid
    }

    return verifyToken(user.twoFactorSecret, token);
  } catch (error) {
    logger.error(`Error validating 2FA for user ${userId}:`, error);
    throw new AppError('Failed to validate 2FA', 500);
  }
};

module.exports = {
  enableTwoFactor,
  disableTwoFactor,
  isTwoFactorRequired,
  validateTwoFactor
};

================
File: src/services/userService.js
================
const { Op } = require('sequelize');
const bcrypt = require('bcrypt');
const { User } = require('../models');
const { UserRole } = require('../types/enums');
const { CreateUserDto, UpdateUserDto } = require('../types/dto/user');
const { NotFoundError, ConflictError } = require('../utils/errors');

const createUser = async (userData) => {
  const existingUser = await User.findOne({
    where: {
      [Op.or]: [{ username: userData.username }, { email: userData.email }],
    },
  });

  if (existingUser) {
    throw new ConflictError('Username or email already exists');
  }

  const hashedPassword = await bcrypt.hash(userData.password, 10);
  const newUser = await User.create({
    ...userData,
    password: hashedPassword,
  });

  return newUser;
};

const getUserById = async (id) => {
  const user = await User.findByPk(id);
  if (!user) {
    throw new NotFoundError('User not found');
  }
  return user;
};

const updateUser = async (id, updateData) => {
  const user = await getUserById(id);
  
  if (updateData.password) {
    updateData.password = await bcrypt.hash(updateData.password, 10);
  }

  await user.update(updateData);
  return user;
};

const deleteUser = async (id) => {
  const user = await getUserById(id);
  await user.destroy();
};

const getUserByUsername = async (username) => {
  return User.findOne({ where: { username } });
};

module.exports = {
  createUser,
  getUserById,
  updateUser,
  deleteUser,
  getUserByUsername,
};

================
File: src/services/walletDropService.js
================
const WalletDrop = require '../models/WalletDrop';
const logger = require '../utils/logger';

const createWalletDrop = async (
  userId,
  type: 'credit' | 'percentage' | 'fixed' | 'item',
  value,
  reason,
  itemId?,
  expirationDate?
) => {
  try {
    const walletDrop = await WalletDrop.create({ userId, type, value, reason, itemId, expirationDate });
    logger.info(`Wallet drop created: ${walletDrop.id}`);
    return walletDrop;
  } catch (error) {
    logger.error('Error creating wallet drop:', error);
    throw error;
  }
};

const getWalletDropsByUser = async (userId) => {
  try {
    return await WalletDrop.findAll({ where: { userId } });
  } catch (error) {
    logger.error('Error fetching wallet drops:', error);
    throw error;
  }
};

// Add more methods  (update, delete, etc.)

================
File: src/services/walletService.js
================
const { Wallet, Guest, Discount, LoyaltyReward, Transaction } = require('../models');
const { AppError } = require('../utils/errorHandler');
const logger = require('../utils/logger');

class WalletService {
  static async getWalletBalance(guestId) {
    try {
      const wallet = await Wallet.findOne({
        where: { guestId },
        include: [Guest, LoyaltyReward],
      });

      if (!wallet) {
        throw new AppError('Wallet not found', 404);
      }

      // Calculate total balance including any unused rewards
      const totalBalance = wallet.balance + wallet.LoyaltyRewards.reduce((sum, reward) => sum + reward.value, 0);

      return totalBalance;
    } catch (error) {
      logger.error(`Error fetching wallet balance for guest ${guestId}:`, error);
      throw error instanceof AppError ? error : new AppError('Failed to fetch wallet balance', 500);
    }
  }

  static async addFunds(guestId, amount) {
    try {
      const wallet = await Wallet.findOne({ where: { guestId } });
      if (!wallet) {
        throw new AppError('Wallet not found', 404);
      }

      wallet.balance += amount;
      await wallet.save();

      await Transaction.create({
        walletId: wallet.id,
        type: 'DEPOSIT',
        amount,
        balance: wallet.balance
      });

      return wallet.balance;
    } catch (error) {
      logger.error(`Error adding funds to wallet for guest ${guestId}:`, error);
      throw error instanceof AppError ? error : new AppError('Failed to add funds to wallet', 500);
    }
  }

  static async withdrawFunds(guestId, amount) {
    try {
      const wallet = await Wallet.findOne({ where: { guestId } });
      if (!wallet) {
        throw new AppError('Wallet not found', 404);
      }

      if (wallet.balance < amount) {
        throw new AppError('Insufficient funds', 400);
      }

      wallet.balance -= amount;
      await wallet.save();

      await Transaction.create({
        walletId: wallet.id,
        type: 'WITHDRAWAL',
        amount: -amount,
        balance: wallet.balance
      });

      return wallet.balance;
    } catch (error) {
      logger.error(`Error withdrawing funds from wallet for guest ${guestId}:`, error);
      throw error instanceof AppError ? error : new AppError('Failed to withdraw funds from wallet', 500);
    }
  }

  static async getTransactionHistory(guestId) {
    try {
      const wallet = await Wallet.findOne({ where: { guestId } });
      if (!wallet) {
        throw new AppError('Wallet not found', 404);
      }

      return Transaction.findAll({
        where: { walletId: wallet.id },
        order: [['createdAt', 'DESC']],
        limit: 50
      });
    } catch (error) {
      logger.error(`Error fetching transaction history for guest ${guestId}:`, error);
      throw error instanceof AppError ? error : new AppError('Failed to fetch transaction history', 500);
    }
  }

  static async transferFunds(senderId, recipientId, amount) {
    try {
      const senderWallet = await Wallet.findOne({ where: { guestId: senderId } });
      const recipientWallet = await Wallet.findOne({ where: { guestId: recipientId } });

      if (!senderWallet || !recipientWallet) {
        throw new AppError('Wallet not found', 404);
      }

      if (senderWallet.balance < amount) {
        throw new AppError('Insufficient funds', 400);
      }

      senderWallet.balance -= amount;
      recipientWallet.balance += amount;

      await senderWallet.save();
      await recipientWallet.save();

      await Transaction.create({
        walletId: senderWallet.id,
        type: 'TRANSFER_OUT',
        amount: -amount,
        balance: senderWallet.balance,
        recipientId
      });

      await Transaction.create({
        walletId: recipientWallet.id,
        type: 'TRANSFER_IN',
        amount,
        balance: recipientWallet.balance,
        senderId
      });

      return { message: 'Funds transferred successfully' };
    } catch (error) {
      logger.error(`Error transferring funds from guest ${senderId} to guest ${recipientId}:`, error);
      throw error instanceof AppError ? error : new AppError('Failed to transfer funds', 500);
    }
  }

  static async getWalletDetails(guestId) {
    try {
      const wallet = await Wallet.findOne({
        where: { guestId },
        include: [Guest, LoyaltyReward, Discount]
      });

      if (!wallet) {
        throw new AppError('Wallet not found', 404);
      }

      return wallet;
    } catch (error) {
      logger.error(`Error fetching wallet details for guest ${guestId}:`, error);
      throw error instanceof AppError ? error : new AppError('Failed to fetch wallet details', 500);
    }
  }

  static async addDiscountToWallet(guestId, discountId) {
    try {
      const wallet = await Wallet.findOne({ where: { guestId } });
      if (!wallet) {
        throw new AppError('Wallet not found', 404);
      }

      await Discount.update({ walletId: wallet.id }, { where: { id: discountId } });
      return true;
    } catch (error) {
      logger.error(`Error adding discount to wallet for guest ${guestId}:`, error);
      throw error instanceof AppError ? error : new AppError('Failed to add discount to wallet', 500);
    }
  }

  static async getWalletDiscounts(guestId) {
    try {
      const wallet = await Wallet.findOne({ where: { guestId } });
      if (!wallet) {
        throw new AppError('Wallet not found', 404);
      }

      return await Discount.findAll({ where: { walletId: wallet.id } });
    } catch (error) {
      logger.error(`Error fetching wallet discounts for guest ${guestId}:`, error);
      throw error instanceof AppError ? error : new AppError('Failed to fetch wallet discounts', 500);
    }
  }

  static async applyLoyaltyPoints(guestId, points) {
    try {
      const wallet = await Wallet.findOne({ where: { guestId } });
      if (!wallet) {
        throw new AppError('Wallet not found', 404);
      }

      if (wallet.balance < points) {
        throw new AppError('Insufficient points', 400);
      }

      wallet.balance -= points;
      await wallet.save();

      await Transaction.create({
        walletId: wallet.id,
        type: 'LOYALTY_POINTS_USED',
        amount: -points,
        balance: wallet.balance
      });

      return true;
    } catch (error) {
      logger.error(`Error applying loyalty points for guest ${guestId}:`, error);
      throw error instanceof AppError ? error : new AppError('Failed to apply loyalty points', 500);
    }
  }
}

module.exports = WalletService;

================
File: src/ssl/server.cert
================
-----BEGIN CERTIFICATE-----
MIID6TCCAtGgAwIBAgIUBhIEASF8akIwLFOOrR/OLXiPZF8wDQYJKoZIhvcNAQEL
BQAwgYMxCzAJBgNVBAYTAnVzMQ8wDQYDVQQIDAZuZXZhZGExITAfBgNVBAoMGElu
dGVybmV0IFdpZGdpdHMgUHR5IEx0ZDEWMBQGA1UEAwwNNjQuMjMuMTc4LjE5ODEo
MCYGCSqGSIb3DQEJARYZYnJ5Y2UuYXNwaW53YWxsQGdtYWlsLmNvbTAeFw0yNDA4
MTcxNTMwNTJaFw0yNTA4MTcxNTMwNTJaMIGDMQswCQYDVQQGEwJ1czEPMA0GA1UE
CAwGbmV2YWRhMSEwHwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQxFjAU
BgNVBAMMDTY0LjIzLjE3OC4xOTgxKDAmBgkqhkiG9w0BCQEWGWJyeWNlLmFzcGlu
d2FsbEBnbWFpbC5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDF
P9OohjVJkUeuyuKycXQHY2LiI8jMxCgje/RFGPnyuBFe2R+TcUrEvuWi+WtOoWNZ
+p1KfwilpdG+56EwEVKpnNoWFdAXJJXa4Wu0vWxXHQJ+GENvjbCPY7ikfdRe+7Ou
k5UvoAESF9tvBbjF9JYCTlqhocftn1QIjvJOXt49uJMRvW8pdblKB9FMNjCXjDop
2c7ZrWMKGHNG7p7RnNAcWlxL28+JNE1Uh5Z0o6NDtdJ4+StEDccRLqHvfsd8Ol7a
TSDsPRK7mbUJCblhu8wzyAoGYk4Ym0a7FlBpvr+SmmFOKGUkCk8gOYV2JLBbEEsq
2wHYlAVvYSlHoLzNIN0JAgMBAAGjUzBRMB0GA1UdDgQWBBSfg5uBHa3yEKcAV0ZR
msjfw4ErNTAfBgNVHSMEGDAWgBSfg5uBHa3yEKcAV0ZRmsjfw4ErNTAPBgNVHRMB
Af8EBTADAQH/MA0GCSqGSIb3DQEBCwUAA4IBAQArDRlDSOhZaS9zFSCDy9U0bam8
RMJeXjW3wWRqkg7pl8q7FQXYM2vVmbuBRfsobxcS3jZqXRQXbPEpOewiODyEzru8
b4AvzzOglZHY26SupU1zT6qEPPg20Pjn8PVOAQUhKtv95unAcGc5Bwi1PZgbXfOP
rooTqwfsmoUvjc90U5msA2W4GJTJDgj+hZx6NC9QeyWoLK38L0yZqA6d0mavyj2r
zPLHZ8XfRZIiWvScDx1W152LVRteLlV6gCAjR1on2bszbi5pTQap5BIIQkO2K0Hp
wJx+w35INOVAfwdbpPrIATlnmYUIbnnfKCu7zBxffp+hXgfl4KUM/Jn5X0qH
-----END CERTIFICATE-----

================
File: src/tests/location.test.js
================
const request = require 'supertest';
const app = require '../app';
const { Location } = require '../models/Location';

describe('Location API', () => {
  beforeEach(async () => {
    await Location.deleteMany({});
  });

  it('should create a new location', async () => {
    const res = await request(app)
      .post('/api/locations')
      .send({
        name: 'Test Location',
        address: '123 Test St',
        city: 'Testville',
        state: 'TS',
        zipCode: '12345',
      });
    expect(res.statusCode).toEqual(201);
    expect(res.body).toHaveProperty('name', 'Test Location');
  });

  // Add more tests...
});

================
File: src/translator/providerConfigs.js
================
const providerConfigs = {
  doordash: {
    format: 'JSON',
    apiEndpoint: 'https://api.doordash.com/menus',
    contentType: 'application/json',
  },
  ubereats: {
    format: 'XML',
    apiEndpoint: 'https://api.ubereats.com/menus',
    contentType: 'application/xml',
  },
  // Add more providers as needed
};

module.exports = providerConfigs;

================
File: src/translator/translatorService.js
================
const axios = require('axios');

class TranslatorService {
  constructor(providerConfig) {
    this.providerConfig = providerConfig; // Each provider's config defines how to format the data
  }

  // Function to translate menu data
  translateMenu(menuData) {
    if (this.providerConfig.format === 'JSON') {
      return this.translateToJSON(menuData);
    } else if (this.providerConfig.format === 'XML') {
      return this.translateToXML(menuData);
    }
    // Add more formats as needed
  }

  // Example function to translate to JSON format
  translateToJSON(menuData) {
    return {
      menuName: menuData.name,
      items: menuData.menuItems.map(item => ({
        itemName: item.name,
        price: item.basePrice,
        pointsPrice: item.pointsPrice || null, // Handling points if applicable
        modifiers: item.modifiers,
      })),
    };
  }

  // Example function to translate to XML format (stubbed out for now)
  translateToXML(menuData) {
    // Implement XML translation logic here
    return `<Menu><Name>${menuData.name}</Name></Menu>`;
  }

  // Send the translated data to the provider's API
  async sendDataToProvider(translatedData) {
    try {
      const response = await axios.post(this.providerConfig.apiEndpoint, translatedData, {
        headers: {
          'Content-Type': this.providerConfig.contentType,
        },
      });
      return response.data;
    } catch (error) {
      console.error('Error sending data to provider:', error);
      throw error;
    }
  }
}

module.exports = TranslatorService;

================
File: src/types/dto/user.js
================
class CreateUserDto {
  // Add properties as needed
}

class UpdateUserDto {
  // Add properties as needed
}

module.exports = {
  CreateUserDto,
  UpdateUserDto
};

================
File: src/types/enums.js
================
const UserRole = {
  ADMIN: 'ADMIN',
  USER: 'USER',
  // Add other roles as needed
};

module.exports = {
  UserRole
};

================
File: src/utils/cache.js
================
const NodeCache = require 'node-cache';

const cache = new NodeCache({ stdTTL: 600 }); // 10 minutes default TTL

const getOrSetCache = async <T>(
  key,
  cb: () => Promise<T>
) => {
  const value = cache.get<T>(key);
  if (value) {
    return value;
  }

  const result = await cb();
  cache.set(key, result);
  return result;
};

================
File: src/utils/dateUtils.js
================
const moment = require('moment-timezone');

/**
 * Convert date and time based on the location's timezone.
 * @param {Date} date - The date to convert.
 * @param {string} timezone - The location's timezone.
 * @returns {Date} The converted date.
 */
function convertToTimezone(date, timezone) {
  return moment(date).tz(timezone).toDate();
}

/**
 * Calculate the remaining time until a specific date.
 * @param {Date} targetDate - The target date.
 * @returns {string} The formatted remaining time (e.g., '2 hours left').
 */
function getTimeUntil(targetDate) {
  const now = moment();
  const target = moment(targetDate);
  const duration = moment.duration(target.diff(now));

  if (duration.asHours() >= 1) {
    return `${Math.floor(duration.asHours())} hours left`;
  }
  return `${Math.floor(duration.asMinutes())} minutes left`;
}

/**
 * Get the "pretty" time slots in 15-minute intervals.
 * @param {Date} startTime - The starting time.
 * @returns {Array<string>} An array of time slots (e.g., ['1:15 PM', '1:30 PM']).
 */
function getPrettyTimeSlots(startTime) {
  const slots = [];
  const roundedStart = moment(startTime).startOf('minute').add(15 - (startTime.getMinutes() % 15), 'minutes');

  for (let i = 0; i < 24; i++) {
    slots.push(roundedStart.format('h:mm A'));
    roundedStart.add(15, 'minutes');
  }
  return slots;
}

module.exports = {
  convertToTimezone,
  getTimeUntil,
  getPrettyTimeSlots,
};

================
File: src/utils/discountUtils.js
================
const { Discount } = require('../models');

/**
 * Get applicable discounts for an order based on guest and location.
 * @param {Order} order - The order being placed.
 * @param {number} guestId - The ID of the guest placing the order.
 * @returns {Array<Discount>} An array of applicable discounts.
 */
async function getApplicableDiscounts(order, guestId) {
  const discounts = await Discount.findAll({
    where: {
      locationId: order.locationId,
      status: 'active',
    },
  });

  return discounts.filter(discount => discount.isApplicable(order, guestId));
}

/**
 * Apply the best discount to the order.
 * @param {Array<Discount>} discounts - The array of applicable discounts.
 * @param {Order} order - The order to apply the discount to.
 * @returns {Order} The updated order with the best discount applied.
 */
function applyBestDiscount(discounts, order) {
  if (discounts.length === 0) return order;

  const bestDiscount = discounts.reduce((prev, current) => (current.value > prev.value ? current : prev));
  order.discountApplied = bestDiscount.value;
  order.totalAmount -= bestDiscount.value;

  return order.save();
}

module.exports = {
  getApplicableDiscounts,
  applyBestDiscount,
};

================
File: src/utils/emojiUtils.js
================
module.exports.StripEmojis = (str) => {
  if (!str) return str;
  return str.replace(/[\u{1F600}-\u{1F64F}\u{1F300}-\u{1F5FF}\u{1F680}-\u{1F6FF}\u{1F700}-\u{1F77F}\u{1F780}-\u{1F7FF}\u{1F800}-\u{1F8FF}\u{1F900}-\u{1F9FF}\u{1FA00}-\u{1FA6F}\u{1FA70}-\u{1FAFF}]/gu, '');
};

================
File: src/utils/errorHandler.js
================
const { Request, Response, NextFunction } = require('express');
const logger = require('./logger');

class AppError extends Error {
  constructor(message, statusCode) {
    super(message);
    this.statusCode = statusCode;
    this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';
    this.isOperational = true;

    Error.captureStackTrace(this, this.constructor);
  }
}

const errorHandler = (err, req, res, next) => {
  // This function is now handled directly in server.js
  next(err);
};

module.exports = {
  AppError,
  errorHandler
};

================
File: src/utils/errors.js
================
class UnauthorizedError extends Error {
  constructor(message) {
    super(message);
    this.name = 'UnauthorizedError';
    this.statusCode = 401;
  }
}

class NotFoundError extends Error {
  constructor(message) {
    super(message);
    this.name = 'NotFoundError';
  }
}

class ConflictError extends Error {
  constructor(message) {
    super(message);
    this.name = 'ConflictError';
  }
}

module.exports = {
  UnauthorizedError,
  NotFoundError,
  ConflictError
};

================
File: src/utils/exportUtils.js
================
const ExcelJS = require 'exceljs';
const PDFDocument = require 'pdfkit';
const { Readable } = require 'stream';

const exportToExcel = async (data[], sheetName) => {
  const workbook = new ExcelJS.Workbook();
  const worksheet = workbook.addWorksheet(sheetName);

  // Add headers
  const headers = Object.keys(data[0]);
  worksheet.addRow(headers);

  // Add data
  data.forEach(item => {
    worksheet.addRow(Object.values(item));
  });

  return await workbook.xlsx.writeBuffer();
};

const exportToPDF = (data[]) => {
  const doc = new PDFDocument();
  const stream = new Readable();
  stream._read = () => {};

  doc.pipe(stream);

  // Add headers
  const headers = Object.keys(data[0]);
  doc.text(headers.join(', '));

  // Add data
  data.forEach(item => {
    doc.text(Object.values(item).join(', '));
  });

  doc.end();

  return stream;
};

================
File: src/utils/invoiceUtils.js
================
const { Invoice } = require('../models'); // Added import for Invoice model

const calculateAccountBalance = async (houseAccountId) => {
  const invoices = await Invoice.findAll({ where: { houseAccountId } });
  const total = invoices.reduce((sum, invoice) => sum + invoice.amount, 0);
  return total;
};

const generateInvoiceNumber = () => {
  return `INV-${Date.now()}`;
};

module.exports = { calculateAccountBalance, generateInvoiceNumber };

================
File: src/utils/locationUtils.js
================
const axios = require('axios');

/**
 * Get coordinates (latitude and longitude) from an address using a geocoding API.
 * @param {string} address - The address to geocode.
 * @returns {Object} An object containing latitude and longitude.
 */
async function getCoordinatesFromAddress(address) {
  try {
    // Use a geocoding API (e.g., Google Geocoding API, OpenStreetMap, etc.)
    const response = await axios.get(`https://api.opencagedata.com/geocode/v1/json`, {
      params: {
        q: address,
        key: process.env.GEOCODING_API_KEY, // Replace with your geocoding API key
      },
    });

    const { lat, lng } = response.data.results[0].geometry;
    return { latitude: lat, longitude: lng };
  } catch (error) {
    console.error('Error fetching coordinates:', error);
    throw new Error('Unable to fetch coordinates for the provided address.');
  }
}

module.exports = { getCoordinatesFromAddress };

================
File: src/utils/logger.js
================
const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' })
  ]
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple()
  }));
}

module.exports = logger;

================
File: src/utils/loyaltyUtils.js
================
const { LoyaltyReward, Guest, Order, Wallet } = require('../models');
const moment = require('moment-timezone');

function calculateLoyaltyTier(guest) {
  const totalSpend = guest.totalSpend;
  if (totalSpend >= 1000) return 'Platinum';
  if (totalSpend >= 500) return 'Gold';
  return 'Silver';
}

async function applyLoyaltyReward(order, guestId) {
  const wallet = await Wallet.findOne({ where: { guestId }, include: [LoyaltyReward] });
  if (!wallet) throw new Error('Wallet not found');

  const applicableRewards = wallet.LoyaltyRewards.filter(reward => {
    return (
      reward.status === 'active' &&
      reward.pointsRequired <= wallet.loyaltyPoints
    );
  });

  if (!applicableRewards.length) {
    return order; // No reward applicable
  }

  const rewardToApply = applicableRewards[0];
  wallet.loyaltyPoints -= rewardToApply.pointsRequired;

  const expirationDate = moment().add(30, 'days');

  await wallet.save();

  order.loyaltyPointsUsed = rewardToApply.pointsRequired;
  order.rewardExpirationDate = expirationDate;
  return order;
}

async function updateLoyaltyProgress(order, guestId) {
  const guest = await Guest.findByPk(guestId);
  const pointsEarned = Math.floor(order.subtotal);

  guest.loyaltyPoints += pointsEarned;
  guest.totalSpend += order.subtotal;

  if (guest.loyaltyTier === 'Silver') {
    guest.loyaltyPoints = applyRollingExpiration(guest.loyaltyPoints, 30);
  } else if (guest.loyaltyTier === 'Platinum') {
    guest.loyaltyPoints = applyRollingExpiration(guest.loyaltyPoints, 90);
  }

  await guest.save();
}

function applyRollingExpiration(points, days) {
  const expirationDate = moment().subtract(days, 'days');
  const currentDate = moment();
  
  // Calculate the fraction of a year that has passed since the expiration date
  const yearFraction = currentDate.diff(expirationDate, 'days') / 365;
  
  // Expire points proportional to the time passed, with a maximum of the input points
  const expiredPoints = Math.min(points, Math.floor(points * yearFraction));
  
  return Math.max(points - expiredPoints, 0);
}

async function getOrderHistory(guestId) {
  return await Order.findAll({ where: { guestId } });
}

module.exports = {
  calculateLoyaltyTier,
  applyLoyaltyReward,
  updateLoyaltyProgress,
  getOrderHistory,
};

================
File: src/utils/menuSyncScheduler.js
================
const cron = require 'node-cron';
const { syncMenuForProvider } = require '../services/orderProviderService';

const schedules: { [key].ScheduledTask } = {};

const scheduleMenuSync = (provider) => {
  if (schedules[provider.id]) {
    schedules[provider.id].stop();
  }

  let cronExpression;
  switch (provider.menuSyncFrequency) {
    case 'hourly':
      cronExpression = '0 * * * *';
      break;
    case 'daily':
      cronExpression = '0 0 * * *';
      break;
    case 'weekly':
      cronExpression = '0 0 * * 0';
      break;
    default:
      cronExpression = '0 0 * * *'; // Default to daily
  }

  schedules[provider.id] = cron.schedule(cronExpression, () => {
    syncMenuForProvider(provider.id);
  });
};

const stopMenuSync = (providerId) => {
  if (schedules[providerId]) {
    schedules[providerId].stop();
    delete schedules[providerId];
  }
};

================
File: src/utils/notificationService.js
================
const admin = require('firebase-admin');
const { User } = require('../models');

const sendNotification = async (userId, message) => {
  try {
    const user = await User.findByPk(userId);
    if (user && user.fcmToken) {
      await admin.messaging().send({
        token: user.fcmToken,
        notification: {
          title: 'Order Update',
          body: message,
        },
      });
    }
  } catch (error) {
    console.error('Error sending notification:', error);
  }
};

module.exports = {
  sendNotification
};

================
File: src/utils/orderProviderIntegration.js
================
const axios = require 'axios';
const { Order } = require '../models/Order';
const { Location } = require '../models/Location';

const sendMenuToProvider = async (provider, menuItems[]) => {
  const location = await Location.findByPk(provider.locationId);
  if (!location) {
    throw new Error('Location not found');
  }

  const upliftedMenuItems = menuItems.map((item) => ({
    ...item,
    price.price * (1 + provider.upliftPercentage / 100),
  }));

  try {
    await axios.post(`${provider.apiUrl}/menu`, {
      apiKey.apiKey,
      menu,
    });
  } catch (error) {
    console.error(`Failed to send menu to ${provider.name}:`, error);
    throw error;
  }
};

const handleIncomingOrder = async (provider, orderData) => {
  // Validate the incoming order data
  // Transform the order data to match your internal order structure
  const transformedOrder = transformOrderData(orderData);

  // Apply any necessary business logic (e.g., inventory checks)

  // Create the order in your system
  const order = await Order.create(transformedOrder);

  // Send the order to the POS system
  await sendOrderToPOS(order);

  return order;
};

const transformOrderData = (orderData) => {
  // Implement the logic to transform the order data from the provider's format to your internal format
  // This will depend on the specific structure of the incoming order data and your internal order model
  return {
    // Map the fields accordingly
  };
};

const sendOrderToPOS = async (order) => {
  // Implement the logic to send the order to the POS system
  // This will depend on your POS integration
};

const sendDoordashSSIOUpdate = async (provider, menuItems?[]) => {
  const location = await Location.findByPk(provider.locationId);
  if (!location) {
    throw new Error('Location not found');
  }

  const ssioPayload = {
    external_reference_id.doordashExternalReferenceId,
    store_id.doordashStoreId,
    menu_id.doordashMenuId,
    // Add other required SSIO fields here
  };

  if (menuItems) {
    ssioPayload.items = menuItems.map((item) => ({
      external_id.id,
      name.name,
      description.description,
      price.price * (1 + provider.upliftPercentage / 100),
      // Add other required item fields here
    }));
  }

  try {
    await axios.post('https://api.doordash.com/drive/v2/ssio/update', ssioPayload, {
      headers: {
        'Authorization': `Bearer ${provider.apiKey}`,
        'Content-Type': 'application/json',
      },
    });
  } catch (error) {
    console.error(`Failed to send SSIO update to Doordash:`, error);
    throw error;
  }
};

================
File: src/utils/orderScheduler.js
================
const cron = require('node-cron');
const { Order, Op } = require('../models'); // Added Op import

// Schedule job to process scheduled orders every minute
cron.schedule('* * * * *', async () => {
  console.log('Processing scheduled orders...');
  try {
    const now = new Date();
    const scheduledOrders = await Order.findAll({
      where: {
        status: 'scheduled',
        scheduledFor: { [Op.lte]: now }, // Process orders scheduled for now or earlier
      }
    });

    for (const order of scheduledOrders) {
      order.status = 'processing';
      await order.save();

      // Implement logic to send order to the kitchen or process as needed
      console.log(`Order ${order.id} is now processing.`);
    }
  } catch (error) {
    console.error('Error processing scheduled orders:', error);
  }
});

================
File: src/utils/pricingUtils.js
================
function roundToNext99(price) {
  if (typeof price !== 'number') {
    throw new Error('Price must be a number');
  }
  const roundedPrice = Math.ceil(price) - 0.01;
  return parseFloat(roundedPrice.toFixed(2));
}

// Function to calculate the uplifted price based on the percentage
function calculateUplift(price, upliftPercentage) {
  if (typeof price !== 'number' || typeof upliftPercentage !== 'number') {
    throw new Error('Price and uplift percentage must be numbers');
  }
  const upliftedPrice = price * (1 + upliftPercentage / 100);
  return parseFloat(upliftedPrice.toFixed(2));
}

// Function to apply rounding based on provider settings
function applyRoundingIfNeeded(price, roundingOption) {
  switch (roundingOption) {
    case '.99':
      return roundToNext99(price);
    case 'nearest':
      return Math.round(price * 100) / 100;
    default:
      return price;
  }
}

// Function to calculate provider-specific pricing uplifts with rounding options
function calculateProviderPricing(price, upliftPercentage, roundingOption) {
  let upliftedPrice = calculateUplift(price, upliftPercentage);
  return applyRoundingIfNeeded(upliftedPrice, roundingOption);
}

module.exports = {
  roundToNext99,
  calculateUplift,
  applyRoundingIfNeeded,
  calculateProviderPricing,
};

================
File: src/utils/readyTimeUtils.js
================
const { Location } = require('../models'); // Added import for Location model

const updateReadyTime = async (locationId, orderData) => { // Added async keyword
  const { totalItems, totalAmount, totalOrders } = orderData;

  // Fetch location-specific throttle settings
  const location = await Location.findByPk(locationId);
  const throttleSettings = location.throttleSettings;

  // Apply the scaling logic based on the throttle settings
  let readyTimeIncrement = 0;

  if (totalItems >= throttleSettings.itemThreshold) {
    readyTimeIncrement += throttleSettings.itemIncrement; // e.g., 5 minutes
  }

  if (totalAmount >= throttleSettings.amountThreshold) {
    readyTimeIncrement += throttleSettings.amountIncrement; // e.g., 10 minutes
  }

  if (totalOrders >= throttleSettings.orderThreshold) {
    readyTimeIncrement += throttleSettings.orderIncrement; // e.g., 15 minutes
  }

  // Update the ready time for future orders at this location
  location.currentReadyTime += readyTimeIncrement;
  await location.save();

  return location.currentReadyTime;
};

module.exports = { updateReadyTime };

================
File: src/utils/scheduledOrderCron.js
================
const cron = require 'node-cron';
const { processScheduledOrders } = require '../services/scheduledOrderService';

const startScheduledOrderCron = () => {
  cron.schedule('* * * * *', async () => {
    await processScheduledOrders();
  });
};

================
File: src/utils/timezoneUtils.js
================
const moment = require('moment-timezone');

/**
 * Automatically determine the timezone based on a location's address.
 * @param {string} address - The address of the location.
 * @returns {string} The determined timezone (e.g., 'America/New_York').
 */
function getTimezoneFromAddress(address) {
  // Mocked function to determine timezone based on location address
  if (address.includes('New York')) {
    return 'America/New_York';
  }
  return 'America/Los_Angeles';
}

/**
 * Convert a date to a location's timezone.
 * @param {Date} date - The date to convert.
 * @param {string} timezone - The timezone to convert to.
 * @returns {Date} The converted date.
 */
function convertToLocationTimezone(date, timezone) {
  return moment(date).tz(timezone).toDate();
}

module.exports = {
  getTimezoneFromAddress,
  convertToLocationTimezone,
};

================
File: src/utils/translationEngine.js
================
class TranslationEngine {
  constructor(mapping) {
    this.mapping = mapping;
  }

  translate(internalData) {
    const translatedData = {};

    for (const [internalKey, posKey] of Object.entries(this.mapping)) {
      translatedData[posKey] = internalData[internalKey];
    }

    return translatedData;
  }

  // Add methods to support complex translation scenarios (e.g., nested objects, array mappings)
  translateNestedData(internalData, nestedMappings) {
    const translatedData = {};

    for (const [internalKey, posKey] of Object.entries(nestedMappings)) {
      if (internalData[internalKey] && typeof internalData[internalKey] === 'object') {
        translatedData[posKey] = this.translate(internalData[internalKey]);
      } else {
        translatedData[posKey] = internalData[internalKey];
      }
    }

    return translatedData;
  }
}

module.exports = TranslationEngine;

================
File: src/validators/clientValidator.js
================
const Joi = require 'joi';

const clientSchema = Joi.object({
  name.string().required(),
  domain.string().required(),
  primaryColor.string().required(),
  secondaryColor.string().required(),
  logo.string().uri().required(),
  features.object({
    loyalty.boolean().required(),
    onlineOrdering.boolean().required(),
    tableReservations.boolean().required(),
  }).required(),
});

const validateClientData = (data) => {
  const { error } = clientSchema.validate(data, { abortEarly });
  if (error) {
    return error.details.map((err) => err.message);
  }
  return [];
};

================
File: src/.env
================
DB_NAME=pos
DB_USER=bryce
DB_PASSWORD=1234
DB_HOST=localhost
JWT_SECRET=Lma1i18om2ghPiqGuuNFgI80GCYbyfFJuYoN0p+mIfU=

================
File: src/app.js
================
const express = require 'express';
const { apiLimiter } = require './middleware/rateLimiter';
const { cacheMiddleware } = require './middleware/cache';
const authRoutes = require './routes/authRoutes';
const orderRoutes = require './routes/orderRoutes';
// const subscriptionRoutes = require './routes/subscriptionRoutes';
const paymentRoutes = require './routes/paymentRoutes';
const twoFactorRoutes = require './routes/twoFactorRoutes';
const clientSettingsRoutes = require './routes/clientSettingsRoutes';
const providerRoutes = require './routes/providerRoutes';

const app = express();

if (typeof app.use === 'function') {
  app.use(express.json());
  app.use(apiLimiter);

  app.use('/api/auth', authRoutes);
  app.use('/api/orders', cacheMiddleware(300), orderRoutes); // Cache for 5 minutes
  // app.use('/api/subscriptions', subscriptionRoutes);
} else {
  console.error('app.use is not a function. Make sure express is properly initialized.');
}
app.use('/api/payments', paymentRoutes);
app.use('/api/2fa', twoFactorRoutes);
app.use('/api/client-settings', clientSettingsRoutes);
app.use('/api', providerRoutes);

// Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).send('Something broke!');
});

module.exports = app;

================
File: src/cronJobs.js
================
const cron = require('node-cron');
const CateringService = require('./services/cateringService');
const logger = require('./utils/logger');

// Schedule guest orders based on their scheduled time
cron.schedule('* * * * *', async () => {
  try {
    logger.info('Running scheduled task for guest orders...');
    await CateringService.handleScheduledOrders();
  } catch (error) {
    logger.error('Error handling scheduled guest orders:', error);
  }
});

// Schedule catering orders based on their scheduled time
cron.schedule('* * * * *', async () => {
  try {
    logger.info('Running scheduled task for catering orders...');
    await CateringService.handleScheduledOrders();
  } catch (error) {
    logger.error('Error handling scheduled catering orders:', error);
  }
});

================
File: src/HouseAccountUser.js
================
module.exports = (sequelize, DataTypes) => {
  const HouseAccount = sequelize.define('HouseAccount', {
    accountName: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    billingType: {
      type: DataTypes.ENUM('invoice', 'purchase_order'),
      allowNull: false,
    },
    isActive: {
      type: DataTypes.BOOLEAN,
      defaultValue: true,
    },
  });

  HouseAccount.associate = (models) => {
    HouseAccount.belongsTo(models.Client, { foreignKey: 'clientId' });
    HouseAccount.hasMany(models.HouseAccountUser, { foreignKey: 'houseAccountId' });
  };

  return HouseAccount;
};

================
File: src/logger.js
================
const winston = require('winston');
const { createLogger, format, transports } = winston;

// Define custom format for logs
const customFormat = format.combine(
  format.timestamp(),
  format.printf(({ timestamp, level, message }) => {
    return `${timestamp} [${level}]: ${message}`;
  })
);

// Create a logger instance
const logger = createLogger({
  level: 'info',
  format: customFormat,
  transports: [
    new transports.Console(),
    new transports.File({ filename: 'logs/application.log' }), // Ensure correct log file path
  ],
});

module.exports = logger;

================
File: src/OrderThrottleService.js
================
const Location = require('../models/Location');

class OrderThrottleService {
  static async adjustReadyTime(locationId) {
    const location = await Location.findByPk(locationId);
    const { throttleSettings } = location;

    // Logic to determine the new ready time based on sales volume, item count, etc.
    if (location.salesVolume > throttleSettings.volumeThreshold) {
      location.readyTime += throttleSettings.increment; // Example adjustment
    }

    await location.save();
    return location.readyTime;
  }
}

module.exports = OrderThrottleService;

================
File: src/seedDatabase.js
================
const { createConnection } = require 'typeorm';
const { seedEnterpriseClient } = require './seeders/enterpriseClientSeeder';

async function runSeed() {
  const connection = await createConnection();
  try {
    await seedEnterpriseClient(connection);
    console.log('Seeding completed successfully');
  } catch (error) {
    console.error('Error seeding data:', error);
  } finally {
    await connection.close();
  }
}

runSeed();

================
File: src/seedGuests.js
================
const { Guest } = require('./models');

async function seedGuests() {
  await Guest.bulkCreate([
    {
      firstName: 'John',
      lastName: 'Doe',
      email: 'john.doe@example.com',
      numberOfOrders: 5,
      averageOrderSize: 24.99,
      favoriteMenuItem: 'Burger',
    },
    {
      firstName: 'Jane',
      lastName: 'Smith',
      email: 'jane.smith@example.com',
      numberOfOrders: 10,
      averageOrderSize: 15.45,
      favoriteMenuItem: 'Pizza',
    },
  ]);
  console.log('Guests seeded successfully');
}

seedGuests();

================
File: src/seedRoles.js
================
const { Role } = require('./models');

async function seedRoles() {
  try {
    await Role.bulkCreate([
      { name: 'Super Admin' },
      { name: 'Admin' },
      { name: 'Manager' },
    ]);

    console.log('Roles seeded successfully!');
    process.exit(0); // Exit the script
  } catch (error) {
    console.error('Error seeding roles:', error);
    process.exit(1); // Exit with error
  }
}

seedRoles();

================
File: src/server.js
================
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const { clientRoutes } = require('./routes/clientRoutes');
const { authRoutes } = require('./routes/authRoutes');
const { errorHandler } = require('./middleware/errorHandler');
const { authMiddleware } = require('./middleware/authMiddleware');
const session = require('express-session');
const RedisStore = require('connect-redis')(session);
const redisClient = require('./services/redisService').redis;

const app = express();

// Middleware
app.use(cors());
app.use(helmet());
app.use(express.json());

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // limit each IP to 100 requests per windowMs
});
app.use(limiter);

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/clients', authMiddleware, clientRoutes);

// Error handling
app.use(errorHandler);

// Session management
app.use(
  session({
    store: new RedisStore({ client: redisClient }),
    secret: process.env.SESSION_SECRET,
    resave: false,
    saveUninitialized: false,
    cookie: {
      secure: process.env.NODE_ENV === 'production',
      httpOnly: true,
      maxAge: 1000 * 60 * 60 * 24, // 1 day
    },
  })
);

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`Server running on port ${PORT}`));

module.exports = app;

================
File: src/socket.js
================
const { Server } = require('socket.io');

let io;

const initializeSocket = (server) => {
  io = new Server(server, {
    cors: {
      origin: process.env.FRONTEND_URL || "http://localhost:3000",
      methods: ["GET", "POST"]
    }
  });

  io.on('connection', (socket) => {
    console.log('A user connected');

    socket.on('disconnect', () => {
      console.log('User disconnected');
    });
  });

  return io;
};

module.exports = {
  initializeSocket,
  getIO: () => {
    if (!io) {
      throw new Error('Socket.io not initialized!');
    }
    return io;
  }
};

================
File: src/websocket.js
================
const WebSocket = require('ws');

const setupWebSocket = (server) => {
  const wss = new WebSocket.Server({ server });

  wss.on('connection', (ws) => {
    console.log('New WebSocket connection');

    ws.on('message', (message) => {
      console.log('Received:', message);
    });

    ws.send('Welcome to the WebSocket server!');
  });

  return wss;
};

module.exports = setupWebSocket;

// Use in app.js
const http = require('http');
const setupWebSocket = require('./websocket');

const server = http.createServer(app);
const wss = setupWebSocket(server);

// frontend/src/services/websocket.ts
export class WebSocketService {
  private socket: WebSocket;

  constructor(url: string) {
    this.socket = new WebSocket(url);

    this.socket.onopen = () => {
      console.log('WebSocket connection established');
    };

    this.socket.onmessage = (event) => {
      console.log('Received message:', event.data);
      // Handle incoming messages
    };

    this.socket.onerror = (error) => {
      console.error('WebSocket error:', error);
    };

    this.socket.onclose = () => {
      console.log('WebSocket connection closed');
    };
  }

  sendMessage(message: string) {
    this.socket.send(message);
  }
}

// Use in ExecutiveDashboard.tsx
const websocket = new WebSocketService('ws://localhost:3000');

================
File: ssl/server.cert
================
-----BEGIN CERTIFICATE-----
MIIDmzCCAoOgAwIBAgIUHYtGI00KMYIzKZsM/1/e1QOnJWEwDQYJKoZIhvcNAQEL
BQAwXTELMAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUxITAfBgNVBAoM
GEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDEWMBQGA1UEAwwNNjQuMjMuMTc4LjE5
ODAeFw0yNDA4MjcxNjIyMDNaFw0yNDA5MjYxNjIyMDNaMF0xCzAJBgNVBAYTAkFV
MRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRz
IFB0eSBMdGQxFjAUBgNVBAMMDTY0LjIzLjE3OC4xOTgwggEiMA0GCSqGSIb3DQEB
AQUAA4IBDwAwggEKAoIBAQCdmZ9Dyv9rWgW+ot6B+05u8tlDEyvhoW1l8TTFSzHK
eEOq653WV5yFTgxLPcEhD2alMJwfqUkAoDYR8Rcelp7VI7gXiePwKPvZS8ijhsbZ
enEdBCM4almMCwhY+r7QAfz87uzXoXEOSu7yTcOEEY4WsojpMyyEd5Rw3u6v/fKO
o7jC+lxJEFfhOcbrg8ltrz/iVz4TPap+Qzc/0iNct5Se12+zjU9AmmjBu7fwbWZB
Nmzvt/XG4wxrIcQVKXo5v3Jg2SsyWunYOXH7WxrI6sYLy87/qUVedIILAcgPvf62
DTkGdv4dqFGztn7GmTUn0BdbfMVIYeMxN1xBPlU+pUNnAgMBAAGjUzBRMB0GA1Ud
DgQWBBQucnL9vh5mqQEOGzc6tUuhLfN52DAfBgNVHSMEGDAWgBQucnL9vh5mqQEO
Gzc6tUuhLfN52DAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3DQEBCwUAA4IBAQAF
sdRBi40zp05PhsfgltBaF88/khkls7t4T+mAzgysobEL4Miz34kVALYfSWlJhtZy
OLOEYUJqbU8ZqNCEj2awSi42ES01F8BfspX19g0fYwh5W7HvoVwv204HxqQ5xR16
GNJJ1Fwjz57OE1M4lMAZjWenw1x/OdXHGqgNeSSPggVJLEtikaiR86de4wCzb/J8
kmRZlrL16EG4ZJfCdURA8o/zzoFEQ2tCE4G8amY6qzHSvcebwZRe86gi3MOT1s6E
IYbb4+qHyMiuL8hMyy8e485mgIM5YKtXT9VqAhPZFGIRCaxtDSynRz3DVZKK9oQL
6Qe5qJuXoJ5iQ1xpOYI+
-----END CERTIFICATE-----

================
File: .babelrc
================
{
  "presets": ["@babel/preset-env"]
}

================
File: .dockerignore
================
node_modules
logs
.git
*.log

================
File: .eslintrc.js
================
module.exports = {
  root: true,
  env: {
    node: true,
    es2022: true,
  },
  extends: [
    'eslint:recommended',
  ],
  parserOptions: {
    ecmaVersion: 2022,
    sourceType: 'module',
  },
  rules: {
    'no-unused-vars': ['error', { 
      argsIgnorePattern: '^_',
      varsIgnorePattern: '^(Sequelize|queryInterface)$'
    }],
  },
  overrides: [
    {
      files: ['**/*.js'],
      parserOptions: {
        sourceType: 'commonjs',
      },
    },
  ],
};

================
File: .sequelizerc
================
const path = require('path');

module.exports = {
  'config': path.resolve('src/config', 'database.js'),
  'models-path': path.resolve('src', 'models'),
  'seeders-path': path.resolve('src', 'seeders'),
  'migrations-path': path.resolve('src', 'migrations')
};

================
File: checkMigrations.js
================
const { Sequelize } = require('sequelize');
const { Umzug, SequelizeStorage } = require('umzug');

// Log the database connection setup
console.log('Setting up database connection...');

const sequelize = new Sequelize({
  dialect: 'postgres',
  host: 'localhost', // Assuming your DB is hosted locally
  username: 'bryce',
  password: '1234',
  database: 'pos',
  logging: console.log, // Enable Sequelize logging to see SQL queries
});

console.log('Database connection setup completed.');

// Log the Umzug setup
console.log('Setting up Umzug for migrations...');

const umzug = new Umzug({
  migrations: {
    glob: './migrations/*.js', // Path to your migration files
  },
  context: sequelize.getQueryInterface(),
  storage: new SequelizeStorage({ sequelize }),
  logger: console,
});

console.log('Umzug setup completed.');

// Function to validate migrations
async function checkMigrations() {
  try {
    console.log('Checking migrations...');

    const migrations = await umzug.pending(); // Get all pending migrations
    if (migrations.length === 0) {
      console.log('All migrations have already been executed.');
    } else {
      console.log(`Found ${migrations.length} pending migrations.`);

      for (const migration of migrations) {
        console.log(`Testing migration: ${migration.name}`);
        try {
          await umzug.up({ migrations: [migration.name] }); // Run the migration
          console.log(`Migration ${migration.name} executed successfully.`);
          
          // Rollback immediately to keep the database clean
          await umzug.down({ migrations: [migration.name] });
          console.log(`Migration ${migration.name} rolled back successfully.`);
        } catch (error) {
          console.error(`Error executing migration ${migration.name}:`, error);
          return; // Stop further checks if any migration fails
        }
      }

      console.log('All migrations tested successfully.');
    }
  } catch (error) {
    console.error('Error while checking migrations:', error);
  } finally {
    await sequelize.close(); // Close the database connection
  }
}

// Run the migration check
checkMigrations();

================
File: collect-seed-errors.js
================
const { Sequelize } = require('sequelize');
const { exec } = require('child_process');
const fs = require('fs').promises;

const config = require('./config/config.json').development;

const sequelize = new Sequelize(config.database, config.username, config.password, {
  host: config.host,
  dialect: config.dialect
});

async function runSeeders() {
  const seeders = await fs.readdir('./seeders');
  const errors = [];

  for (const seeder of seeders) {
    if (seeder.endsWith('.js')) {
      try {
        console.log(`Running seeder: ${seeder}`);
        await new Promise((resolve) => {
          exec(`npx sequelize-cli db:seed --seed ${seeder}`, (error, stdout) => {
            if (error) {
              console.error(`Error in seeder ${seeder}:`, error.message);
              errors.push({ seeder, error: error.message });
            } else {
              console.log(stdout);
            }
            resolve(); // Continue to next seeder even if there's an error
          });
        });
      } catch (error) {
        console.error(`Error running seeder ${seeder}:`, error);
        errors.push({ seeder, error: error.message });
      }
    }
  }

  return errors;
}

async function main() {
  try {
    await sequelize.authenticate();
    console.log('Connection to the database has been established successfully.');

    const errors = await runSeeders();

    if (errors.length > 0) {
      console.log('Errors encountered during seeding:');
      console.log(JSON.stringify(errors, null, 2));
      await fs.writeFile('seed-errors.json', JSON.stringify(errors, null, 2));
      console.log('Errors have been written to seed-errors.json');
    } else {
      console.log('All seeders completed successfully.');
    }
  } catch (error) {
    console.error('Unable to connect to the database:', error);
  } finally {
    await sequelize.close();
  }
}

main();

================
File: config.json
================
{
  "development": {
    "username": "bryce",
    "password": "1234",
    "database": "pos",
    "host": "db",
    "dialect": "postgres"
  },
  "test": {
    "username": "bryce",
    "password": "1234",
    "database": "pos_test",
    "host": "db",
    "dialect": "postgres"
  },
  "production": {
    "use_env_variable": "DATABASE_URL",
    "dialect": "postgres",
    "dialectOptions": {
      "ssl": {
        "require": true,
        "rejectUnauthorized": false
      }
    }
  }
}

================
File: convert_to_js.sh
================
convert_file() {
    file="$1"
    js_file="${file%.ts}.js"
    
    # Remove type annotations
    sed 's/: [A-Za-z<>|&]\+//g' "$file" > "$js_file"
    
    # Replace import statements
    sed -i 's/import \(.*\) from/const \1 = require/g' "$js_file"
    
    # Replace export statements
    sed -i 's/export const/const/g' "$js_file"
    sed -i 's/export default/module.exports =/g' "$js_file"
    sed -i 's/export {/module.exports = {/g' "$js_file"
    
    # Remove interface and type declarations
    sed -i '/^interface /d' "$js_file"
    sed -i '/^type /d' "$js_file"
    
    # Remove other TypeScript-specific syntax
    sed -i 's/as [A-Za-z]\+//g' "$js_file"
    
    echo "Converted $file to $js_file"
}

# Find and convert all TypeScript files
find src -name "*.ts" | while read file; do
    convert_file "$file"
    # Remove the original .ts file
    rm "$file"
    echo "Deleted original TypeScript file: $file"
done

echo "Conversion complete. All .ts files have been converted to .js and original .ts files have been deleted."

================
File: correctmodel1.js
================
const fs = require('fs');
const path = require('path');

const modelsDir = path.join(__dirname, 'src', 'models');

const updateModelFile = (filePath) => {
  const content = fs.readFileSync(filePath, 'utf8');
  
  // Check if the file already has the new structure
  if (content.includes('static attributes =')) {
    console.log(`Skipping ${filePath} as it already has the new structure.`);
    return;
  }

  const updatedContent = content
    .replace(/const { Model, DataTypes } = require\('sequelize'\);/, "const { DataTypes } = require('sequelize');")
    .replace(/class \w+ extends Model/, "class $& extends BaseModel")
    .replace(/(\w+)\.init\(([\s\S]*?)\);/, (match, className, attributes) => {
      return `${className}.attributes = ${attributes.trim()};`;
    })
    .replace(/sequelize,\s*modelName:[^}]+},?/, '')
    .replace(/(\w+)\.name = ['"](\w+)['"];/, '');

  const baseModelImport = "const BaseModel = require('./BaseModel');\n\n";
  const updatedContentWithImport = baseModelImport + updatedContent;

  fs.writeFileSync(filePath, updatedContentWithImport);
  console.log(`Updated ${filePath}`);
};

fs.readdirSync(modelsDir).forEach(file => {
  if (file.endsWith('.js') && file !== 'index.js' && file !== 'BaseModel.js') {
    const filePath = path.join(modelsDir, file);
    updateModelFile(filePath);
  }
});

console.log('All model files have been updated.');

================
File: correctmodelname.js
================
const fs = require('fs');
const path = require('path');

const modelsDir = path.join(__dirname, 'src', 'models');

fs.readdir(modelsDir, (err, files) => {
  if (err) {
    console.error("Could not list the directory.", err);
    process.exit(1);
  }

  files.forEach((file, index) => {
    if (file.endsWith('.js') && file !== 'index.js' && file !== 'BaseModel.js') {
      const filePath = path.join(modelsDir, file);
      
      fs.readFile(filePath, 'utf8', (err, content) => {
        if (err) {
          console.error(`Error reading file ${file}:`, err);
          return;
        }

        // Remove the line that sets the name property
        const updatedContent = content.replace(/^.*\.name = '.*';$/m, '');

        fs.writeFile(filePath, updatedContent, 'utf8', (err) => {
          if (err) {
            console.error(`Error writing file ${file}:`, err);
          } else {
            console.log(`Successfully updated ${file}`);
          }
        });
      });
    }
  });
});

================
File: docker-compose.yml
================
version: '3.8'

services:
  backend:
    build: 
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "5000:5000"
    environment:
      - NODE_ENV=${NODE_ENV}
    env_file:
      - .env
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    volumes:
      - ./backend:/app
      - /app/node_modules
      - ./backend/ssl:/app/ssl:ro
    restart: unless-stopped

  frontend:
    build: 
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "443:443"
    environment:
      - REACT_APP_API_URL=https://backend:5000/api
    depends_on:
      - backend
    volumes:
      - ./frontend/ssl:/etc/nginx/ssl:ro
    restart: unless-stopped

  db:
    image: postgres:14-alpine
    environment:
      - POSTGRES_DB=${DB_NAME}
      - POSTGRES_USER=${DB_USER}
      - POSTGRES_PASSWORD=${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER} -d ${DB_NAME}"]
      interval: 10s
      retries: 5
      start_period: 30s
      timeout: 5s
    restart: unless-stopped

  redis:
    image: redis:6-alpine
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      retries: 5
      start_period: 30s
      timeout: 5s
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:

================
File: docker-entrypoint.sh
================
#!/bin/sh

# Run any pre-start commands you need here, e.g., migrations or seeds
echo "Starting backend service..."

# Start the Node.js server
exec "$@"

================
File: Dockerfile
================
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./

RUN npm install

COPY . .

EXPOSE 5000

CMD ["npm", "run", "dev"]

================
File: Dockerfile.migrate
================
FROM node:14

WORKDIR /app

COPY package*.json ./

RUN npm install

COPY . .

CMD ["sh", "-c", "npm run migrate && npm run seed"]

================
File: drop_all_tables.sql
================
DO $$ DECLARE
    r RECORD;
BEGIN
    FOR r IN (SELECT tablename FROM pg_tables WHERE schemaname = current_schema()) LOOP
        EXECUTE 'DROP TABLE IF EXISTS ' || quote_ident(r.tablename) || ' CASCADE';
    END LOOP;
END $$;

================
File: eslint.config.mjs
================
import globals from "globals";
import pluginJs from "@eslint/js";


export default [
  {languageOptions: { globals: globals.node }},
  pluginJs.configs.recommended,
];

================
File: jsconfig.json
================
{
  "compilerOptions": {
    "module": "CommonJS",
    "target": "ES2021",
    "allowSyntheticDefaultImports": true,
    "forceConsistentCasingInFileNames": true,
    "baseUrl": ".",
    "paths": {
      "*": ["src/*"]
    }
  },
  "exclude": ["node_modules", "dist"]
}

================
File: package.json
================
{
  "name": "backend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "start": "node src/server.js",
    "test": "jest",
    "migrate": "sequelize-cli db:migrate",
    "seed": "sequelize-cli db:seed:all",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@faker-js/faker": "^8.4.1",
    "@googlemaps/google-maps-services-js": "^3.4.0",
    "aws-sdk": "^2.1687.0",
    "axios": "^1.7.4",
    "bcrypt": "^5.1.1",
    "bcryptjs": "^2.4.3",
    "connect-redis": "^7.1.1",
    "cors": "^2.8.5",
    "crypto": "^1.0.1",
    "dotenv": "^16.4.5",
    "exceljs": "^4.4.0",
    "express": "^4.19.2",
    "express-rate-limit": "^7.4.0",
    "express-session": "^1.18.0",
    "express-validator": "^7.2.0",
    "firebase-admin": "^12.4.0",
    "geo-tz": "^8.0.2",
    "helmet": "^7.1.0",
    "http-proxy-middleware": "^3.0.0",
    "ioredis": "^5.4.1",
    "joi": "^17.13.3",
    "jsonwebtoken": "^9.0.2",
    "moment-timezone": "^0.5.45",
    "mongoose": "^8.5.3",
    "multer": "^1.4.5-lts.1",
    "node-cache": "^5.1.2",
    "node-cron": "^3.0.3",
    "node-schedule": "^2.1.1",
    "pdfkit": "^0.15.0",
    "pg": "^8.12.0",
    "pg-hstore": "^2.3.4",
    "prom-client": "^15.1.3",
    "qrcode": "^1.5.4",
    "sequelize": "^6.37.3",
    "sharp": "^0.33.5",
    "socket.io": "^4.7.5",
    "speakeasy": "^2.0.0",
    "stripe": "^16.8.0",
    "swagger-jsdoc": "^6.2.8",
    "swagger-ui-express": "^5.0.1",
    "twilio": "^5.2.2",
    "umzug": "^3.8.1",
    "uuid": "^10.0.0",
    "winston": "^3.14.2",
    "worldpay": "^0.0.4"
  },
  "description": "",
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@babel/eslint-parser": "^7.25.1",
    "@babel/preset-env": "^7.25.4",
    "@eslint/js": "^9.9.1",
    "@typescript-eslint/eslint-plugin": "^8.3.0",
    "@typescript-eslint/parser": "^8.3.0",
    "eslint": "^8.57.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-config-recommended": "^4.1.0",
    "eslint-plugin-import": "^2.29.1",
    "eslint-plugin-node": "^11.1.0",
    "eslint-plugin-prettier": "^5.2.1",
    "eslint-plugin-security": "^3.0.1",
    "globals": "^15.9.0",
    "jest": "^29.7.0",
    "prettier": "^3.3.3",
    "sequelize-cli": "^6.6.2",
    "supertest": "^7.0.0"
  }
}

================
File: removeExtraBaseModels.js
================
const fs = require('fs');
const path = require('path');

const modelsDir = path.join(__dirname, 'src', 'models');

const updateModelFile = (filePath) => {
  let content = fs.readFileSync(filePath, 'utf8');
  
  // Remove duplicate BaseModel imports
  content = content.replace(/const BaseModel = require\(['"]\.\/BaseModel['"]\);?\n/g, '');
  
  // Add BaseModel import if it doesn't exist
  if (!content.includes("const BaseModel = require('./BaseModel');")) {
    content = "const BaseModel = require('./BaseModel');\n\n" + content;
  }

  // Update the class declaration
  content = content.replace(/class (\w+) extends (Model|BaseModel)/, 'class $1 extends BaseModel');

  // Remove ModelName.init call
  content = content.replace(/\w+\.init\([^)]+\);?\n/, '');

  // Update attributes definition
  content = content.replace(/(\w+)\.attributes = ({[\s\S]+?});/, (match, className, attributes) => {
    return `${className}.attributes = ${attributes};`;
  });

  // Update module exports
  content = content.replace(/module\.exports = \w+;/, (match, className) => {
    return `module.exports = (sequelize) => {
  ${className}.init(${className}.attributes, {
    sequelize,
    modelName: '${className}',
    tableName: '${className.toLowerCase()}s', // Adjust this to match your table naming convention
  });
  return ${className};
};`;
  });

  fs.writeFileSync(filePath, content);
  console.log(`Updated ${filePath}`);
};

fs.readdirSync(modelsDir).forEach(file => {
  if (file.endsWith('.js') && file !== 'index.js' && file !== 'BaseModel.js') {
    const filePath = path.join(modelsDir, file);
    updateModelFile(filePath);
  }
});

console.log('All model files have been updated.');

================
File: route-check.js
================
const fs = require('fs');
const path = require('path');

const modelsDir = path.join(__dirname, 'src', 'models');
const routesDir = path.join(__dirname, 'src', 'routes');
const controllersDir = path.join(__dirname, 'src', 'controllers');

function getFiles(dir) {
  return fs.readdirSync(dir).filter(file => file.endsWith('.js') && file !== 'index.js');
}

function checkRoutesMethods(routeFile) {
  const content = fs.readFileSync(path.join(routesDir, routeFile), 'utf8');
  const methods = ['get', 'post', 'put', 'patch', 'delete'].filter(method => content.includes(`router.${method}`));
  return methods;
}

function checkControllerMethods(controllerFile) {
  const content = fs.readFileSync(path.join(controllersDir, controllerFile), 'utf8');
  const methods = ['index', 'show', 'create', 'update', 'destroy'].filter(method => content.includes(`${method}:`));
  return methods;
}

const models = getFiles(modelsDir);
const routes = getFiles(routesDir);
const controllers = getFiles(controllersDir);

console.log('Model Check Report:');
console.log('==================');

models.forEach(model => {
  const modelName = path.parse(model).name.toLowerCase();
  console.log(`\nModel: ${modelName}`);
  
  const routeFile = routes.find(route => route.toLowerCase().includes(modelName));
  if (routeFile) {
    console.log(`  Route file: ${routeFile}`);
    const routeMethods = checkRoutesMethods(routeFile);
    console.log(`  Route methods: ${routeMethods.join(', ')}`);
  } else {
    console.log(`  Route file: Missing`);
  }
  
  const controllerFile = controllers.find(controller => controller.toLowerCase().includes(modelName));
  if (controllerFile) {
    console.log(`  Controller file: ${controllerFile}`);
    const controllerMethods = checkControllerMethods(controllerFile);
    console.log(`  Controller methods: ${controllerMethods.join(', ')}`);
  } else {
    console.log(`  Controller file: Missing`);
  }
});

console.log('\nMissing Routes or Controllers:');
console.log('==============================');
models.forEach(model => {
  const modelName = path.parse(model).name.toLowerCase();
  if (!routes.some(route => route.toLowerCase().includes(modelName))) {
    console.log(`Missing route for model: ${modelName}`);
  }
  if (!controllers.some(controller => controller.toLowerCase().includes(modelName))) {
    console.log(`Missing controller for model: ${modelName}`);
  }
});

console.log('\nUnused Routes or Controllers:');
console.log('==============================');
routes.forEach(route => {
  const routeName = path.parse(route).name.toLowerCase();
  if (!models.some(model => routeName.includes(path.parse(model).name.toLowerCase()))) {
    console.log(`Potential unused route: ${route}`);
  }
});
controllers.forEach(controller => {
  const controllerName = path.parse(controller).name.toLowerCase();
  if (!models.some(model => controllerName.includes(path.parse(model).name.toLowerCase()))) {
    console.log(`Potential unused controller: ${controller}`);
  }
});

================
File: search_role_template_assignments.sh
================
#!/bin/bash

# Navigate to the backend directory
cd ~/pos-system/backend

# Use grep to search for the specific text
grep -r -i "RoleTemplateAssignments" \
    --exclude-dir=node_modules \
    --exclude-dir=.* \
    .

# Also search for any 'as' aliases that might be conflicting
grep -r -i "as: ['\"]\?RoleTemplateAssignments" \
    --exclude-dir=node_modules \
    --exclude-dir=.* \
    .

echo "Search completed."

================
File: seed-errors.json
================
[
  {
    "seeder": "20240821-create-client-profile.js",
    "error": "Command failed: npx sequelize-cli db:seed --seed 20240821-create-client-profile.js\n\u001b[31mERROR:\u001b[39m column \"clientSettings\" of relation \"Clients\" does not exist\n"
  },
  {
    "seeder": "20240821-create-guest-profiles.js",
    "error": "Command failed: npx sequelize-cli db:seed --seed 20240821-create-guest-profiles.js\n\u001b[31mERROR:\u001b[39m Cannot read properties of undefined (reading 'id')\n"
  },
  {
    "seeder": "20240821-create-locations.js",
    "error": "Command failed: npx sequelize-cli db:seed --seed 20240821-create-locations.js\n\u001b[31mERROR:\u001b[39m column \"latitude\" of relation \"Locations\" does not exist\n"
  },
  {
    "seeder": "20240821-create-orders.js",
    "error": "Command failed: npx sequelize-cli db:seed --seed 20240821-create-orders.js\n\u001b[31mERROR:\u001b[39m Cannot read properties of undefined (reading 'id')\n"
  },
  {
    "seeder": "20240821-create-test-pos-profile.js",
    "error": "Command failed: npx sequelize-cli db:seed --seed 20240821-create-test-pos-profile.js\n\u001b[31mERROR:\u001b[39m column \"posProvider\" of relation \"PosProfiles\" does not exist\n"
  },
  {
    "seeder": "20240822000400-seed-global-settings.js",
    "error": "Command failed: npx sequelize-cli db:seed --seed 20240822000400-seed-global-settings.js\n\u001b[31mERROR:\u001b[39m Cannot read properties of undefined (reading 'map')\n"
  }
]

================
File: ts_to_js_converter.py
================
import os
import re

def ts_to_js(content):
    # Remove type annotations
    content = re.sub(r': \w+', '', content)
    content = re.sub(r'<\w+>', '', content)
    
    # Convert imports
    content = re.sub(r'import (.*) from ["\'](.*)["\'](;?)', r'const \1 = require("\2")\3', content)
    
    # Convert exports
    content = re.sub(r'export const', 'exports.', content)
    content = re.sub(r'export default', 'module.exports =', content)
    
    # Convert interface to JSDoc
    content = re.sub(r'interface (\w+) {([^}]*)}', r'/**\n * @typedef {Object} \1\n\2 */', content)
    
    # Convert type to JSDoc
    content = re.sub(r'type (\w+) =', r'/** @typedef', content)
    
    # Add basic JSDoc for functions
    content = re.sub(r'(async )?function (\w+)\((.*?)\)', r'/**\n * @param {Object} params\n */\n\1function \2(\3)', content)
    
    return content

def process_directory(directory):
    for root, dirs, files in os.walk(directory):
        for file in files:
            if file.endswith('.ts'):
                file_path = os.path.join(root, file)
                new_file_path = file_path[:-3] + '.js'
                
                with open(file_path, 'r') as f:
                    content = f.read()
                
                new_content = ts_to_js(content)
                
                with open(new_file_path, 'w') as f:
                    f.write(new_content)
                
                os.remove(file_path)
                print(f"Converted {file_path} to {new_file_path}")

# Replace 'path/to/your/backend' with the actual path to your backend directory
backend_path = 'pos-system/backend'
process_directory(backend_path)

print("Conversion complete!")

================
File: updateModels.js
================
const fs = require('fs');
const path = require('path');

const modelsDir = path.join(__dirname, 'src', 'models');

const updateModelFile = (filePath) => {
  let content = fs.readFileSync(filePath, 'utf8');
  
  // Remove unexpected semicolons
  content = content.replace(/;\s*\};/g, '\n};');
  
  fs.writeFileSync(filePath, content);
  console.log(`Updated ${filePath}`);
};

fs.readdirSync(modelsDir).forEach(file => {
  if (file.endsWith('.js') && file !== 'index.js' && file !== 'BaseModel.js') {
    const filePath = path.join(modelsDir, file);
    updateModelFile(filePath);
  }
});

console.log('All model files have been updated.');
