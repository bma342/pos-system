================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-09-04T19:35:52.847Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
api/
  abTestApi.ts
  analyticsApi.ts
  apiClient.ts
  authApi.ts
  axios.ts
  axiosInstance.ts
  brandingApi.ts
  cateringApi.ts
  cateringOrderApi.ts
  challengeApi.ts
  clientApi.ts
  dashboardApi.ts
  discountApi.ts
  guestApi.ts
  inventoryApi.ts
  locationApi.ts
  loyaltyApi.ts
  loyaltyChallengeApi.ts
  menuApi.ts
  metricsApi.ts
  orderApi.ts
  posIntegrationApi.ts
  posProfileApi.ts
  posSettingsApi.ts
  providerApi.ts
  revenueApi.ts
  reviewApi.ts
  roleApi.ts
  serviceFeeApi.ts
  settingsApi.ts
  userApi.ts
  walletApi.ts
  walletDropApi.ts
components/
  layout/
    Footer.tsx
    Navbar.tsx
  tablet/
    TabletOrderManager.tsx
  ABTestManager.tsx
  AnalyticsOverview.tsx
  AuditLogViewer.tsx
  BrandingManagement.css
  ChallengeManager.tsx
  ClientAdminHub.tsx
  ClientBrandingManager.tsx
  ClientBrandingProvider.tsx
  ClientBuilderWizard.tsx
  CorePOSProfileManager.tsx
  CustomerMetricsDisplay.tsx
  DatePickerComponent.tsx
  DetailedInventoryView.tsx
  DetailedLocationView.tsx
  DiscountApplier.tsx
  DiscountBuilder.tsx
  DiscountManager.tsx
  DiscountSelector.tsx
  DoordashMarketplaceSettings.tsx
  DoordashSSIOSettings.tsx
  DropOffLocationManager.tsx
  ErrorBoundary.tsx
  errorHandler.ts
  ExecutiveDashboard.tsx
  ExportData.tsx
  Home.tsx
  InventoryAlerts.tsx
  ItemBuilder.css
  ItemReviews.tsx
  Layout.tsx
  LazyBarChart.tsx
  LazyLineChart.tsx
  LazyLocationComparisonChart.tsx
  LoadingSpinner.tsx
  LocationBuilder.tsx
  LocationCard.tsx
  LocationExceptions.tsx
  LocationList.tsx
  LocationManager.tsx
  LocationMap.tsx
  LocationSelector.tsx
  LocationSettings.tsx
  Login.tsx
  LoginForm.tsx
  LoginModal.tsx
  LoyaltyChallengeManager.tsx
  LoyaltyChallengeProgress.tsx
  LoyaltyRewards.tsx
  LoyaltyRewardSelector.tsx
  LoyaltyTiers.tsx
  MarketingCampaigns.tsx
  MarketingDashboard.tsx
  Menu.tsx
  MenuBuilder.tsx
  MenuGroupComponent.tsx
  MenuItem.tsx
  MenuItemCard.tsx
  MenuItemComponent.tsx
  MenuItemDisplay.tsx
  MenuItemModal.tsx
  MenuManager.tsx
  MultiLocationMenuManager.tsx
  OrderDashboard.tsx
  OrderManagement.tsx
  OrderProvider.tsx
  Orders.tsx
  POSAlerts.tsx
  POSDiscountSync.tsx
  POSIntegrationSelector.tsx
  POSSettingsForm.tsx
  PrivateRoute.tsx
  ProtectedRoute.tsx
  ProviderList.tsx
  RealtimeMetricsTicker.tsx
  RevenueChart.tsx
  ReviewManager.tsx
  RoleManagement.tsx
  SalesByCategoryChart.tsx
  ServiceFeeBuilder.tsx
  ServiceFeeManager.tsx
  SettingsManager.tsx
  StaffScheduler.tsx
  SubmitReview.tsx
  ThemeProvider.tsx
  TopSellingItemsChart.tsx
  UserManager.tsx
  WalletDrop.tsx
context/
  AuthContext.tsx
  CartContext.tsx
  ClientContext.tsx
  SocketContext.tsx
features/
  menuSlice.ts
  ordersSlice.ts
  rolesSlice.ts
hooks/
  useAuth.ts
  useClientBranding.ts
  useLazyImage.ts
  useQuery.ts
  useQueryWithCache.ts
  useSelectedLocation.ts
pages/
  ABTestManagement.tsx
  AdminDashboard.tsx
  AdminDiscounts.tsx
  AdminLocationManagement.tsx
  AdminLoyaltyManagement.tsx
  AdminLoyaltyRewards.tsx
  AdminMenuManagement.tsx
  AdminPanel.tsx
  AdminWalletManagement.tsx
  BrandingManagement.tsx
  BrandingSettings.tsx
  BusinessAdminDashboard.tsx
  CateringMenuItems.tsx
  CateringMenus.tsx
  CateringOrderAssignments.tsx
  CateringOrders.tsx
  CateringOrdersAdmin.tsx
  CheckoutPage.tsx
  ClientLocationsPage.tsx
  ClientSettings.tsx
  Dashboard.tsx
  GlobalAdminDashboard.tsx
  GlobalAdminPanel.tsx
  GuestLandingPage.tsx
  GuestMenuPage.tsx
  GuestProfile.tsx
  GuestProfilePage.tsx
  HomePage.tsx
  Inventory.tsx
  InventoryManagement.tsx
  LocationManagement.tsx
  Login.tsx
  LoyaltyAdminPage.tsx
  LoyaltyManagement.tsx
  Menu.tsx
  MenuBuilder.tsx
  MenuManagementAdmin.tsx
  MenuPage.tsx
  OrderConfirmation.tsx
  OrderPage.tsx
  OrderScheduling.tsx
  PosProfilePage.tsx
  PosSettingsPage.tsx
  ProfilePage.tsx
  Register.tsx
  ReportingDashboard.tsx
  UserManagement.tsx
  Wallet.tsx
redux/
  slices/
    abTestSlice.ts
    auditLogSlice.ts
    authSlice.ts
    brandingSlice.ts
    cartSlice.ts
    cateringOrderSlice.ts
    challengeSlice.ts
    clientBrandingSlice.ts
    clientConfigSlice.ts
    clientSlice.ts
    dashboardSlice.ts
    discountSlice.ts
    guestSlice.ts
    inventorySlice.ts
    LocationCard.tsx
    LocationSelectionPage.tsx
    locationSlice.ts
    loyaltySlice.ts
    menuItemsSlice.ts
    menuSlice.ts
    orderSlice.ts
    posIntegrationSlice.ts
    posProfileSlice.ts
    posSettingsSlice.ts
    providerSlice.ts
    realtimeMetricsSlice.ts
    revenueSlice.ts
    reviewSlice.ts
    roleSlice.ts
    rootReducer.ts
    salesReportSlice.ts
    serviceFeeSlice.ts
    sessionSlice.ts
    settingsSlice.ts
    tailwind.css
    types.ts
    userSlice.ts
    walletSlice.ts
  rootReducer.ts
  store.ts
services/
  abTestService.ts
  analyticsService.ts
  api.ts
  brandingService.ts
  cateringOrderService.ts
  cateringService.ts
  clientBrandingService.ts
  clientConfigService.ts
  clientService.ts
  corePOSProfileService.ts
  dashboardService.ts
  guestService.ts
  inventoryService.ts
  locationService.ts
  loyaltyService.ts
  menuItemService.ts
  menuService.ts
  posIntegrationService.ts
  posProfileService.ts
  posSettingService.ts
  providerService.ts
  reviewService.ts
  userService.ts
  walletService.ts
store/
  clientSlice.ts
  discountSlice.ts
  index.ts
  locationSlice.ts
  menuSlice.ts
styles/
  tailwind.css
types/
  abTestTypes.ts
  analyticsTypes.ts
  authTypes.ts
  cateringOrderTypes.ts
  cateringTypes.ts
  challengeTypes.ts
  clientTypes.ts
  dashboardTypes.ts
  dateTypes.ts
  discountTypes.ts
  guestTypes.ts
  index.ts
  inventoryTypes.ts
  locationTypes.ts
  loyaltyTypes.ts
  menuTypes.ts
  orderTypes.ts
  paginationTypes.ts
  posIntegrationTypes.ts
  posSettingsTypes.ts
  posTypes.ts
  providerTypes.ts
  revenueTypes.ts
  reviewTypes.ts
  roleTypes.ts
  serviceFeeTypes.ts
  settingsTypes.ts
  tenantTypes.ts
  userTypes.ts
  walletTypes.ts
utils/
  abTestUtils.ts
  auth.ts
  errorHandler.js
  errorHandler.ts
  exportUtils.ts
  logger.ts
  socket.ts
  subdomain.ts
  themeUtils.ts
App.css
App.js
App.tsx
ClientContext.tsx
component-types.txt
defined-types.txt
env.d.ts
index.css
index.html
index.html.1
index.html.2
index.tsx
logo.svg
missing-types.txt
reducers.ts
reportWebVitals.ts
routes.tsx
serviceWorker.ts
serviceWorkerRegistration.ts
setupProxy.js
theme.ts
types.ts

================================================================
Repository Files
================================================================

================
File: api/abTestApi.ts
================
import { ABTest } from '../types/abTestTypes';
import apiClient from './apiClient';

export const abTestApi = {
  getABTests: async (): Promise<ABTest[]> => {
    try {
      const response = await apiClient.get<ABTest[]>('/ab-tests');
      return response.data;
    } catch (error) {
      console.error('Error fetching AB tests:', error);
      throw error;
    }
  },

  getABTest: async (id: number): Promise<ABTest> => {
    try {
      const response = await apiClient.get<ABTest>(`/ab-tests/${id}`);
      return response.data;
    } catch (error) {
      console.error(`Error fetching AB test with id ${id}:`, error);
      throw error;
    }
  },

  createABTest: async (abTest: Omit<ABTest, 'id'>): Promise<ABTest> => {
    try {
      const response = await apiClient.post<ABTest>('/ab-tests', abTest);
      return response.data;
    } catch (error) {
      console.error('Error creating AB test:', error);
      throw error;
    }
  },

  updateABTest: async (abTest: ABTest): Promise<ABTest> => {
    try {
      const response = await apiClient.put<ABTest>(`/ab-tests/${abTest.id}`, abTest);
      return response.data;
    } catch (error) {
      console.error(`Error updating AB test with id ${abTest.id}:`, error);
      throw error;
    }
  },

  deleteABTest: async (id: number): Promise<void> => {
    try {
      await apiClient.delete(`/ab-tests/${id}`);
    } catch (error) {
      console.error(`Error deleting AB test with id ${id}:`, error);
      throw error;
    }
  },

  getABTestResults: async (id: number): Promise<any> => {
    try {
      const response = await apiClient.get(`/ab-tests/${id}/results`);
      return response.data;
    } catch (error) {
      console.error(`Error fetching results for AB test with id ${id}:`, error);
      throw error;
    }
  },
};

================
File: api/analyticsApi.ts
================
import axios from 'axios';
import { TopSellingItem, SalesByCategory, AnalyticsData } from '../types/analyticsTypes';

const BASE_URL = '/api/analytics';

export const fetchTopSellingItems = async (startDate?: string, endDate?: string): Promise<TopSellingItem[]> => {
  const response = await axios.get(`${BASE_URL}/top-selling-items`, { params: { startDate, endDate } });
  return response.data;
};

export const fetchSalesByCategory = async (startDate?: string, endDate?: string): Promise<SalesByCategory[]> => {
  const response = await axios.get(`${BASE_URL}/sales-by-category`, { params: { startDate, endDate } });
  return response.data;
};

export const fetchRevenueOverTime = async (startDate: string, endDate: string, interval: 'day' | 'week' | 'month'): Promise<AnalyticsData[]> => {
  const response = await axios.get(`${BASE_URL}/revenue-over-time`, { params: { startDate, endDate, interval } });
  return response.data;
};

export const fetchCustomerRetentionRate = async (startDate: string, endDate: string): Promise<number> => {
  const response = await axios.get(`${BASE_URL}/customer-retention-rate`, { params: { startDate, endDate } });
  return response.data;
};

export const fetchAverageOrderValue = async (startDate?: string, endDate?: string): Promise<number> => {
  const response = await axios.get(`${BASE_URL}/average-order-value`, { params: { startDate, endDate } });
  return response.data;
};

================
File: api/apiClient.ts
================
import axios, {
  AxiosInstance,
  InternalAxiosRequestConfig,
  AxiosResponse,
} from 'axios';

const apiClient: AxiosInstance = axios.create({
  baseURL: process.env.REACT_APP_API_BASE_URL || '/api',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor
apiClient.interceptors.request.use(
  (config: InternalAxiosRequestConfig) => {
    // You can add auth token here
    const token = localStorage.getItem('authToken');
    if (token) {
      config.headers = config.headers || {};
      config.headers['Authorization'] = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor
apiClient.interceptors.response.use(
  (response: AxiosResponse) => {
    return response;
  },
  (error) => {
    if (error.response?.status === 401) {
      // Handle unauthorized access
      // e.g., redirect to login page
    }
    return Promise.reject(error);
  }
);

export default apiClient;

================
File: api/authApi.ts
================
import apiClient from './apiClient';
import { User } from '../types/authTypes';

export const authApi = {
  login: async (email: string, password: string): Promise<{ token: string; user: User }> => {
    const response = await apiClient.post('/auth/login', { email, password });
    return response.data;
  },

  getCurrentUser: async (): Promise<User> => {
    const response = await apiClient.get('/auth/me');
    return response.data;
  },
};

================
File: api/axios.ts
================
import axios, { AxiosError, InternalAxiosRequestConfig } from 'axios';
import { store } from '../redux/store';
import refreshTokenAction, { logout } from '../redux/slices/authSlice'; // Corrected import
import { handleApiError } from '../utils/errorHandler';

const axiosInstance = axios.create({
  baseURL: process.env.REACT_APP_API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

axiosInstance.interceptors.request.use(
  (config: InternalAxiosRequestConfig) => {
    const token = store.getState().auth.token; // Ensure auth state has 'token' property
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`;
    }
    return config;
  },
  (error: AxiosError) => {
    handleApiError(error);
    return Promise.reject(error);
  }
);

axiosInstance.interceptors.response.use(
  (response) => response,
  async (error: AxiosError) => {
    const originalRequest = error.config as InternalAxiosRequestConfig & {
      _retry?: boolean;
    };

    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      try {
        const action = await store.dispatch(refreshTokenAction({}));
        if (refreshTokenAction.fulfilled.match(action)) {
          return axiosInstance(originalRequest);
        }
      } catch (refreshError) {
        store.dispatch(logout());
        if (refreshError instanceof Error || axios.isAxiosError(refreshError)) {
          handleApiError(refreshError);
        } else {
          console.error('Unknown refresh token error:', refreshError);
        }
        return Promise.reject(refreshError);
      }
    }

    handleApiError(error);
    return Promise.reject(error);
  }
);

export default axiosInstance;

================
File: api/axiosInstance.ts
================
import axios from 'axios';
import { getSubdomain } from '../utils/subdomain';

const axiosInstance = axios.create({
  baseURL: process.env.REACT_APP_API_URL,
});

axiosInstance.interceptors.request.use((config) => {
  const subdomain = getSubdomain();
  if (subdomain) {
    config.headers['X-Subdomain'] = subdomain;
  }
  return config;
});

export default axiosInstance;

================
File: api/brandingApi.ts
================
import axios from './axios';
import { BrandingProfile, Wallet, Discount, LoyaltyReward } from '../types';

export const fetchBrandingProfiles = async (
  clientId: number
): Promise<BrandingProfile[]> => {
  const response = await axios.get(`/branding/client/${clientId}`);
  return response.data;
};

export const saveBrandingProfile = async (
  profile: BrandingProfile
): Promise<BrandingProfile> => {
  const response = profile.id
    ? await axios.put(`/branding/client/${profile.clientId}`, profile)
    : await axios.post(`/branding/client/${profile.clientId}`, profile);
  return response.data;
};

export const uploadLogo = async (
  clientId: number,
  file: File
): Promise<string> => {
  const formData = new FormData();
  formData.append('file', file);
  formData.append('clientId', clientId.toString());

  const response = await axios.post('/branding/upload-logo', formData, {
    headers: {
      'Content-Type': 'multipart/form-data',
    },
  });

  return response.data.url;
};

export const getWalletDetails = (clientId: number): Promise<Wallet> => {
  return axios.get(`/wallet/${clientId}`).then((response) => response.data);
};

export const getClientDiscounts = (clientId: number): Promise<Discount[]> => {
  return axios.get(`/discounts/${clientId}`).then((response) => response.data);
};

export const getLoyaltyRewards = (
  clientId: number
): Promise<LoyaltyReward[]> => {
  return axios
    .get(`/loyalty-rewards/${clientId}`)
    .then((response) => response.data);
};

================
File: api/cateringApi.ts
================
import axios from 'axios';
import { CateringOrder, CateringMenu, CateringEvent } from '../types/cateringTypes';

const BASE_URL = '/api/catering';

export const fetchCateringOrders = async (clientId: string): Promise<CateringOrder[]> => {
  const response = await axios.get(`${BASE_URL}/orders`, { params: { clientId } });
  return response.data;
};

export const createCateringOrder = async (order: Omit<CateringOrder, 'id'>): Promise<CateringOrder> => {
  const response = await axios.post(`${BASE_URL}/orders`, order);
  return response.data;
};

export const updateCateringOrder = async (orderId: string, order: Partial<CateringOrder>): Promise<CateringOrder> => {
  const response = await axios.put(`${BASE_URL}/orders/${orderId}`, order);
  return response.data;
};

export const deleteCateringOrder = async (orderId: string): Promise<void> => {
  await axios.delete(`${BASE_URL}/orders/${orderId}`);
};

export const fetchCateringMenu = async (clientId: string): Promise<CateringMenu> => {
  const response = await axios.get(`${BASE_URL}/menu`, { params: { clientId } });
  return response.data;
};

export const updateCateringMenu = async (clientId: string, menu: Partial<CateringMenu>): Promise<CateringMenu> => {
  const response = await axios.put(`${BASE_URL}/menu`, menu, { params: { clientId } });
  return response.data;
};

export const createCateringEvent = async (event: Omit<CateringEvent, 'id'>): Promise<CateringEvent> => {
  const response = await axios.post(`${BASE_URL}/events`, event);
  return response.data;
};

export const fetchCateringEvents = async (clientId: string): Promise<CateringEvent[]> => {
  const response = await axios.get(`${BASE_URL}/events`, { params: { clientId } });
  return response.data;
};

================
File: api/cateringOrderApi.ts
================
import apiClient from './apiClient';
import { OrderStatistics } from '../types/cateringOrderTypes';

export const cateringOrderApi = {
  // ... other methods

  getOrderStatistics: async (clientId: string, startDate: string, endDate: string): Promise<OrderStatistics> => {
    const response = await apiClient.get(`/catering-orders/statistics/${clientId}`, {
      params: { startDate, endDate },
    });
    return response.data;
  },
};

================
File: api/challengeApi.ts
================
import apiClient from './axios';
import { Challenge } from '../types/challengeTypes';

export const getChallenges = async (): Promise<Challenge[]> => {
  const response = await apiClient.get<Challenge[]>('/api/challenges');
  return response.data;
};

export const createChallenge = async (
  challengeData: Omit<Challenge, 'id' | 'createdAt' | 'updatedAt'>
): Promise<Challenge> => {
  const response = await apiClient.post<Challenge>(
    '/api/challenges',
    challengeData
  );
  return response.data;
};

export const updateChallenge = async (
  id: number,
  challengeData: Partial<Challenge>
): Promise<Challenge> => {
  const response = await apiClient.put<Challenge>(
    `/api/challenges/${id}`,
    challengeData
  );
  return response.data;
};

export const deleteChallenge = async (id: number): Promise<void> => {
  await apiClient.delete(`/api/challenges/${id}`);
};

export const getChallengesByLocation = async (
  locationId: number
): Promise<Challenge[]> => {
  const response = await apiClient.get<Challenge[]>(
    `/api/challenges/location/${locationId}`
  );
  return response.data;
};

export const getChallengesByClient = async (
  clientId: number
): Promise<Challenge[]> => {
  const response = await apiClient.get<Challenge[]>(
    `/api/challenges/client/${clientId}`
  );
  return response.data;
};

================
File: api/clientApi.ts
================
import axios from 'axios';
import {
  Client,
  ClientPreferences,
  ClientBranding,
} from '../types/clientTypes';

const API_BASE_URL =
  process.env.REACT_APP_API_BASE_URL || 'https://api.eatsuite.net';

// Use API_BASE_URL in your axios calls
const apiClient = axios.create({
  baseURL: API_BASE_URL,
});

// Replace all axios calls with apiClient
export const fetchClientId = async (): Promise<number | null> => {
  try {
    const response = await apiClient.get<number>('/api/clients/get-client-id');
    return response.data;
  } catch (error) {
    console.error('Error fetching client ID:', error);
    return null;
  }
};

export const updateClientDetails = async (
  clientId: number,
  clientData: Partial<Client>
): Promise<Client | null> => {
  try {
    const response = await apiClient.put<Client>(
      `/api/clients/${clientId}`,
      clientData
    );
    return response.data;
  } catch (error) {
    console.error('Error updating client details:', error);
    return null;
  }
};

export const deleteClient = async (clientId: number): Promise<boolean> => {
  try {
    await apiClient.delete(`/api/clients/${clientId}`);
    return true;
  } catch (error) {
    console.error('Error deleting client:', error);
    return false;
  }
};

export const fetchClientBranding = async (): Promise<ClientBranding> => {
  try {
    const response = await apiClient.get('/api/client-branding');
    return response.data;
  } catch (error) {
    throw new Error('Failed to fetch client branding');
  }
};

export const updateClientBranding = async (
  brandingData: ClientBranding
): Promise<ClientBranding> => {
  try {
    const response = await apiClient.put('/api/client-branding', brandingData);
    return response.data;
  } catch (error) {
    throw new Error('Failed to update client branding');
  }
};

export const createClient = async (clientData: Partial<Client>) => {
  try {
    const response = await apiClient.post<Client>('/api/clients', clientData);
    return response.data;
  } catch (error) {
    throw new Error('Failed to create client');
  }
};

export const updateClientPreferences = async (
  clientId: string,
  preferences: Partial<ClientPreferences>
): Promise<Client> => {
  const response = await apiClient.put<Client>(
    `/api/clients/${clientId}/preferences`,
    preferences
  );
  return response.data;
};

export const fetchClientBySubdomain = async (
  subdomain: string
): Promise<Client> => {
  try {
    const response = await apiClient.get<Client>(
      `/api/clients/subdomain/${subdomain}`
    );
    return response.data;
  } catch (error) {
    console.error('Error fetching client by subdomain:', error);
    throw error;
  }
};

================
File: api/dashboardApi.ts
================
import axiosInstance from './axios';
import { DashboardStat } from '../types';

export const fetchDashboardStats = async (): Promise<DashboardStat[]> => {
  try {
    const response = await axiosInstance.get<DashboardStat[]>(
      '/api/dashboard/stats'
    );
    return response.data;
  } catch (error) {
    throw new Error('Failed to fetch dashboard stats');
  }
};

================
File: api/discountApi.ts
================
import { apiCall } from '../services/api';
import { Discount } from '../types';

export const getDiscounts = () =>
  apiCall<Discount[]>({ url: '/discounts', method: 'GET' });

export const createDiscount = (discount: Omit<Discount, 'id' | 'usageCount'>) =>
  apiCall<Discount>({ url: '/discounts', method: 'POST', data: discount });

export const updateDiscount = (id: number, discount: Partial<Discount>) =>
  apiCall<Discount>({ url: `/discounts/${id}`, method: 'PUT', data: discount });

export const deleteDiscount = (id: number) =>
  apiCall<void>({ url: `/discounts/${id}`, method: 'DELETE' });

export const applyDiscount = (code: string, cartTotal: number) =>
  apiCall<{ discountedTotal: number; appliedDiscount: Discount }>({
    url: '/discounts/apply',
    method: 'POST',
    data: { code, cartTotal },
  });

export const syncDiscountsFromPOS = (locationId: number) =>
  apiCall<void>({
    url: '/discounts/sync-from-pos',
    method: 'POST',
    data: { locationId },
  });

export const syncDiscountsForAllLocations = () =>
  apiCall<void>({ url: '/discounts/sync-all-locations', method: 'POST' });

export const fetchDiscountsByLocation = (clientId: number) =>
  apiCall<Discount[]>({
    url: `/discounts/by-location/${clientId}`,
    method: 'GET',
  });

================
File: api/guestApi.ts
================
import apiClient from './apiClient';
import { Reward, CartItem } from '../types';

export const fetchGuestRewards = async (guestId: number): Promise<Reward[]> => {
  try {
    const response = await apiClient.get(`/api/guests/${guestId}/rewards`);
    return response.data;
  } catch (error) {
    throw new Error('Failed to fetch guest rewards');
  }
};

export const checkInventory = async (cartItems: CartItem[]): Promise<boolean> => {
  try {
    const response = await apiClient.post('/api/check-inventory', {
      items: cartItems,
    });
    return response.data.inStock;
  } catch (error) {
    throw new Error('Failed to check inventory');
  }
};

export const getEstimatedPrepTime = async (cartItems: CartItem[]): Promise<string> => {
  try {
    const response = await apiClient.post('/api/estimated-prep-time', {
      items: cartItems,
    });
    return response.data.estimatedTime;
  } catch (error) {
    throw new Error('Failed to get estimated prep time');
  }
};

================
File: api/inventoryApi.ts
================
import axios from 'axios';
import { InventoryItem } from '../types';

const API_BASE_URL =
  process.env.REACT_APP_API_BASE_URL || 'http://localhost:5000/api';

export const fetchInventoryItems = async (): Promise<InventoryItem[]> => {
  try {
    const response = await axios.get<InventoryItem[]>(
      `${API_BASE_URL}/inventory`
    );
    return response.data;
  } catch (error) {
    console.error('Error fetching inventory items:', error);
    throw error;
  }
};

export const getInventoryItemById = async (
  id: number
): Promise<InventoryItem> => {
  try {
    const response = await axios.get<InventoryItem>(
      `${API_BASE_URL}/inventory/${id}`
    );
    return response.data;
  } catch (error) {
    console.error(`Error fetching inventory item with id ${id}:`, error);
    throw error;
  }
};

export const createInventoryItem = async (
  itemData: Partial<InventoryItem>
): Promise<InventoryItem> => {
  try {
    const response = await axios.post<InventoryItem>(
      `${API_BASE_URL}/inventory`,
      itemData
    );
    return response.data;
  } catch (error) {
    console.error('Error creating inventory item:', error);
    throw error;
  }
};

export const updateInventoryItem = async (
  id: number,
  itemData: Partial<InventoryItem>
): Promise<InventoryItem> => {
  try {
    const response = await axios.put<InventoryItem>(
      `${API_BASE_URL}/inventory/${id}`,
      itemData
    );
    return response.data;
  } catch (error) {
    console.error(`Error updating inventory item with id ${id}:`, error);
    throw error;
  }
};

export const deleteInventoryItem = async (id: number): Promise<void> => {
  try {
    await axios.delete(`${API_BASE_URL}/inventory/${id}`);
  } catch (error) {
    console.error(`Error deleting inventory item with id ${id}:`, error);
    throw error;
  }
};

export const updateInventoryQuantity = async (
  id: number,
  quantity: number
): Promise<InventoryItem> => {
  try {
    const response = await axios.patch<InventoryItem>(
      `${API_BASE_URL}/inventory/${id}/quantity`,
      { quantity }
    );
    return response.data;
  } catch (error) {
    console.error(
      `Error updating quantity for inventory item with id ${id}:`,
      error
    );
    throw error;
  }
};

================
File: api/locationApi.ts
================
import { Location, LocationCreateData } from '../types/locationTypes';
import apiClient from './apiClient';

export const locationApi = {
  getLocations: async (): Promise<Location[]> => {
    try {
      const response = await apiClient.get<Location[]>('/locations');
      return response.data;
    } catch (error) {
      console.error('Error fetching locations:', error);
      throw error;
    }
  },

  getLocation: async (id: number): Promise<Location> => {
    try {
      const response = await apiClient.get<Location>(`/locations/${id}`);
      return response.data;
    } catch (error) {
      console.error(`Error fetching location with id ${id}:`, error);
      throw error;
    }
  },

  createLocation: async (location: LocationCreateData): Promise<Location> => {
    try {
      const response = await apiClient.post<Location>('/locations', location);
      return response.data;
    } catch (error) {
      console.error('Error creating location:', error);
      throw error;
    }
  },

  updateLocation: async (location: Location): Promise<Location> => {
    try {
      const response = await apiClient.put<Location>(`/locations/${location.id}`, location);
      return response.data;
    } catch (error) {
      console.error(`Error updating location with id ${location.id}:`, error);
      throw error;
    }
  },

  deleteLocation: async (id: number): Promise<void> => {
    try {
      await apiClient.delete(`/locations/${id}`);
    } catch (error) {
      console.error(`Error deleting location with id ${id}:`, error);
      throw error;
    }
  },

  getLocationMenu: async (id: number): Promise<any> => {
    try {
      const response = await apiClient.get(`/locations/${id}/menu`);
      return response.data;
    } catch (error) {
      console.error(`Error fetching menu for location with id ${id}:`, error);
      throw error;
    }
  },

  getLocationOrders: async (id: number): Promise<any> => {
    try {
      const response = await apiClient.get(`/locations/${id}/orders`);
      return response.data;
    } catch (error) {
      console.error(`Error fetching orders for location with id ${id}:`, error);
      throw error;
    }
  },
};

================
File: api/loyaltyApi.ts
================
import apiClient from './axios';
import { LoyaltyReward } from '../types';

interface LoyaltyProgramData {
  tiers: { name: string; pointThreshold: number }[];
  pointsPerDollar: number;
}

interface LoyaltyChallengeData {
  name: string;
  description: string;
  pointReward: number;
  startDate: string;
  endDate: string;
}

// Fetch loyalty rewards by guest ID
export const fetchLoyaltyRewards = async (
  guestId: number
): Promise<LoyaltyReward[]> => {
  const response = await apiClient.get<LoyaltyReward[]>(
    `/api/loyalty/${guestId}`
  );
  return response.data;
};

// Update loyalty program
export const updateLoyaltyProgram = async (
  clientId: number,
  data: LoyaltyProgramData
): Promise<void> => {
  await apiClient.put(`/api/loyalty/${clientId}`, data);
};

export const upsertLoyaltyChallenge = async (
  challengeData: LoyaltyChallengeData
): Promise<void> => {
  await apiClient.post('/api/loyalty/challenge', challengeData);
};

// Delete a loyalty challenge
export const deleteLoyaltyChallenge = async (
  challengeId: number
): Promise<void> => {
  await apiClient.delete(`/api/loyalty/challenge/${challengeId}`);
};

================
File: api/loyaltyChallengeApi.ts
================
import apiClient from './axios';
import { LoyaltyChallenge, LoyaltyChallengeProgress } from '../types/loyaltyTypes';

export const getLoyaltyChallenges = async (): Promise<LoyaltyChallenge[]> => {
  const response = await apiClient.get('/api/loyalty-challenges');
  return response.data;
};

export const createLoyaltyChallenge = async (
  challenge: Omit<LoyaltyChallenge, 'id'>
): Promise<LoyaltyChallenge> => {
  const response = await apiClient.post('/api/loyalty-challenges', challenge);
  return response.data;
};

export const updateLoyaltyChallenge = async (
  id: number,
  challenge: Partial<LoyaltyChallenge>
): Promise<LoyaltyChallenge> => {
  const response = await apiClient.put(
    `/api/loyalty-challenges/${id}`,
    challenge
  );
  return response.data;
};

export const deleteLoyaltyChallenge = async (id: number): Promise<void> => {
  await apiClient.delete(`/api/loyalty-challenges/${id}`);
};

export const getGuestChallengeProgress = async (
  guestId: number
): Promise<LoyaltyChallengeProgress[]> => {
  const response = await apiClient.get(
    `/api/loyalty-challenges/progress/${guestId}`
  );
  return response.data;
};

================
File: api/menuApi.ts
================
import apiClient from './apiClient';
import { Menu, MenuStatistics } from '../types/menuTypes';

export const menuApi = {
  getMenu: async (clientId: string): Promise<Menu> => {
    try {
      const response = await apiClient.get(`/menus/${clientId}`);
      return response.data;
    } catch (error) {
      console.error(`Error fetching menu for client ${clientId}:`, error);
      throw error;
    }
  },

  getMenuStatistics: async (clientId: string): Promise<MenuStatistics> => {
    try {
      const response = await apiClient.get(`/menus/statistics/${clientId}`);
      return response.data;
    } catch (error) {
      console.error(`Error fetching menu statistics for client ${clientId}:`, error);
      throw error;
    }
  },

  // Add other API methods as needed
};

================
File: api/metricsApi.ts
================
import axios from 'axios';
import { RealtimeMetrics } from '../types';

export const fetchRealtimeMetrics = async (
  clientId: string
): Promise<{ data: RealtimeMetrics }> => {
  const response = await axios.get(`/api/clients/${clientId}/realtime-metrics`);
  return response.data;
};

================
File: api/orderApi.ts
================
import api from './axios';
import { Order, OrderItem } from '../types';

export const createOrder = async (orderData: Partial<Order>) => {
  try {
    return await api.post<Order>('/orders', orderData);
  } catch (error) {
    throw new Error('Failed to create order');
  }
};

export const getActiveOrders = async () => {
  try {
    return await api.get<Order[]>('/orders/active');
  } catch (error) {
    throw new Error('Failed to fetch active orders');
  }
};

export const cancelOrder = async (orderId: string) => {
  try {
    return await api.post<Order>(`/orders/${orderId}/cancel`);
  } catch (error) {
    throw new Error(`Failed to cancel order ${orderId}`);
  }
};

export const markItemOutOfStock = async (orderId: string, itemId: string) => {
  try {
    return await api.post<OrderItem>(
      `/orders/${orderId}/items/${itemId}/out-of-stock`
    );
  } catch (error) {
    throw new Error(`Failed to mark item ${itemId} out of stock for order ${orderId}`);
  }
};

// Add other order-related API calls as needed

================
File: api/posIntegrationApi.ts
================
import apiClient from './apiClient';

export const fetchPOSIntegrations = async () => {
  return await apiClient.get('/api/pos-integrations');
};

================
File: api/posProfileApi.ts
================
import axios from 'axios';
import { POSProfile, POSIntegration } from '../types/posTypes';

const BASE_URL = '/api/pos-profiles';

export const fetchPOSProfiles = async (clientId: string): Promise<POSProfile[]> => {
  const response = await axios.get(`${BASE_URL}`, { params: { clientId } });
  return response.data;
};

export const createPOSProfile = async (profile: Omit<POSProfile, 'id'>): Promise<POSProfile> => {
  const response = await axios.post(`${BASE_URL}`, profile);
  return response.data;
};

export const updatePOSProfile = async (profileId: string, profile: Partial<POSProfile>): Promise<POSProfile> => {
  const response = await axios.put(`${BASE_URL}/${profileId}`, profile);
  return response.data;
};

export const deletePOSProfile = async (profileId: string): Promise<void> => {
  await axios.delete(`${BASE_URL}/${profileId}`);
};

export const fetchPOSIntegrations = async (clientId: string): Promise<POSIntegration[]> => {
  const response = await axios.get(`${BASE_URL}/integrations`, { params: { clientId } });
  return response.data;
};

export const createPOSIntegration = async (integration: Omit<POSIntegration, 'id'>): Promise<POSIntegration> => {
  const response = await axios.post(`${BASE_URL}/integrations`, integration);
  return response.data;
};

export const updatePOSIntegration = async (integrationId: string, integration: Partial<POSIntegration>): Promise<POSIntegration> => {
  const response = await axios.put(`${BASE_URL}/integrations/${integrationId}`, integration);
  return response.data;
};

export const deletePOSIntegration = async (integrationId: string): Promise<void> => {
  await axios.delete(`${BASE_URL}/integrations/${integrationId}`);
};

export const syncPOSProfile = async (profileId: string): Promise<void> => {
  await axios.post(`${BASE_URL}/${profileId}/sync`);
};

================
File: api/posSettingsApi.ts
================
import axios from 'axios';

export const fetchPOSSettings = async () => {
  try {
    const response = await axios.get('/api/pos-settings');
    return response.data;
  } catch (error) {
    throw new Error('Failed to fetch POS settings');
  }
};

export const updatePOSSettings = async (settings: {
  modifierSendMethod: string;
}) => {
  try {
    const response = await axios.put('/api/pos-settings', settings);
    return response.data;
  } catch (error) {
    throw new Error('Failed to update POS settings');
  }
};

================
File: api/providerApi.ts
================
import axios from 'axios';
import { Provider, ProviderIntegration } from '../types/providerTypes';

const BASE_URL = '/api/providers';

export const fetchProviders = async (clientId: string): Promise<Provider[]> => {
  const response = await axios.get(`${BASE_URL}`, { params: { clientId } });
  return response.data;
};

export const createProvider = async (provider: Omit<Provider, 'id'>): Promise<Provider> => {
  const response = await axios.post(`${BASE_URL}`, provider);
  return response.data;
};

export const updateProvider = async (providerId: string, provider: Partial<Provider>): Promise<Provider> => {
  const response = await axios.put(`${BASE_URL}/${providerId}`, provider);
  return response.data;
};

export const deleteProvider = async (providerId: string): Promise<void> => {
  await axios.delete(`${BASE_URL}/${providerId}`);
};

export const fetchProviderIntegrations = async (clientId: string): Promise<ProviderIntegration[]> => {
  const response = await axios.get(`${BASE_URL}/integrations`, { params: { clientId } });
  return response.data;
};

export const createProviderIntegration = async (integration: Omit<ProviderIntegration, 'id'>): Promise<ProviderIntegration> => {
  const response = await axios.post(`${BASE_URL}/integrations`, integration);
  return response.data;
};

export const updateProviderIntegration = async (integrationId: string, integration: Partial<ProviderIntegration>): Promise<ProviderIntegration> => {
  const response = await axios.put(`${BASE_URL}/integrations/${integrationId}`, integration);
  return response.data;
};

export const deleteProviderIntegration = async (integrationId: string): Promise<void> => {
  await axios.delete(`${BASE_URL}/integrations/${integrationId}`);
};

export const syncProviderData = async (providerId: string): Promise<void> => {
  await axios.post(`${BASE_URL}/${providerId}/sync`);
};

================
File: api/revenueApi.ts
================
import api from '../services/api';

export const fetchRevenueData = async (dateRange: { startDate: string; endDate: string }) => {
  const response = await api.get('/revenue', { params: dateRange });
  return response.data;
};

================
File: api/reviewApi.ts
================
import axios from 'axios';
import { Review, ReviewCreateData } from '../types/reviewTypes';

const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:3000/api';

export const createReview = async (
  reviewData: ReviewCreateData
): Promise<Review> => {
  const response = await axios.post<Review>('/api/reviews', reviewData);
  return response.data;
};

export const getReviewsForMenuItem = async (menuItemId: number) => {
  const response = await axios.get(`${API_URL}/reviews/menuItem/${menuItemId}`);
  return response.data;
};

export const getPendingReviews = async () => {
  const response = await axios.get(`${API_URL}/reviews/pending`);
  return response.data;
};

export const approveReview = async (reviewId: number) => {
  const response = await axios.put(`${API_URL}/reviews/approve/${reviewId}`);
  return response.data;
};

export const deleteReview = async (reviewId: number) => {
  await axios.delete(`${API_URL}/reviews/${reviewId}`);
};

================
File: api/roleApi.ts
================
import axios from 'axios';
import { Role, Permission } from '../types/roleTypes';

const BASE_URL = '/api/roles';

export const fetchRoles = async (clientId: string): Promise<Role[]> => {
  const response = await axios.get(`${BASE_URL}`, { params: { clientId } });
  return response.data;
};

export const createRole = async (role: Omit<Role, 'id'>): Promise<Role> => {
  const response = await axios.post(`${BASE_URL}`, role);
  return response.data;
};

export const updateRole = async (roleId: string, role: Partial<Role>): Promise<Role> => {
  const response = await axios.put(`${BASE_URL}/${roleId}`, role);
  return response.data;
};

export const deleteRole = async (roleId: string): Promise<void> => {
  await axios.delete(`${BASE_URL}/${roleId}`);
};

export const fetchPermissions = async (): Promise<Permission[]> => {
  const response = await axios.get(`${BASE_URL}/permissions`);
  return response.data;
};

export const assignRoleToUser = async (userId: string, roleId: string): Promise<void> => {
  await axios.post(`${BASE_URL}/assign`, { userId, roleId });
};

export const removeRoleFromUser = async (userId: string, roleId: string): Promise<void> => {
  await axios.post(`${BASE_URL}/remove`, { userId, roleId });
};

================
File: api/serviceFeeApi.ts
================
import api from './axios';
import { ServiceFee } from '../types/serviceFeeTypes';
import logger from '../utils/logger';

export const ServiceFeeApi = {
  async getServiceFees(clientId: string): Promise<ServiceFee[]> {
    try {
      const response = await api.get<ServiceFee[]>(
        `/clients/${clientId}/service-fees`
      );
      logger.info('Fetched service fees successfully', { clientId });
      return response.data;
    } catch (error) {
      logger.error('Error fetching service fees', { clientId, error });
      throw error;
    }
  },

  async createServiceFee(
    clientId: string,
    serviceFee: Omit<ServiceFee, 'id'>
  ): Promise<ServiceFee> {
    try {
      const response = await api.post<ServiceFee>(
        `/clients/${clientId}/service-fees`,
        serviceFee
      );
      logger.info('Created service fee successfully', {
        clientId,
        serviceFeeId: response.data.id,
      });
      return response.data;
    } catch (error) {
      logger.error('Error creating service fee', { clientId, error });
      throw error;
    }
  },

  async updateServiceFee(
    clientId: string,
    serviceFeeId: string,
    serviceFee: Partial<ServiceFee>
  ): Promise<ServiceFee> {
    try {
      const response = await api.put<ServiceFee>(
        `/clients/${clientId}/service-fees/${serviceFeeId}`,
        serviceFee
      );
      logger.info('Updated service fee successfully', {
        clientId,
        serviceFeeId,
      });
      return response.data;
    } catch (error) {
      logger.error('Error updating service fee', {
        clientId,
        serviceFeeId,
        error,
      });
      throw error;
    }
  },

  async deleteServiceFee(
    clientId: string,
    serviceFeeId: string
  ): Promise<void> {
    try {
      await api.delete(`/clients/${clientId}/service-fees/${serviceFeeId}`);
      logger.info('Deleted service fee successfully', {
        clientId,
        serviceFeeId,
      });
    } catch (error) {
      logger.error('Error deleting service fee', {
        clientId,
        serviceFeeId,
        error,
      });
      throw error;
    }
  },
};

export default ServiceFeeApi;

================
File: api/settingsApi.ts
================
import axios from 'axios';
import { Settings } from '../types/settingsTypes';

const API_BASE_URL =
  process.env.REACT_APP_API_BASE_URL || 'http://localhost:5000/api';

export const fetchSettings = async (clientId: number): Promise<Settings> => {
  const response = await axios.get(`${API_BASE_URL}/settings/${clientId}`);
  return response.data;
};

export const updateSettings = async (
  clientId: number,
  settings: Partial<Settings>
): Promise<Settings> => {
  const response = await axios.put(
    `${API_BASE_URL}/settings/${clientId}`,
    settings
  );
  return response.data;
};

export const fetchSettingsByKey = async (
  clientId: number,
  key: string
): Promise<any> => {
  const response = await axios.get(
    `${API_BASE_URL}/settings/${clientId}/${key}`
  );
  return response.data;
};

export const updateSettingByKey = async (
  clientId: number,
  key: string,
  value: any
): Promise<any> => {
  const response = await axios.put(
    `${API_BASE_URL}/settings/${clientId}/${key}`,
    { value }
  );
  return response.data;
};

================
File: api/userApi.ts
================
import axios from 'axios';
import { User, UserProfile } from '../types/userTypes';

const BASE_URL = '/api/users';

export const fetchUsers = async (clientId: string): Promise<User[]> => {
  const response = await axios.get(`${BASE_URL}`, { params: { clientId } });
  return response.data;
};

export const createUser = async (user: Omit<User, 'id'>): Promise<User> => {
  const response = await axios.post(`${BASE_URL}`, user);
  return response.data;
};

export const updateUser = async (userId: string, user: Partial<User>): Promise<User> => {
  const response = await axios.put(`${BASE_URL}/${userId}`, user);
  return response.data;
};

export const deleteUser = async (userId: string): Promise<void> => {
  await axios.delete(`${BASE_URL}/${userId}`);
};

export const fetchUserProfile = async (userId: string): Promise<UserProfile> => {
  const response = await axios.get(`${BASE_URL}/${userId}/profile`);
  return response.data;
};

export const updateUserProfile = async (userId: string, profile: Partial<UserProfile>): Promise<UserProfile> => {
  const response = await axios.put(`${BASE_URL}/${userId}/profile`, profile);
  return response.data;
};

export const changeUserPassword = async (userId: string, currentPassword: string, newPassword: string): Promise<void> => {
  await axios.post(`${BASE_URL}/${userId}/change-password`, { currentPassword, newPassword });
};

export const resetUserPassword = async (email: string): Promise<void> => {
  await axios.post(`${BASE_URL}/reset-password`, { email });
};

================
File: api/walletApi.ts
================
import apiClient from './axios';
import { Wallet, Discount, LoyaltyReward } from '../types';

// Fetch wallet balance
export const fetchWalletBalance = async (): Promise<{ balance: number }> => {
  const response = await apiClient.get<{ balance: number }>(
    '/api/wallet/balance'
  );
  return response.data;
};

// Fetch wallet discounts
export const fetchWalletDiscounts = async (): Promise<Discount[]> => {
  const response = await apiClient.get<Discount[]>('/api/wallet/discounts');
  return response.data;
};

// Fetch loyalty rewards
export const fetchLoyaltyRewards = async (): Promise<LoyaltyReward[]> => {
  const response = await apiClient.get<LoyaltyReward[]>(
    '/api/wallet/loyalty-rewards'
  );
  return response.data;
};

// Add a discount to the wallet
export const addDiscountToWallet = async (
  discountId: number
): Promise<void> => {
  await apiClient.post('/api/wallet/add-discount', { discountId });
};

// Fetch all wallet data (balance, discounts, rewards)
export const fetchWalletData = async (): Promise<Wallet> => {
  const response = await apiClient.get<Wallet>('/api/wallet');
  return response.data;
};

================
File: api/walletDropApi.ts
================
import apiClient from './axios';
import { WalletDrop } from '../types/walletTypes';

export const getWalletDropsByUser = async (
  userId: number
): Promise<WalletDrop[]> => {
  const response = await apiClient.get(`/api/wallet-drops/user/${userId}`);
  return response.data;
};

export const createWalletDrop = async (
  userId: number,
  type: 'credit' | 'percentage' | 'fixed' | 'item',
  value: number,
  reason: string,
  itemId?: number,
  expirationDate?: Date
): Promise<WalletDrop> => {
  const response = await apiClient.post('/api/wallet-drops', {
    userId,
    type,
    value,
    reason,
    itemId,
    expirationDate,
  });
  return response.data;
};

================
File: components/layout/Footer.tsx
================
import React from 'react';

const Footer: React.FC = () => {
  return (
    <footer className="footer bg-gray-800 text-white py-4 mt-8">
      <div className="container mx-auto text-center">
        <p>
          &copy; {new Date().getFullYear()} Client Brand. All rights reserved.
        </p>
        <ul className="flex justify-center space-x-4 mt-2">
          <li>
            <a href="/terms" className="hover:underline">
              Terms & Conditions
            </a>
          </li>
          <li>
            <a href="/privacy" className="hover:underline">
              Privacy Policy
            </a>
          </li>
          <li>
            <a href="/support" className="hover:underline">
              Support
            </a>
          </li>
        </ul>
      </div>
    </footer>
  );
};

export default Footer;

================
File: components/layout/Navbar.tsx
================
import React, { useMemo } from 'react';
import { Link } from 'react-router-dom';
import { useSelector, useDispatch } from 'react-redux';
import { AppBar, Toolbar, Button, Typography } from '@mui/material';
import { RootState, AppDispatch } from '../../redux/store';
import { logout } from '../../redux/slices/authSlice';

const Navbar: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { isAuthenticated, user } = useSelector(
    (state: RootState) => state.auth
  );

  const handleLogout = () => {
    dispatch(logout());
  };

  const menuItems = useMemo(() => {
    const items = [
      { label: 'Dashboard', path: '/' },
      { label: 'Locations', path: '/admin/locations' },
      { label: 'Loyalty', path: '/admin/loyalty' },
      { label: 'Branding', path: '/admin/branding' },
      { label: 'AB Tests', path: '/admin/ab-tests' },
      { label: 'Reporting', path: '/admin/reporting' },
    ];

    if (user?.role === 'admin') {
      items.push({ label: 'Global Admin', path: '/global-admin' });
    }

    return items;
  }, [user?.role]);

  if (!isAuthenticated) return null;

  return (
    <AppBar position="static">
      <Toolbar>
        <Typography variant="h6" style={{ flexGrow: 1 }}>
          POS Admin
        </Typography>
        {menuItems.map((item) => (
          <Button
            key={item.path}
            color="inherit"
            component={Link}
            to={item.path}
          >
            {item.label}
          </Button>
        ))}
        <Button color="inherit" onClick={handleLogout}>
          Logout
        </Button>
      </Toolbar>
    </AppBar>
  );
};

export default React.memo(Navbar);

================
File: components/tablet/TabletOrderManager.tsx
================
import React, { useEffect, useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { RootState, AppDispatch } from '../../redux/store';
import {
  fetchActiveOrders,
  cancelOrder,
  markItemOutOfStock,
} from '../../redux/slices/orderSlice';
import { Order, OrderItem } from '../../types';
import { View, Text, FlatList, TouchableOpacity, StyleSheet } from 'react-native-web';

const TabletOrderManager: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const activeOrders = useSelector(
    (state: RootState) => state.orders.activeOrders
  );
  const [selectedOrder, setSelectedOrder] = useState<Order | null>(null);

  useEffect(() => {
    dispatch(fetchActiveOrders());
    const interval = setInterval(() => {
      dispatch(fetchActiveOrders());
    }, 30000); // Refresh every 30 seconds

    return () => clearInterval(interval);
  }, [dispatch]);

  const handleCancelOrder = (orderId: string) => {
    dispatch(cancelOrder(orderId));
  };

  const handleMarkItemOutOfStock = (itemId: string) => {
    dispatch(markItemOutOfStock(itemId));
  };

  const renderOrderItem = ({ item }: { item: OrderItem }) => (
    <View style={styles.orderItem}>
      <Text>{item.name}</Text>
      <Text>Quantity: {item.quantity}</Text>
      {item.modifications &&
        item.modifications.map((mod: string, index: number) => (
          <Text key={index} style={styles.modification}>
            {mod}
          </Text>
        ))}
      <TouchableOpacity onPress={() => handleMarkItemOutOfStock(item.id)}>
        <Text style={styles.outOfStockButton}>Mark Out of Stock</Text>
      </TouchableOpacity>
    </View>
  );

  const renderOrder = ({ item }: { item: Order }) => (
    <TouchableOpacity
      onPress={() => setSelectedOrder(item)}
      style={styles.orderCard}
    >
      <Text style={styles.orderNumber}>Order #{item.id}</Text>
      <Text>Promise Time: {item.promiseTime}</Text>
      <Text>Total Items: {item.items.length}</Text>
      <TouchableOpacity onPress={() => handleCancelOrder(item.id)}>
        <Text style={styles.cancelButton}>Cancel Order</Text>
      </TouchableOpacity>
    </TouchableOpacity>
  );

  return (
    <View style={styles.container}>
      <View style={styles.orderList}>
        <Text style={styles.title}>Active Orders</Text>
        <FlatList
          data={activeOrders}
          renderItem={renderOrder}
          keyExtractor={(item) => item.id}
        />
      </View>
      {selectedOrder && (
        <View style={styles.orderDetails}>
          <Text style={styles.title}>Order Details</Text>
          <Text>Order #{selectedOrder.id}</Text>
          <Text>Promise Time: {selectedOrder.promiseTime}</Text>
          <FlatList
            data={selectedOrder.items}
            renderItem={renderOrderItem}
            keyExtractor={(item) => item.id}
          />
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    flexDirection: 'row',
  },
  orderList: {
    flex: 1,
    padding: 10,
  },
  orderDetails: {
    flex: 2,
    padding: 10,
    backgroundColor: '#f0f0f0',
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 10,
  },
  orderCard: {
    backgroundColor: 'white',
    padding: 10,
    marginBottom: 10,
    borderRadius: 5,
  },
  orderNumber: {
    fontWeight: 'bold',
  },
  cancelButton: {
    color: 'red',
    marginTop: 5,
  },
  orderItem: {
    backgroundColor: 'white',
    padding: 10,
    marginBottom: 5,
    borderRadius: 5,
  },
  modification: {
    fontStyle: 'italic',
  },
  outOfStockButton: {
    color: 'orange',
    marginTop: 5,
  },
});

export default TabletOrderManager;

================
File: components/ABTestManager.tsx
================
import React, { useState, useEffect, useCallback } from 'react';
import { Typography, Button, TextField, Select, MenuItem } from '@mui/material';
import { ABTestService } from '../services/ABTestService';
import { ABTest } from '../types/abTestTypes';
import { fetchABTests } from 'frontend/src/api/abTestApi';

const ABTestManager: React.FC = () => {
  const [tests, setTests] = useState<ABTest[]>([]);
  const [newTest, setNewTest] = useState<Partial<ABTest>>({
    name: '',
    description: '',
    status: 'draft',
  });

  const abTestService = React.useMemo(() => new ABTestService(), []);

  const fetchTests = useCallback(async () => {
    try {
      const fetchedTests = await abTestService.getABTests();
      setTests(fetchedTests);
    } catch (error) {
      console.error('Failed to fetch A/B tests:', error);
    }
  }, [abTestService]);

  useEffect(() => {
    fetchTests();
  }, [fetchTests]);

  const handleCreateTest = async () => {
    try {
      await abTestService.createABTest(newTest as ABTest);
      fetchTests();
      setNewTest({ name: '', description: '', status: 'draft' });
    } catch (error) {
      console.error('Failed to create A/B test:', error);
    }
  };

  const handleUpdateTest = async (updatedTest: ABTest) => {
    try {
      await abTestService.updateABTest(updatedTest);
      fetchTests();
    } catch (error) {
      console.error('Failed to update A/B test:', error);
    }
  };

  return (
    <div>
      <Typography variant="h4">A/B Test Manager</Typography>
      <div>
        <TextField
          label="Test Name"
          value={newTest.name}
          onChange={(e) => setNewTest({ ...newTest, name: e.target.value })}
        />
        <TextField
          label="Description"
          value={newTest.description}
          onChange={(e) =>
            setNewTest({ ...newTest, description: e.target.value })
          }
        />
        <Select
          value={newTest.status}
          onChange={(e) =>
            setNewTest({
              ...newTest,
              status: e.target.value as ABTest['status'],
            })
          }
        >
          <MenuItem value="draft">Draft</MenuItem>
          <MenuItem value="active">Active</MenuItem>
          <MenuItem value="completed">Completed</MenuItem>
        </Select>
        <Button onClick={handleCreateTest}>Create Test</Button>
      </div>
      <div>
        {tests.map((test) => (
          <div key={test.id}>
            <Typography>{test.name}</Typography>
            <Typography>{test.description}</Typography>
            <Typography>{test.status}</Typography>
            <Button
              onClick={() => handleUpdateTest({ ...test, status: 'active' })}
            >
              Activate
            </Button>
            <Button
              onClick={() => handleUpdateTest({ ...test, status: 'completed' })}
            >
              Complete
            </Button>
          </div>
        ))}
      </div>
    </div>
  );
};

export default ABTestManager;

================
File: components/AnalyticsOverview.tsx
================
import React from 'react';
import { RevenueData, CustomerMetrics } from '../types/analyticsTypes';

interface Props {
  revenue: RevenueData[];
  customerMetrics: CustomerMetrics;
}

const AnalyticsOverview: React.FC<Props> = ({ revenue, customerMetrics }) => {
  const totalRevenue = revenue.reduce((sum, item) => sum + item.amount, 0);
  const averageRevenue = totalRevenue / revenue.length;

  return (
    <div className="analytics-overview">
      <div className="metric">
        <h4>Total Revenue</h4>
        <p>${totalRevenue.toFixed(2)}</p>
      </div>
      <div className="metric">
        <h4>Average Daily Revenue</h4>
        <p>${averageRevenue.toFixed(2)}</p>
      </div>
      <div className="metric">
        <h4>Total Customers</h4>
        <p>{customerMetrics.totalCustomers}</p>
      </div>
      <div className="metric">
        <h4>New Customers</h4>
        <p>{customerMetrics.newCustomers}</p>
      </div>
    </div>
  );
};

export default AnalyticsOverview;

================
File: components/AuditLogViewer.tsx
================
import React, { useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import { fetchAuditLogsAsync } from '../redux/slices/auditLogSlice';

const AuditLogViewer: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { logs, totalPages, currentPage, status, error } = useSelector(
    (state: RootState) => state.auditLog
  );

  useEffect(() => {
    dispatch(fetchAuditLogsAsync(currentPage));
  }, [dispatch, currentPage]);

  if (status === 'loading') {
    return <div>Loading...</div>;
  }

  if (status === 'failed') {
    return <div>Error: {error}</div>;
  }

  return (
    <div>
      <h3>Audit Logs</h3>
      <table>
        <thead>
          <tr>
            <th>User</th>
            <th>Action</th>
            <th>Details</th>
            <th>Timestamp</th>
          </tr>
        </thead>
        <tbody>
          {logs.map((log) => (
            <tr key={log.id}>
              <td>{log.userId}</td>
              <td>{log.action}</td>
              <td>{log.details}</td>
              <td>{new Date(log.createdAt).toLocaleString()}</td>
            </tr>
          ))}
        </tbody>
      </table>
      <div>
        <button
          onClick={() =>
            dispatch(fetchAuditLogsAsync(Math.max(1, currentPage - 1)))
          }
          disabled={currentPage === 1}
        >
          Previous
        </button>
        <span>
          Page {currentPage} of {totalPages}
        </span>
        <button
          onClick={() =>
            dispatch(fetchAuditLogsAsync(Math.min(totalPages, currentPage + 1)))
          }
          disabled={currentPage === totalPages}
        >
          Next
        </button>
      </div>
    </div>
  );
};

export default AuditLogViewer;

================
File: components/BrandingManagement.css
================
.branding-management {
  padding: 20px;
  background-color: #f9f9f9;
}

.profile-selector {
  margin-bottom: 20px;
}

.color-picker-group {
  margin-bottom: 15px;
}

.color-picker-group label {
  font-weight: bold;
}

.color-picker-group input {
  margin-top: 5px;
  padding: 5px;
  width: 100%;
  border: 1px solid #ccc;
  border-radius: 4px;
}

.logo-upload input {
  margin-top: 10px;
}

.schedule-section {
  margin-top: 20px;
}

.save-profile-btn,
.schedule-profile-btn {
  margin-top: 20px;
  padding: 10px 15px;
  font-size: 16px;
  cursor: pointer;
  border: none;
  border-radius: 5px;
}

.save-profile-btn {
  background-color: #007bff;
  color: white;
}

.schedule-profile-btn {
  background-color: #28a745;
  color: white;
  margin-left: 10px;
}

================
File: components/ChallengeManager.tsx
================
import React, { useState, useEffect } from 'react';
import { Typography, Button, TextField, Select, MenuItem, SelectChangeEvent } from '@mui/material';
import { useDispatch, useSelector } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import {
  fetchChallenges,
  createChallenge,
  updateChallenge,
  Challenge,
  ChallengeType
} from '../redux/slices/challengeSlice';

const ChallengeManager: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const challenges = useSelector((state: RootState) => state.challenge.challenges);
  const [newChallenge, setNewChallenge] = useState<Partial<Challenge>>({
    name: '',
    description: '',
    challengeType: 'purchase' as ChallengeType,
    targetValue: 0,
    reward: 0,
  });

  useEffect(() => {
    dispatch(fetchChallenges());
  }, [dispatch]);

  const handleCreate = () => {
    dispatch(createChallenge(newChallenge as Challenge));
    setNewChallenge({
      name: '',
      description: '',
      challengeType: 'purchase' as ChallengeType,
      targetValue: 0,
      reward: 0,
    });
  };

  const handleUpdate = (updatedChallenge: Challenge) => {
    dispatch(updateChallenge(updatedChallenge));
  };

  const handleInputChange = (event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = event.target;
    setNewChallenge(prev => ({ ...prev, [name]: value }));
  };

  const handleSelectChange = (event: SelectChangeEvent<ChallengeType>) => {
    setNewChallenge(prev => ({ ...prev, challengeType: event.target.value as ChallengeType }));
  };

  return (
    <div>
      <Typography variant="h4">Challenge Manager</Typography>
      <div>
        <TextField
          name="name"
          label="Challenge Name"
          value={newChallenge.name}
          onChange={handleInputChange}
        />
        <TextField
          name="description"
          label="Description"
          value={newChallenge.description}
          onChange={handleInputChange}
        />
        <Select
          value={newChallenge.challengeType}
          onChange={handleSelectChange}
          label="Challenge Type"
        >
          <MenuItem value="purchase">Purchase</MenuItem>
          <MenuItem value="visit">Visit</MenuItem>
          <MenuItem value="referral">Referral</MenuItem>
        </Select>
        <TextField
          name="targetValue"
          label="Target Value"
          type="number"
          value={newChallenge.targetValue}
          onChange={handleInputChange}
        />
        <TextField
          name="reward"
          label="Reward"
          type="number"
          value={newChallenge.reward}
          onChange={handleInputChange}
        />
        <Button onClick={handleCreate}>Create Challenge</Button>
      </div>
      <div>
        {challenges.map((challenge) => (
          <div key={challenge.id}>
            <Typography>{challenge.name}</Typography>
            <Typography>{challenge.description}</Typography>
            <Typography>Type: {challenge.challengeType}</Typography>
            <Typography>Target: {challenge.targetValue}</Typography>
            <Typography>Reward: {challenge.reward}</Typography>
            <Button onClick={() => handleUpdate({ ...challenge, status: 'active' })}>
              Activate
            </Button>
            <Button onClick={() => handleUpdate({ ...challenge, status: 'inactive' })}>
              Deactivate
            </Button>
          </div>
        ))}
      </div>
    </div>
  );
};

export default ChallengeManager;

================
File: components/ClientAdminHub.tsx
================
import React, { useEffect, useState } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import { Typography, Button, Grid } from '@mui/material';
import {
  fetchLocations,
  updateLocationStatus,
} from '../redux/slices/locationSlice';
import LocationCard from './LocationCard';
import { Location } from '../types/locationTypes';
import { LocationService } from '../services/LocationService';

const ClientAdminHub: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const locations = useSelector((state: RootState) => state.location.locations);
  const loading = useSelector((state: RootState) => state.location.loading);
  const error = useSelector((state: RootState) => state.location.error);
  const [selectedLocation, setSelectedLocation] = useState<Location | null>(
    null
  );
  const locationService = new LocationService();

  useEffect(() => {
    dispatch(fetchLocations());
  }, [dispatch]);

  const handleLocationSelect = (location: Location) => {
    setSelectedLocation(location);
  };

  const handleStatusUpdate = async (locationId: string, newStatus: string) => {
    try {
      await locationService.updateLocation(locationId, { status: newStatus });
      dispatch(updateLocationStatus({ locationId, status: newStatus }));
    } catch (error) {
      console.error('Failed to update location status:', error);
    }
  };

  if (loading) return <Typography>Loading...</Typography>;
  if (error) return <Typography color="error">{error}</Typography>;

  return (
    <div>
      <Typography variant="h4">Client Admin Hub</Typography>
      <Grid container spacing={2}>
        {locations.map((location) => (
          <Grid item xs={12} sm={6} md={4} key={location.id}>
            <LocationCard location={location} onSelect={handleLocationSelect} />
            <Button onClick={() => handleStatusUpdate(location.id, 'active')}>
              Activate
            </Button>
            <Button onClick={() => handleStatusUpdate(location.id, 'inactive')}>
              Deactivate
            </Button>
          </Grid>
        ))}
      </Grid>
      {selectedLocation && (
        <div>
          <Typography variant="h5">
            Selected Location: {selectedLocation.name}
          </Typography>
          {/* Add more details or actions for the selected location */}
        </div>
      )}
    </div>
  );
};

export default ClientAdminHub;

================
File: components/ClientBrandingManager.tsx
================
import React, { useState, useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import {
  updateClientBranding,
  fetchClientBranding,
} from '../redux/slices/clientBrandingSlice';
import {
  Button,
  TextField,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  Box,
  Typography,
  SelectChangeEvent,
} from '@mui/material';
import { SketchPicker, ColorResult } from 'react-color';
import { ClientBranding } from '../types/clientTypes';

const ClientBrandingManager: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { branding, status } = useSelector(
    (state: RootState) => state.clientBranding
  );
  const [localBranding, setLocalBranding] = useState<ClientBranding | null>(
    branding
  );

  useEffect(() => {
    dispatch(fetchClientBranding());
  }, [dispatch]);

  useEffect(() => {
    if (branding) {
      setLocalBranding(branding);
    }
  }, [branding]);

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (localBranding) {
      setLocalBranding({ ...localBranding, [e.target.name]: e.target.value });
    }
  };

  const handleColorChange = (
    color: ColorResult,
    colorType: keyof ClientBranding
  ) => {
    if (localBranding) {
      setLocalBranding({ ...localBranding, [colorType]: color.hex });
    }
  };

  const handleSelectChange = (e: SelectChangeEvent<string>) => {
    const { name, value } = e.target;
    if (localBranding) {
      setLocalBranding({ ...localBranding, [name]: value });
    }
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (localBranding) {
      dispatch(updateClientBranding(localBranding));
    }
  };

  if (status === 'loading') return <Typography>Loading...</Typography>;
  if (!localBranding)
    return <Typography>No branding data available</Typography>;

  return (
    <Box component="form" onSubmit={handleSubmit}>
      <Typography variant="h6" gutterBottom>
        Client Branding Manager
      </Typography>
      <TextField
        name="logo"
        label="Logo URL"
        value={localBranding.logo}
        onChange={handleInputChange}
        fullWidth
        margin="normal"
      />
      <TextField
        name="favicon"
        label="Favicon URL"
        value={localBranding.favicon}
        onChange={handleInputChange}
        fullWidth
        margin="normal"
      />
      <FormControl fullWidth margin="normal">
        <InputLabel>Font Family</InputLabel>
        <Select
          name="fontFamily"
          value={localBranding.fontFamily}
          onChange={handleSelectChange}
        >
          <MenuItem value="Arial">Arial</MenuItem>
          <MenuItem value="Helvetica">Helvetica</MenuItem>
          <MenuItem value="Times New Roman">Times New Roman</MenuItem>
        </Select>
      </FormControl>
      <FormControl fullWidth margin="normal">
        <InputLabel>Button Style</InputLabel>
        <Select
          name="buttonStyle"
          value={localBranding.buttonStyle}
          onChange={handleSelectChange}
        >
          <MenuItem value="rounded">Rounded</MenuItem>
          <MenuItem value="square">Square</MenuItem>
        </Select>
      </FormControl>
      <FormControl fullWidth margin="normal">
        <InputLabel>Header Style</InputLabel>
        <Select
          name="headerStyle"
          value={localBranding.headerStyle}
          onChange={handleSelectChange}
        >
          <MenuItem value="centered">Centered</MenuItem>
          <MenuItem value="left-aligned">Left Aligned</MenuItem>
        </Select>
      </FormControl>
      <TextField
        name="footerContent"
        label="Footer Content"
        value={localBranding.footerContent}
        onChange={handleInputChange}
        fullWidth
        margin="normal"
        multiline
        rows={4}
      />
      <Box mt={2}>
        <Typography>Accent Color</Typography>
        <SketchPicker
          color={localBranding.accentColor}
          onChangeComplete={(color) => handleColorChange(color, 'accentColor')}
        />
      </Box>
      <Button type="submit" variant="contained" color="primary" sx={{ mt: 2 }}>
        Save Branding
      </Button>
    </Box>
  );
};

export default ClientBrandingManager;

================
File: components/ClientBrandingProvider.tsx
================
import React, { useEffect, useState, useMemo } from 'react';
import { useSelector } from 'react-redux';
import { RootState } from '../redux/store';
import { ClientBrandingService } from '../services/ClientBrandingService';
import { ClientBranding } from '../types/clientTypes';
import { ThemeProvider, createTheme } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import { fetchClientBranding } from 'frontend/src/api/clientApi';

const ClientBrandingProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const [branding, setBranding] = useState<ClientBranding | null>(null);
  const clientId = useSelector(
    (state: RootState) => state.client.currentClient?.id
  );
  const clientBrandingService = useMemo(() => new ClientBrandingService(), []);

  useEffect(() => {
    const fetchBranding = async () => {
      if (clientId) {
        try {
          const fetchedBranding =
            await clientBrandingService.getClientBranding(clientId);
          setBranding(fetchedBranding);
        } catch (error) {
          console.error('Failed to fetch client branding:', error);
        }
      }
    };

    fetchBranding();
  }, [clientId, clientBrandingService]);

  const theme = useMemo(() => {
    if (!branding) return createTheme();

    return createTheme({
      palette: {
        primary: {
          main: branding.primaryColor,
        },
        secondary: {
          main: branding.secondaryColor,
        },
        text: {
          primary: branding.fontColor,
          secondary: branding.secondaryFontColor,
        },
      },
      typography: {
        fontFamily: branding.fontFamily,
      },
    });
  }, [branding]);

  if (!branding) {
    return null; // Or a loading component
  }

  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <div className="min-h-screen" style={{ backgroundColor: branding.primaryColor }}>
        {children}
      </div>
    </ThemeProvider>
  );
};

export default ClientBrandingProvider;

================
File: components/ClientBuilderWizard.tsx
================
import React, { useState } from 'react';
import { useDispatch } from 'react-redux';
import { createClientAsync } from '../redux/slices/clientSlice';
import {
  TextField,
  Button,
  Stepper,
  Step,
  StepLabel,
  Box,
  Checkbox,
  FormControlLabel,
  Typography,
} from '@mui/material';
import { useFormik } from 'formik';
import * as Yup from 'yup';
import { AppDispatch } from '../redux/store';
import { ClientData } from '../types/clientTypes';

const ClientBuilderWizard: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const [activeStep, setActiveStep] = useState(0);

  const validationSchema = Yup.object({
    name: Yup.string().required('Client name is required'),
    domain: Yup.string().required('Domain is required'),
    primaryColor: Yup.string().required('Primary color is required'),
    secondaryColor: Yup.string().required('Secondary color is required'),
    logo: Yup.string()
      .url('Must be a valid URL')
      .required('Logo URL is required'),
    features: Yup.object({
      loyalty: Yup.boolean(),
      onlineOrdering: Yup.boolean(),
      tableReservations: Yup.boolean(),
    }),
  });

  const formik = useFormik<ClientData>({
    initialValues: {
      name: '',
      domain: '',
      primaryColor: '#000000',
      secondaryColor: '#ffffff',
      logo: '',
      features: {
        loyalty: false,
        onlineOrdering: false,
        tableReservations: false,
      },
    },
    validationSchema,
    onSubmit: (values) => {
      dispatch(createClientAsync(values));
    },
  });

  const steps = ['Basic Info', 'Branding', 'Features', 'Confirmation'];

  const handleNext = () => {
    setActiveStep((prevActiveStep) => prevActiveStep + 1);
  };

  const handleBack = () => {
    setActiveStep((prevActiveStep) => prevActiveStep - 1);
  };

  const renderStepContent = (step: number) => {
    switch (step) {
      case 0:
        return (
          <>
            <TextField
              name="name"
              label="Client Name"
              value={formik.values.name}
              onChange={formik.handleChange}
              error={formik.touched.name && Boolean(formik.errors.name)}
              helperText={formik.touched.name && formik.errors.name}
              fullWidth
              margin="normal"
            />
            <TextField
              name="domain"
              label="Domain"
              value={formik.values.domain}
              onChange={formik.handleChange}
              error={formik.touched.domain && Boolean(formik.errors.domain)}
              helperText={formik.touched.domain && formik.errors.domain}
              fullWidth
              margin="normal"
            />
          </>
        );
      case 1:
        return (
          <>
            <TextField
              name="primaryColor"
              label="Primary Color"
              type="color"
              value={formik.values.primaryColor}
              onChange={formik.handleChange}
              error={formik.touched.primaryColor && Boolean(formik.errors.primaryColor)}
              helperText={formik.touched.primaryColor && formik.errors.primaryColor}
              fullWidth
              margin="normal"
            />
            <TextField
              name="secondaryColor"
              label="Secondary Color"
              type="color"
              value={formik.values.secondaryColor}
              onChange={formik.handleChange}
              error={formik.touched.secondaryColor && Boolean(formik.errors.secondaryColor)}
              helperText={formik.touched.secondaryColor && formik.errors.secondaryColor}
              fullWidth
              margin="normal"
            />
            <TextField
              name="logo"
              label="Logo URL"
              value={formik.values.logo}
              onChange={formik.handleChange}
              error={formik.touched.logo && Boolean(formik.errors.logo)}
              helperText={formik.touched.logo && formik.errors.logo}
              fullWidth
              margin="normal"
            />
          </>
        );
      case 2:
        return (
          <>
            <Typography variant="h6">Activate Features</Typography>
            <FormControlLabel
              control={
                <Checkbox
                  checked={formik.values.features.loyalty}
                  onChange={formik.handleChange}
                  name="features.loyalty"
                />
              }
              label="Loyalty Program"
            />
            <FormControlLabel
              control={
                <Checkbox
                  checked={formik.values.features.onlineOrdering}
                  onChange={formik.handleChange}
                  name="features.onlineOrdering"
                />
              }
              label="Online Ordering"
            />
            <FormControlLabel
              control={
                <Checkbox
                  checked={formik.values.features.tableReservations}
                  onChange={formik.handleChange}
                  name="features.tableReservations"
                />
              }
              label="Table Reservations"
            />
          </>
        );
      case 3:
        return (
          <Box>
            <Typography variant="h6">Confirm Client Details</Typography>
            <Typography>Name: {formik.values.name}</Typography>
            <Typography>Domain: {formik.values.domain}</Typography>
            <Typography>Primary Color: {formik.values.primaryColor}</Typography>
            <Typography>Secondary Color: {formik.values.secondaryColor}</Typography>
            <Typography>Logo: {formik.values.logo}</Typography>
            <Typography>Features:</Typography>
            <Typography>- Loyalty: {formik.values.features.loyalty ? 'Yes' : 'No'}</Typography>
            <Typography>- Online Ordering: {formik.values.features.onlineOrdering ? 'Yes' : 'No'}</Typography>
            <Typography>- Table Reservations: {formik.values.features.tableReservations ? 'Yes' : 'No'}</Typography>
          </Box>
        );
      default:
        return null;
    }
  };

  return (
    <Box sx={{ width: '100%' }}>
      <Stepper activeStep={activeStep}>
        {steps.map((label) => (
          <Step key={label}>
            <StepLabel>{label}</StepLabel>
          </Step>
        ))}
      </Stepper>
      <form onSubmit={formik.handleSubmit}>
        {renderStepContent(activeStep)}
        <Box sx={{ display: 'flex', justifyContent: 'flex-end', mt: 2 }}>
          {activeStep > 0 && (
            <Button onClick={handleBack} sx={{ mr: 1 }}>
              Back
            </Button>
          )}
          {activeStep < steps.length - 1 ? (
            <Button variant="contained" onClick={handleNext}>
              Next
            </Button>
          ) : (
            <Button type="submit" variant="contained" color="primary">
              Create Client
            </Button>
          )}
        </Box>
      </form>
    </Box>
  );
};

export default ClientBuilderWizard;

================
File: components/CorePOSProfileManager.tsx
================
import React, { useEffect, useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import {
  fetchCorePOSProfiles,
  createCorePOSProfile,
  updateCorePOSProfile,
  deleteCorePOSProfile,
  syncPOSProfile,
} from '../redux/slices/corePOSProfileSlice';
import { CorePOSProfile } from '../types/posTypes';
import { AppDispatch, RootState } from '../redux/store';

const CorePOSProfileManager: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const profiles = useSelector((state: RootState) => state.corePOSProfile.profiles);
  const status = useSelector((state: RootState) => state.corePOSProfile.status);
  const error = useSelector((state: RootState) => state.corePOSProfile.error);

  const [selectedProfile, setSelectedProfile] = useState<CorePOSProfile | null>(
    null
  );
  const [isEditing, setIsEditing] = useState(false);

  useEffect(() => {
    if (status === 'idle') {
      dispatch(fetchCorePOSProfiles());
    }
  }, [status, dispatch]);

  const handleCreateProfile = (profile: Omit<CorePOSProfile, 'id'>) => {
    dispatch(createCorePOSProfile(profile));
  };

  const handleUpdateProfile = (
    id: string,
    profile: Partial<CorePOSProfile>
  ) => {
    dispatch(updateCorePOSProfile({ id, profile }));
    setIsEditing(false);
    setSelectedProfile(null);
  };

  const handleDeleteProfile = (id: string) => {
    dispatch(deleteCorePOSProfile(id));
  };

  const handleSyncProfile = (id: string) => {
    dispatch(syncPOSProfile(id));
  };

  if (status === 'loading') {
    return <div>Loading...</div>;
  }

  if (status === 'failed') {
    return <div>Error: {error}</div>;
  }

  return (
    <div>
      <h2>Core POS Profiles</h2>
      <ul>
        {profiles.map((profile) => (
          <li key={profile.id}>
            {profile.name} - {profile.apiEndpoint}
            <button onClick={() => setSelectedProfile(profile)}>Edit</button>
            <button onClick={() => handleDeleteProfile(profile.id)}>
              Delete
            </button>
            <button onClick={() => handleSyncProfile(profile.id)}>Sync</button>
          </li>
        ))}
      </ul>
      {selectedProfile && (
        <div>
          <h3>{isEditing ? 'Edit Profile' : 'Profile Details'}</h3>
          {/* Add form fields for editing/viewing profile details */}
          {isEditing ? (
            <button
              onClick={() =>
                handleUpdateProfile(selectedProfile.id, selectedProfile)
              }
            >
              Save
            </button>
          ) : (
            <button onClick={() => setIsEditing(true)}>Edit</button>
          )}
        </div>
      )}
      <div>
        <h3>Create New Profile</h3>
        {/* Add form for creating new profile */}
        <button
          onClick={() =>
            handleCreateProfile({
              name: 'New Profile',
              apiEndpoint: 'https://api.example.com',
              apiKey: 'your-api-key',
              // Add other necessary fields
            })
          }
        >
          Create Profile
        </button>
      </div>
    </div>
  );
};

export default CorePOSProfileManager;

================
File: components/CustomerMetricsDisplay.tsx
================
import React from 'react';
import { CustomerMetrics } from '../types/analyticsTypes';

interface Props {
  metrics: CustomerMetrics;
}

const CustomerMetricsDisplay: React.FC<Props> = ({ metrics }) => {
  return (
    <div className="customer-metrics-display">
      <div className="metric">
        <h4>Total Customers</h4>
        <p>{metrics.totalCustomers}</p>
      </div>
      <div className="metric">
        <h4>New Customers</h4>
        <p>{metrics.newCustomers}</p>
      </div>
      <div className="metric">
        <h4>Repeat Customers</h4>
        <p>{metrics.repeatCustomers}</p>
      </div>
      <div className="metric">
        <h4>Average Order Value</h4>
        <p>${metrics.averageOrderValue.toFixed(2)}</p>
      </div>
    </div>
  );
};

export default CustomerMetricsDisplay;

================
File: components/DatePickerComponent.tsx
================
import React from 'react';
import { DatePicker } from 'antd';
import { Dayjs } from 'dayjs';

interface DatePickerComponentProps {
  onChange: (
    dates: [Dayjs, Dayjs] | null,
    dateStrings: [string, string]
  ) => void;
}

const DatePickerComponent: React.FC<DatePickerComponentProps> = ({
  onChange,
}) => {
  return (
    <DatePicker.RangePicker
      onChange={(dates, dateStrings) =>
        onChange(dates as [Dayjs, Dayjs] | null, dateStrings)
      }
      format="YYYY-MM-DD HH:mm"
      showTime
    />
  );
};

export default DatePickerComponent;

================
File: components/DetailedInventoryView.tsx
================
import React, { useState } from 'react';
import { InventoryItem } from '../types';

interface Props {
  inventory: InventoryItem[];
}

const DetailedInventoryView: React.FC<Props> = ({ inventory }) => {
  const [filter, setFilter] = useState('');

  const filteredInventory = inventory.filter((item) =>
    item.name.toLowerCase().includes(filter.toLowerCase())
  );

  return (
    <div className="detailed-inventory-view">
      <h3>Detailed Inventory View</h3>
      <input
        type="text"
        placeholder="Filter items..."
        value={filter}
        onChange={(e) => setFilter(e.target.value)}
      />
      <table>
        <thead>
          <tr>
            <th>Name</th>
            <th>Quantity</th>
            <th>Reorder Point</th>
            <th>Status</th>
          </tr>
        </thead>
        <tbody>
          {filteredInventory.map((item) => (
            <tr key={item.id}>
              <td>{item.name}</td>
              <td>{item.quantity}</td>
              <td>{item.reorderPoint}</td>
              <td>{item.quantity <= item.reorderPoint ? 'Low Stock' : 'OK'}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};

export default DetailedInventoryView;

================
File: components/DetailedLocationView.tsx
================
import React from 'react';
import { Location } from '../types/locationTypes';

interface Props {
  locations: Location[];
  onStatusChange: (locationId: number, isOpen: boolean) => void;
}

const DetailedLocationView: React.FC<Props> = ({
  locations,
  onStatusChange,
}) => {
  return (
    <div className="detailed-location-view">
      <h3>Detailed Location View</h3>
      {locations.map((location) => (
        <div key={location.id} className="location-card">
          <h4>{location.name}</h4>
          <p>Address: {location.address}</p>
          <p>Status: {location.isOpen ? 'Open' : 'Closed'}</p>
          <button onClick={() => onStatusChange(location.id, !location.isOpen)}>
            {location.isOpen ? 'Close' : 'Open'}
          </button>
          {location.isUsingNonStandardHours && <p>Using non-standard hours</p>}
          <p>Phone: {location.phoneNumber}</p>
          <p>Email: {location.email}</p>
          <p>City: {location.city}</p>
          <p>State: {location.state}</p>
          <p>Zip Code: {location.zipCode}</p>
          <p>Latitude: {location.latitude}</p>
          <p>Longitude: {location.longitude}</p>
        </div>
      ))}
    </div>
  );
};

export default DetailedLocationView;

================
File: components/DiscountApplier.tsx
================
import React, { useState } from 'react';
import { applyDiscount } from '../api/discountApi';

interface Props {
  cartTotal: number;
  onDiscountApplied: (discountedTotal: number) => void;
}

const DiscountApplier: React.FC<Props> = ({ cartTotal, onDiscountApplied }) => {
  const [code, setCode] = useState('');
  const [error, setError] = useState('');

  const handleApplyDiscount = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');
    try {
      const { discountedTotal, appliedDiscount } = await applyDiscount(
        code,
        cartTotal
      );
      onDiscountApplied(discountedTotal);
      setCode('');
      alert(`Discount applied: ${appliedDiscount.name}`);
    } catch (error) {
      setError('Invalid or expired discount code');
    }
  };

  return (
    <div>
      <form onSubmit={handleApplyDiscount}>
        <input
          type="text"
          value={code}
          onChange={(e) => setCode(e.target.value)}
          placeholder="Enter discount code"
        />
        <button type="submit">Apply Discount</button>
      </form>
      {error && <p style={{ color: 'red' }}>{error}</p>}
    </div>
  );
};

export default DiscountApplier;

================
File: components/DiscountBuilder.tsx
================
import React, { useState, useEffect } from 'react';
import {
  TextField,
  Button,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  Typography,
  Box,
} from '@mui/material';
import { DiscountService } from '../services/DiscountService';
import { useSelector } from 'react-redux';
import { RootState } from '../redux/store';
import { Discount } from '../types/discountTypes';

const DiscountBuilder: React.FC = () => {
  const [name, setName] = useState('');
  const [type, setType] = useState('');
  const [value, setValue] = useState('');
  const [code, setCode] = useState('');
  const [startDate, setStartDate] = useState('');
  const [endDate, setEndDate] = useState('');
  const [minPurchaseAmount, setMinPurchaseAmount] = useState('');
  const [maxUses, setMaxUses] = useState('');

  const locationId = useSelector(
    (state: RootState) => state.location.currentLocation?.id
  );
  const discountService = new DiscountService();

  useEffect(() => {
    console.log('Current location ID:', locationId);
  }, [locationId]);

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    try {
      if (locationId) {
        const newDiscount: Omit<Discount, 'id'> = {
          name,
          type,
          value: parseFloat(value),
          code,
          locationId,
          startDate: new Date(startDate),
          endDate: new Date(endDate),
          minPurchaseAmount: parseFloat(minPurchaseAmount),
          maxUses: parseInt(maxUses, 10),
          isActive: true,
        };
        await discountService.createDiscount(newDiscount);
        console.log('Discount created successfully');
        // Reset form or show success message
      } else {
        console.error('No location selected');
      }
    } catch (error) {
      console.error('Failed to create discount:', error);
    }
  };

  return (
    <Box component="form" onSubmit={handleSubmit} sx={{ maxWidth: 400, margin: 'auto' }}>
      <Typography variant="h4" gutterBottom>
        Create New Discount
      </Typography>
      <TextField
        label="Discount Name"
        value={name}
        onChange={(e) => setName(e.target.value)}
        fullWidth
        margin="normal"
        required
      />
      <FormControl fullWidth margin="normal" required>
        <InputLabel>Discount Type</InputLabel>
        <Select
          value={type}
          onChange={(e) => setType(e.target.value as string)}
        >
          <MenuItem value="percentage">Percentage</MenuItem>
          <MenuItem value="fixed">Fixed Amount</MenuItem>
        </Select>
      </FormControl>
      <TextField
        label="Discount Value"
        value={value}
        onChange={(e) => setValue(e.target.value)}
        fullWidth
        margin="normal"
        type="number"
        required
      />
      <TextField
        label="Discount Code"
        value={code}
        onChange={(e) => setCode(e.target.value)}
        fullWidth
        margin="normal"
        required
      />
      <TextField
        label="Start Date"
        type="date"
        value={startDate}
        onChange={(e) => setStartDate(e.target.value)}
        fullWidth
        margin="normal"
        InputLabelProps={{ shrink: true }}
        required
      />
      <TextField
        label="End Date"
        type="date"
        value={endDate}
        onChange={(e) => setEndDate(e.target.value)}
        fullWidth
        margin="normal"
        InputLabelProps={{ shrink: true }}
        required
      />
      <TextField
        label="Minimum Purchase Amount"
        value={minPurchaseAmount}
        onChange={(e) => setMinPurchaseAmount(e.target.value)}
        fullWidth
        margin="normal"
        type="number"
      />
      <TextField
        label="Maximum Uses"
        value={maxUses}
        onChange={(e) => setMaxUses(e.target.value)}
        fullWidth
        margin="normal"
        type="number"
      />
      <Button type="submit" variant="contained" color="primary" fullWidth sx={{ mt: 2 }}>
        Create Discount
      </Button>
    </Box>
  );
};

export default DiscountBuilder;

================
File: components/DiscountManager.tsx
================
import React, { useState } from 'react';
import { useDispatch } from 'react-redux';
import { addDiscount, updateDiscount } from '../redux/slices/discountSlice';

const DiscountManager: React.FC = () => {
  const [discountName, setDiscountName] = useState('');
  const [discountValue, setDiscountValue] = useState<number>(0);
  const dispatch = useDispatch();

  const handleAddDiscount = () => {
    dispatch(
      addDiscount({
        id: '1',
        name: discountName,
        value: parseFloat(discountValue.toString()),
      })
    );
  };

  const handleUpdateDiscount = () => {
    dispatch(
      updateDiscount({ id: '1', value: parseFloat(discountValue.toString()) })
    );
  };

  return (
    <div>
      <h1>Discount Manager</h1>
      <input
        type="text"
        value={discountName}
        onChange={(e) => setDiscountName(e.target.value)}
        placeholder="Discount Name"
      />
      <input
        type="number"
        value={discountValue}
        onChange={(e) => setDiscountValue(parseFloat(e.target.value))}
        placeholder="Discount Value"
      />
      <button onClick={handleAddDiscount}>Add Discount</button>
      <button onClick={handleUpdateDiscount}>Update Discount</button>
    </div>
  );
};

export default DiscountManager;

================
File: components/DiscountSelector.tsx
================
import React from 'react';

interface Discount {
  id: number;
  name: string;
  vanityName?: string;
}

interface DiscountSelectorProps {
  discounts: Discount[];
  selectedDiscountId: number;
  onSelect: (id: number) => void;
}

const DiscountSelector: React.FC<DiscountSelectorProps> = ({
  discounts,
  selectedDiscountId,
  onSelect,
}) => {
  return (
    <select
      value={selectedDiscountId}
      onChange={(e) => onSelect(Number(e.target.value))}
    >
      {discounts.map((discount) => (
        <option key={discount.id} value={discount.id}>
          {discount.vanityName || discount.name}
        </option>
      ))}
    </select>
  );
};

export default DiscountSelector;

================
File: components/DoordashMarketplaceSettings.tsx
================
import React, { useState, useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import { updateOrderProvider } from '../../redux/slices/orderProviderSlice';
import {
  TextField,
  Button,
  Typography,
  Box,
  Switch,
  FormControlLabel,
} from '@mui/material';

interface DoordashMarketplaceSettingsProps {
  providerId: number;
}

const DoordashMarketplaceSettings: React.FC<
  DoordashMarketplaceSettingsProps
> = ({ providerId }) => {
  const dispatch = useDispatch<AppDispatch>();
  const orderProvider = useSelector((state: RootState) =>
    state.orderProviders.providers.find(
      (provider) => provider.id === providerId
    )
  );

  const [storeId, setStoreId] = useState(orderProvider?.doordashStoreId || '');
  const [merchantId, setMerchantId] = useState(
    orderProvider?.doordashMerchantId || ''
  );
  const [apiKey, setApiKey] = useState(orderProvider?.doordashApiKey || '');
  const [isMenuSyncEnabled, setIsMenuSyncEnabled] = useState(
    orderProvider?.isDoordashMenuSyncEnabled || false
  );
  const [isAutoAcceptEnabled, setIsAutoAcceptEnabled] = useState(
    orderProvider?.isDoordashAutoAcceptEnabled || false
  );
  const [handleScheduledOrders, setHandleScheduledOrders] = useState(
    orderProvider?.handleScheduledOrders || false
  );
  const [scheduledOrderLeadTime, setScheduledOrderLeadTime] = useState(
    orderProvider?.scheduledOrderLeadTime || 30
  );

  useEffect(() => {
    if (orderProvider) {
      setStoreId(orderProvider.doordashStoreId || '');
      setMerchantId(orderProvider.doordashMerchantId || '');
      setApiKey(orderProvider.doordashApiKey || '');
      setIsMenuSyncEnabled(orderProvider.isDoordashMenuSyncEnabled || false);
      setIsAutoAcceptEnabled(
        orderProvider.isDoordashAutoAcceptEnabled || false
      );
      setHandleScheduledOrders(orderProvider.handleScheduledOrders || false);
      setScheduledOrderLeadTime(orderProvider.scheduledOrderLeadTime || 30);
    }
  }, [orderProvider]);

  const handleSave = () => {
    dispatch(
      updateOrderProvider({
        id: providerId,
        doordashStoreId: storeId,
        doordashMerchantId: merchantId,
        doordashApiKey: apiKey,
        isDoordashMenuSyncEnabled: isMenuSyncEnabled,
        isDoordashAutoAcceptEnabled: isAutoAcceptEnabled,
        handleScheduledOrders,
        scheduledOrderLeadTime,
      })
    );
  };

  if (!orderProvider) {
    return <Typography>Order provider not found</Typography>;
  }

  return (
    <Box>
      <Typography variant="h6">Doordash Marketplace Settings</Typography>
      <TextField
        fullWidth
        margin="normal"
        label="Doordash Store ID"
        value={storeId}
        onChange={(e) => setStoreId(e.target.value)}
      />
      <TextField
        fullWidth
        margin="normal"
        label="Doordash Merchant ID"
        value={merchantId}
        onChange={(e) => setMerchantId(e.target.value)}
      />
      <TextField
        fullWidth
        margin="normal"
        label="Doordash API Key"
        type="password"
        value={apiKey}
        onChange={(e) => setApiKey(e.target.value)}
      />
      <FormControlLabel
        control={
          <Switch
            checked={isMenuSyncEnabled}
            onChange={(e) => setIsMenuSyncEnabled(e.target.checked)}
          />
        }
        label="Enable Menu Sync"
      />
      <FormControlLabel
        control={
          <Switch
            checked={isAutoAcceptEnabled}
            onChange={(e) => setIsAutoAcceptEnabled(e.target.checked)}
          />
        }
        label="Enable Auto-Accept Orders"
      />
      <FormControlLabel
        control={
          <Switch
            checked={handleScheduledOrders}
            onChange={(e) => setHandleScheduledOrders(e.target.checked)}
          />
        }
        label="Handle Scheduled Orders"
      />
      <TextField
        fullWidth
        margin="normal"
        label="Scheduled Order Lead Time (minutes)"
        type="number"
        value={scheduledOrderLeadTime}
        onChange={(e) => setScheduledOrderLeadTime(parseInt(e.target.value))}
        disabled={!handleScheduledOrders}
      />
      <Button onClick={handleSave} variant="contained" color="primary">
        Save Doordash Marketplace Settings
      </Button>
    </Box>
  );
};

export default DoordashMarketplaceSettings;

================
File: components/DoordashSSIOSettings.tsx
================
import React, { useState, useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import { updateOrderProvider } from '../../redux/slices/orderProviderSlice';
import { TextField, Button, Typography, Box } from '@mui/material';

interface DoordashSSIOSettingsProps {
  providerId: number;
}

const DoordashSSIOSettings: React.FC<DoordashSSIOSettingsProps> = ({
  providerId,
}) => {
  const dispatch = useDispatch<AppDispatch>();
  const orderProvider = useSelector((state: RootState) =>
    state.orderProviders.providers.find(
      (provider) => provider.id === providerId
    )
  );

  const [storeId, setStoreId] = useState(orderProvider?.doordashStoreId || '');
  const [menuId, setMenuId] = useState(orderProvider?.doordashMenuId || '');
  const [externalReferenceId, setExternalReferenceId] = useState(
    orderProvider?.doordashExternalReferenceId || ''
  );

  useEffect(() => {
    if (orderProvider) {
      setStoreId(orderProvider.doordashStoreId || '');
      setMenuId(orderProvider.doordashMenuId || '');
      setExternalReferenceId(orderProvider.doordashExternalReferenceId || '');
    }
  }, [orderProvider]);

  const handleSave = () => {
    dispatch(
      updateOrderProvider({
        id: providerId,
        doordashStoreId: storeId,
        doordashMenuId: menuId,
        doordashExternalReferenceId: externalReferenceId,
      })
    );
  };

  if (!orderProvider) {
    return <Typography>Order provider not found</Typography>;
  }

  return (
    <Box>
      <Typography variant="h6">Doordash SSIO Settings</Typography>
      <TextField
        fullWidth
        margin="normal"
        label="Doordash Store ID"
        value={storeId}
        onChange={(e) => setStoreId(e.target.value)}
      />
      <TextField
        fullWidth
        margin="normal"
        label="Doordash Menu ID"
        value={menuId}
        onChange={(e) => setMenuId(e.target.value)}
      />
      <TextField
        fullWidth
        margin="normal"
        label="External Reference ID"
        value={externalReferenceId}
        onChange={(e) => setExternalReferenceId(e.target.value)}
      />
      <Button onClick={handleSave} variant="contained" color="primary">
        Save Doordash SSIO Settings
      </Button>
    </Box>
  );
};

export default DoordashSSIOSettings;

================
File: components/DropOffLocationManager.tsx
================
import React, { useState, useEffect, useCallback, useMemo } from 'react';
import {
  Typography,
  Button,
  List,
  ListItem,
  ListItemText,
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
} from '@mui/material';
import { Edit as EditIcon, Delete as DeleteIcon } from '@mui/icons-material';
import { DropOffLocationService } from '../services/DropOffLocationService';
import { DropOffLocation } from '../types/locationTypes';
import { fetchDropOffLocations } from 'frontend/src/api/locationApi';

const DropOffLocationManager: React.FC = () => {
  const [locations, setLocations] = useState<DropOffLocation[]>([]);
  const [openDialog, setOpenDialog] = useState(false);
  const [editingLocation, setEditingLocation] = useState<DropOffLocation | null>(null);
  const [newLocation, setNewLocation] = useState<Partial<DropOffLocation>>({
    name: '',
    address: '',
    latitude: 0,
    longitude: 0,
  });

  const dropOffLocationService = useMemo(
    () => new DropOffLocationService(),
    []
  );

  const fetchLocations = useCallback(async () => {
    try {
      const fetchedLocations =
        await dropOffLocationService.getDropOffLocations();
      setLocations(fetchedLocations);
    } catch (error) {
      console.error('Failed to fetch drop-off locations:', error);
    }
  }, [dropOffLocationService]);

  useEffect(() => {
    fetchLocations();
  }, [fetchLocations]);

  const handleEdit = (location: DropOffLocation) => {
    setEditingLocation(location);
    setNewLocation(location);
    setOpenDialog(true);
  };

  const handleDelete = async (locationId: string) => {
    try {
      await dropOffLocationService.deleteDropOffLocation(locationId);
      fetchLocations();
    } catch (error) {
      console.error('Failed to delete drop-off location:', error);
    }
  };

  const handleDialogClose = () => {
    setOpenDialog(false);
    setEditingLocation(null);
    setNewLocation({
      name: '',
      address: '',
      latitude: 0,
      longitude: 0,
    });
  };

  const handleSave = async () => {
    try {
      if (editingLocation) {
        await dropOffLocationService.updateDropOffLocation(editingLocation.id, newLocation as DropOffLocation);
      } else {
        await dropOffLocationService.createDropOffLocation(newLocation as DropOffLocation);
      }
      fetchLocations();
      handleDialogClose();
    } catch (error) {
      console.error('Failed to save drop-off location:', error);
    }
  };

  return (
    <div>
      <Typography variant="h6">Drop-off Locations</Typography>
      <List>
        {locations.map((location) => (
          <ListItem key={location.id}>
            <ListItemText
              primary={location.name}
              secondary={location.address}
            />
            <IconButton onClick={() => handleEdit(location)}>
              <EditIcon />
            </IconButton>
            <IconButton onClick={() => handleDelete(location.id)}>
              <DeleteIcon />
            </IconButton>
          </ListItem>
        ))}
      </List>
      <Button variant="contained" color="primary" onClick={() => setOpenDialog(true)}>
        Add New Location
      </Button>

      <Dialog open={openDialog} onClose={handleDialogClose}>
        <DialogTitle>{editingLocation ? 'Edit Location' : 'Add New Location'}</DialogTitle>
        <DialogContent>
          <TextField
            autoFocus
            margin="dense"
            label="Name"
            fullWidth
            value={newLocation.name}
            onChange={(e) => setNewLocation({ ...newLocation, name: e.target.value })}
          />
          <TextField
            margin="dense"
            label="Address"
            fullWidth
            value={newLocation.address}
            onChange={(e) => setNewLocation({ ...newLocation, address: e.target.value })}
          />
          <TextField
            margin="dense"
            label="Latitude"
            fullWidth
            type="number"
            value={newLocation.latitude}
            onChange={(e) => setNewLocation({ ...newLocation, latitude: parseFloat(e.target.value) })}
          />
          <TextField
            margin="dense"
            label="Longitude"
            fullWidth
            type="number"
            value={newLocation.longitude}
            onChange={(e) => setNewLocation({ ...newLocation, longitude: parseFloat(e.target.value) })}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={handleDialogClose}>Cancel</Button>
          <Button onClick={handleSave} color="primary">Save</Button>
        </DialogActions>
      </Dialog>
    </div>
  );
};

export default DropOffLocationManager;

================
File: components/ErrorBoundary.tsx
================
import React, { Component, ErrorInfo, ReactNode } from 'react';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
}

export class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
  };

  public static getDerivedStateFromError(_: Error): State {
    return { hasError: true };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Uncaught error:', error, errorInfo);
  }

  public render() {
    if (this.state.hasError) {
      return <h1>Sorry.. there was an error</h1>;
    }

    return this.props.children;
  }
}

================
File: components/errorHandler.ts
================
import { toast } from 'react-toastify';

export const logError = (message: string, error: Error, info?: unknown) => {
  console.error(message, error, info);
  // Here you can add logic to send error reports to your server or a service like Sentry
};

export const handleApiError = (error: unknown) => {
  if (error instanceof Error && 'response' in error && error.response) {
    // The request was made and the server responded with a status code
    toast.error(
      `Error: ${
        (error.response as { data?: { message?: string } })?.data?.message ||
        'An unexpected error occurred'
      }`
    );
    logError('API error', error, error.response);
  } else if (error instanceof Error && 'request' in error && error.request) {
    // The request was made but no response was received
    toast.error('Network error. Please check your connection.');
    logError('Network error', error);
  } else {
    // Something happened in setting up the request that triggered an Error
    toast.error('An unexpected error occurred');
    logError('Unexpected error', error as Error);
  }
};

================
File: components/ExecutiveDashboard.tsx
================
import React, { useEffect, useState } from 'react';
import { Typography, Grid, CircularProgress } from '@mui/material';
import { useSelector, useDispatch } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import { fetchClients } from '../redux/slices/clientSlice';
import {
  dashboardService,
  DashboardData,
} from '../services/dashboardService';
import { useAuth } from '../hooks/useAuth'; // Add this import
import 'jspdf-autotable';

const ExecutiveDashboard: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const [selectedClientId, setSelectedClientId] = useState<string | 'all'>(
    'all'
  );
  const [dashboardData, setDashboardData] = useState<DashboardData | null>(
    null
  );
  const [isLoading, setIsLoading] = useState(true);
  const { user, isGlobalAdmin, authToken } = useAuth(); // Add this line

  useEffect(() => {
    if (isGlobalAdmin) {
      dispatch(fetchClients());
    }
    if (authToken) {
      dashboardService.setAuthToken(authToken);
    }
  }, [dispatch, isGlobalAdmin, authToken]);

  useEffect(() => {
    const fetchDashboardData = async () => {
      setIsLoading(true);
      try {
        const data = await dashboardService.getDashboardData(selectedClientId);
        if (selectedClientId !== 'all') {
          const locationData =
            await dashboardService.getLocationData(selectedClientId);
          data.totalLocations = locationData.totalLocations;
        }
        setDashboardData(data);
      } catch (error) {
        console.error('Error fetching dashboard data:', error);
      } finally {
        setIsLoading(false);
      }
    };

    fetchDashboardData();
  }, [selectedClientId]);

  const handleRefresh = () => {
    fetchDashboardData();
  };

  if (isLoading) {
    return <CircularProgress />;
  }

  if (!dashboardData) {
    return <Typography>Loading...</Typography>;
  }

  return (
    <div role="main" aria-label="Executive Dashboard">
      <h1 tabIndex={0}>Executive Dashboard</h1>
      <Grid container spacing={3}>
        <Grid item xs={12} md={6} lg={4}>
          {/* Dashboard item */}
        </Grid>
        {/* ... more grid items ... */}
      </Grid>
      <button aria-label="Refresh dashboard data" onClick={handleRefresh}>
        Refresh
      </button>
    </div>
  );
};

export default ExecutiveDashboard;

================
File: components/ExportData.tsx
================
import React from 'react';
import { useSelector } from 'react-redux';
import { RootState } from '../redux/store';
import { exportToCSV } from '../utils/exportUtils';
import { Button, Typography, Box } from '@mui/material';
import { InventoryItem, Order, RevenueData } from '../types';

const ExportData: React.FC = () => {
  const inventory = useSelector((state: RootState) => state.inventory.items);
  const orders = useSelector((state: RootState) => state.orders.orders);
  const revenue = useSelector((state: RootState) => state.revenue.data);

  const handleExport = (dataType: 'inventory' | 'orders' | 'revenue') => {
    switch (dataType) {
      case 'inventory':
        exportToCSV(inventory as InventoryItem[], 'inventory_report');
        break;
      case 'orders':
        exportToCSV(orders as Order[], 'orders_report');
        break;
      case 'revenue':
        exportToCSV(revenue as RevenueData[], 'revenue_report');
        break;
    }
  };

  return (
    <Box className="export-data">
      <Typography variant="h3" gutterBottom>Export Data</Typography>
      <Box display="flex" flexDirection="column" gap={2}>
        <Button variant="contained" color="primary" onClick={() => handleExport('inventory')}>
          Export Inventory
        </Button>
        <Button variant="contained" color="primary" onClick={() => handleExport('orders')}>
          Export Orders
        </Button>
        <Button variant="contained" color="primary" onClick={() => handleExport('revenue')}>
          Export Revenue
        </Button>
      </Box>
    </Box>
  );
};

export default ExportData;

================
File: components/Home.tsx
================
import React from 'react';

const Home: React.FC = () => {
  return (
    <div>
      <h1>Welcome to the Home Page</h1>
      {/* Add more content as needed */}
    </div>
  );
};

export default Home;

================
File: components/InventoryAlerts.tsx
================
import React from 'react';
import { InventoryItem } from '../types/inventoryTypes';
import { Typography, List, ListItem, ListItemText, Box } from '@mui/material';

interface Props {
  items: InventoryItem[];
}

const InventoryAlerts: React.FC<Props> = ({ items }) => {
  const outOfStockItems = items.filter(item => item.quantity <= 0);
  const lowStockItems = items.filter(item => item.quantity > 0 && item.quantity <= item.lowStockThreshold);

  return (
    <Box className="inventory-alerts">
      <Typography variant="h4">Inventory Alerts</Typography>
      <Box>
        <Typography variant="h5">Out of Stock Items</Typography>
        {outOfStockItems.length === 0 ? (
          <Typography>No items are currently out of stock.</Typography>
        ) : (
          <List>
            {outOfStockItems.map((item) => (
              <ListItem key={item.id}>
                <ListItemText
                  primary={item.name}
                  secondary={`Out of stock for ${item.outOfStockDuration} hours`}
                />
              </ListItem>
            ))}
          </List>
        )}
      </Box>
      <Box>
        <Typography variant="h5">Low Stock Items</Typography>
        {lowStockItems.length === 0 ? (
          <Typography>No items are currently low in stock.</Typography>
        ) : (
          <List>
            {lowStockItems.map((item) => (
              <ListItem key={item.id}>
                <ListItemText
                  primary={item.name}
                  secondary={`Current quantity: ${item.quantity}, Low stock threshold: ${item.lowStockThreshold}`}
                />
              </ListItem>
            ))}
          </List>
        )}
      </Box>
    </Box>
  );
};

export default InventoryAlerts;

================
File: components/ItemBuilder.css
================
.item-builder {
  position: fixed;
  right: 0;
  top: 0;
  bottom: 0;
  width: 400px;
  background: white;
  box-shadow: -2px 0 5px rgba(0, 0, 0, 0.1);
  z-index: 1000;
  padding: 20px;
  overflow-y: auto;
  transform: translateX(100%);
  transition: transform 0.3s ease-in-out;
}

.item-builder.show {
  transform: translateX(0);
}

.item-builder-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid #ddd;
  margin-bottom: 10px;
}

.item-builder-body {
  padding: 10px 0;
}

.modifier-group label {
  display: block;
  font-weight: bold;
  margin-bottom: 5px;
}

.modifier-group select {
  width: 100%;
  padding: 8px;
  border-radius: 4px;
  border: 1px solid #ccc;
  margin-bottom: 15px;
}

.modifier-group select.required {
  border-color: red;
}

.quantity-selector {
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 15px 0;
}

.quantity-selector button {
  background: #007bff;
  color: white;
  padding: 5px 10px;
  border: none;
  cursor: pointer;
  font-size: 18px;
}

.add-to-cart-btn {
  display: block;
  width: 100%;
  background: #28a745;
  color: white;
  padding: 10px;
  border: none;
  cursor: pointer;
  font-size: 18px;
  border-radius: 5px;
  text-align: center;
}

.add-to-cart-btn:hover {
  background: #218838;
}

================
File: components/ItemReviews.tsx
================
import React from 'react';
import { Typography, Box, Rating } from '@mui/material';

interface Review {
  id: number;
  firstName: string;
  lastInitial: string;
  rating: number;
  comment?: string;
  orderAgainPercentage?: number;
}

interface ItemReviewsProps {
  reviews: Review[];
}

const ItemReviews: React.FC<ItemReviewsProps> = ({ reviews }) => {
  const averageRating =
    reviews.reduce((sum, review) => sum + review.rating, 0) / reviews.length;
  const orderAgainPercentage =
    reviews.reduce(
      (sum, review) => sum + (review.orderAgainPercentage || 0),
      0
    ) / reviews.length;

  return (
    <Box>
      <Typography variant="h6">Customer Reviews</Typography>
      <Box display="flex" alignItems="center">
        <Rating value={averageRating} readOnly precision={0.1} />
        <Typography variant="body2" ml={1}>
          ({averageRating.toFixed(1)})
        </Typography>
      </Box>
      {orderAgainPercentage > 0 && (
        <Typography variant="body2">
          {orderAgainPercentage.toFixed(0)}% of customers would order this again
        </Typography>
      )}
      {reviews.map((review) => (
        <Box key={review.id} mt={2}>
          <Typography variant="subtitle2">
            {review.firstName} {review.lastInitial}.
          </Typography>
          <Rating value={review.rating} readOnly size="small" />
          {review.comment && (
            <Typography variant="body2">{review.comment}</Typography>
          )}
        </Box>
      ))}
    </Box>
  );
};

export default ItemReviews;

================
File: components/Layout.tsx
================
import React, { FC, ReactNode } from 'react';

interface LayoutProps {
  children: ReactNode; // Accept children as a prop
}

const Layout: FC<LayoutProps> = ({ children }) => {
  return <div>{children}</div>; // Render children within the layout
};

export default Layout;

================
File: components/LazyBarChart.tsx
================
import React from 'react';
import { Bar } from 'react-chartjs-2';
import { ChartData } from '../types/dashboardTypes';

interface LazyBarChartProps {
  data: ChartData;
  title: string;
}

const LazyBarChart: React.FC<LazyBarChartProps> = ({ data, title }) => {
  // ... (component implementation)
};

export default LazyBarChart;

================
File: components/LazyLineChart.tsx
================
import React from 'react';

interface LazyLineChartProps {
  data: any; // Replace 'any' with the appropriate type for your chart data
}

const LazyLineChart: React.FC<LazyLineChartProps> = ({ data }) => {
  // Implement your line chart logic here
  return (
    <div>
      {/* Your line chart UI */}
    </div>
  );
};

export default LazyLineChart;

================
File: components/LazyLocationComparisonChart.tsx
================
import React from 'react';
import { Bar } from 'react-chartjs-2';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  BarElement,
  Title,
  Tooltip,
  Legend,
  ChartOptions,
} from 'chart.js';

ChartJS.register(
  CategoryScale,
  LinearScale,
  BarElement,
  Title,
  Tooltip,
  Legend
);

interface LocationComparisonData {
  labels: string[];
  datasets: {
    label: string;
    data: number[];
    backgroundColor: string;
  }[];
}

interface LazyLocationComparisonChartProps {
  data: LocationComparisonData;
}

const LazyLocationComparisonChart: React.FC<LazyLocationComparisonChartProps> = ({ data }) => {
  const options: ChartOptions<'bar'> = {
    responsive: true,
    plugins: {
      legend: {
        position: 'top' as const,
      },
      title: {
        display: true,
        text: 'Location Comparison',
      },
    },
    scales: {
      y: {
        beginAtZero: true,
      },
    },
  };

  return <Bar options={options} data={data} />;
};

export default LazyLocationComparisonChart;

================
File: components/LoadingSpinner.tsx
================
import React from 'react';
import { CircularProgress } from '@mui/material';

const LoadingSpinner: React.FC = () => (
  <div
    style={{
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
      height: '100vh',
    }}
  >
    <CircularProgress />
  </div>
);

export default LoadingSpinner;

================
File: components/LocationBuilder.tsx
================
import React, { useState, useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { updateLocation, fetchLocationProfiles } from '../redux/slices/locationSlice';
import { fetchPosIntegrations } from '../redux/slices/posIntegrationSlice';
import { Location, PosIntegration, LocationProfile } from '../types';
import { AppDispatch, RootState } from '../redux/store';
import { TextField, Button, Select, MenuItem, FormControl, InputLabel } from '@mui/material';
import { SelectChangeEvent } from '@mui/material/Select';
import ProviderList from './ProviderList';

interface ProviderListProps {
  locationId: string | undefined;
  providers: string[];
}

const ProviderList: React.FC<ProviderListProps> = ({ locationId, providers }) => {
  // ... component implementation
};

const LocationBuilder: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const locationProfiles = useSelector((state: RootState) => state.location.locationProfiles);
  const posIntegrations = useSelector((state: RootState) => state.posIntegration.integrations);

  const [location, setLocation] = useState<Omit<Location, 'id'>>({
    name: '',
    address: '',
    gpsCoordinates: '',
    city: '',
    state: '',
    zipCode: '',
    phoneNumber: '',
    email: '',
    latitude: 0,
    longitude: 0,
    posIntegrationId: '',
    customSettings: {},
  });

  useEffect(() => {
    dispatch(fetchLocationProfiles());
    dispatch(fetchPosIntegrations());
  }, [dispatch]);

  const handleSave = () => {
    if (location.name && location.address) {
      dispatch(updateLocation(location as Location));
    }
  };

  const handlePosIntegrationChange = (event: SelectChangeEvent<string>) => {
    setLocation((prev) => ({ ...prev, posIntegrationId: event.target.value }));
  };

  const handleLocationProfileChange = (event: SelectChangeEvent<string>) => {
    const profileId = event.target.value;
    const selectedProfile = locationProfiles.find((profile: LocationProfile) => profile.id === profileId);
    if (selectedProfile) {
      setLocation((prev) => ({ ...prev, ...selectedProfile }));
    }
  };

  return (
    <div>
      <h2>Location Builder</h2>
      <form>
        <FormControl fullWidth margin="normal">
          <InputLabel>Location Profile</InputLabel>
          <Select value={location.posIntegrationId} onChange={handleLocationProfileChange}>
            {locationProfiles.map((profile: LocationProfile) => (
              <MenuItem key={profile.id} value={profile.id}>{profile.name}</MenuItem>
            ))}
          </Select>
        </FormControl>

        <FormControl fullWidth margin="normal">
          <InputLabel>POS Integration</InputLabel>
          <Select value={location.posIntegrationId} onChange={handlePosIntegrationChange}>
            {posIntegrations.map((integration: PosIntegration) => (
              <MenuItem key={integration.id} value={integration.id}>{integration.name}</MenuItem>
            ))}
          </Select>
        </FormControl>

        <TextField
          fullWidth
          margin="normal"
          label="Name"
          value={location.name}
          onChange={(e) => setLocation((prev) => ({ ...prev, name: e.target.value }))}
        />
        <TextField
          fullWidth
          margin="normal"
          label="Address"
          value={location.address}
          onChange={(e) => setLocation((prev) => ({ ...prev, address: e.target.value }))}
        />
        {/* Add other fields similarly */}

        <ProviderList locationId={undefined} providers={[]} />

        <Button variant="contained" color="primary" onClick={handleSave}>
          Save Location
        </Button>
      </form>
    </div>
  );
};

export default LocationBuilder;

================
File: components/LocationCard.tsx
================
import React from 'react';
import { Location } from '../types';

interface LocationCardProps {
  location: Location;
}

const LocationCard: React.FC<LocationCardProps> = ({ location }) => {
  return (
    <div>
      <h2>{location.name}</h2>
      <p>{location.address}</p>
      {/* Add more fields as necessary */}
    </div>
  );
};

export default LocationCard;

================
File: components/LocationExceptions.tsx
================
import React from 'react';
import { useSelector } from 'react-redux';
import { RootState } from '../redux/store';
import { Typography, List, ListItem, ListItemText } from '@mui/material';

interface LocationExceptionsProps {
  locationId: number;
}

const LocationExceptions: React.FC<LocationExceptionsProps> = ({
  locationId,
}) => {
  const menuItems = useSelector((state: RootState) =>
    state.menuItems.items.filter(
      (item) => item.locationId === locationId && item.prepTime > 0
    )
  );

  return (
    <div>
      <Typography variant="h6">Exceptions</Typography>
      <List>
        {menuItems.map((item) => (
          <ListItem key={item.id}>
            <ListItemText
              primary={item.name}
              secondary={`Prep Time: ${item.prepTime} minutes`}
            />
          </ListItem>
        ))}
      </List>
    </div>
  );
};

export default LocationExceptions;

================
File: components/LocationList.tsx
================
import React, { useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import {
  List,
  ListItem,
  ListItemText,
  Typography,
  CircularProgress,
  Box,
  Button,
} from '@mui/material';
import {
  fetchLocations,
  selectLocations,
  selectLocationStatus,
  selectLocationError,
} from '../redux/slices/locationSlice';
import { Location, RootState, AppDispatch } from '../types';
import { Link } from 'react-router-dom';

const LocationList: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const locations = useSelector((state: RootState) => selectLocations(state));
  const status = useSelector((state: RootState) => selectLocationStatus(state));
  const error = useSelector((state: RootState) => selectLocationError(state));

  useEffect(() => {
    if (status === 'idle') {
      dispatch(fetchLocations());
    }
  }, [status, dispatch]);

  if (status === 'loading') {
    return <CircularProgress />;
  }

  if (status === 'failed') {
    return (
      <Typography color="error">Failed to load locations: {error}</Typography>
    );
  }

  return (
    <Box>
      <Typography variant="h2">Locations</Typography>
      <List>
        {locations.map((location: Location) => (
          <ListItem key={location.id}>
            <ListItemText
              primary={location.name}
              secondary={`${location.address}, ${location.city}, ${location.state} ${location.zipCode}`}
            />
            <Button component={Link} to={`/locations/${location.id}`} variant="outlined">
              View Details
            </Button>
          </ListItem>
        ))}
      </List>
      <Button component={Link} to="/locations/new" variant="contained" color="primary">
        Add New Location
      </Button>
    </Box>
  );
};

export default LocationList;

================
File: components/LocationManager.tsx
================
import React, { useEffect, useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import {
  fetchLocations,
  updateLocation,
} from '../redux/slices/locationSlice';
import {
  Box,
  Typography,
  List,
  ListItem,
  ListItemText,
  Button,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Checkbox,
  FormControlLabel,
  FormGroup,
} from '@mui/material';
import { PaymentGateway } from '../types';
import LocationBuilder from './LocationBuilder';

const LocationManager: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const locations = useSelector(
    (state: RootState) => state.locations.locations
  );
  const [selectedLocation, setSelectedLocation] = useState(null);
  const [openDialog, setOpenDialog] = useState(false);

  useEffect(() => {
    dispatch(fetchLocations());
  }, [dispatch]);

  const handleEdit = (location) => {
    setSelectedLocation(location);
    setOpenDialog(true);
  };

  const handleClose = () => {
    setOpenDialog(false);
    setSelectedLocation(null);
  };

  const handleSave = () => {
    dispatch(updateLocation(selectedLocation));
    handleClose();
  };

  const handleExceptionChange = (field: string) => {
    setSelectedLocation({
      ...selectedLocation,
      [field]: !selectedLocation[field],
    });
  };

  const handlePaymentGatewayChange = (gateway: PaymentGateway) => {
    const updatedGateways = selectedLocation.paymentGatewayExceptions.includes(
      gateway
    )
      ? selectedLocation.paymentGatewayExceptions.filter((g) => g !== gateway)
      : [...selectedLocation.paymentGatewayExceptions, gateway];
    setSelectedLocation({
      ...selectedLocation,
      paymentGatewayExceptions: updatedGateways,
    });
  };

  return (
    <Box>
      <Typography variant="h5">Location Manager</Typography>
      <List>
        {locations.map((location) => (
          <ListItem key={location.id}>
            <ListItemText
              primary={location.name}
              secondary={location.address}
            />
            <Button onClick={() => handleEdit(location)}>Edit</Button>
          </ListItem>
        ))}
      </List>
      <LocationBuilder />
      <Dialog open={openDialog} onClose={handleClose}>
        <DialogTitle>Edit Location</DialogTitle>
        <DialogContent>
          {selectedLocation && (
            <>
              <FormGroup>
                <FormControlLabel
                  control={
                    <Checkbox
                      checked={selectedLocation.twoFactorException}
                      onChange={() =>
                        handleExceptionChange('twoFactorException')
                      }
                    />
                  }
                  label="Two-Factor Authentication Exception"
                />
              </FormGroup>
              <Typography variant="h6">Payment Gateway Exceptions</Typography>
              <FormGroup>
                {Object.values(PaymentGateway).map((gateway) => (
                  <FormControlLabel
                    key={gateway}
                    control={
                      <Checkbox
                        checked={selectedLocation.paymentGatewayExceptions.includes(
                          gateway
                        )}
                        onChange={() => handlePaymentGatewayChange(gateway)}
                      />
                    }
                    label={gateway}
                  />
                ))}
              </FormGroup>
            </>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={handleClose}>Cancel</Button>
          <Button onClick={handleSave}>Save</Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default LocationManager;

================
File: components/LocationMap.tsx
================
import React, { useEffect } from 'react';
import { MapContainer, TileLayer, Marker, Popup, useMap } from 'react-leaflet';
import 'leaflet/dist/leaflet.css';
import { Location } from '../types';

interface LocationMapProps {
  locations: Location[];
}

const SetViewOnClick: React.FC<{ center: [number, number]; zoom: number }> = ({
  center,
  zoom,
}) => {
  const map = useMap();
  useEffect(() => {
    map.setView(center, zoom);
  }, [center, zoom, map]);
  return null;
};

const LocationMap: React.FC<LocationMapProps> = ({ locations }) => {
  const defaultPosition: [number, number] = [51.505, -0.09]; // Default to London if no locations

  const mapCenter: [number, number] =
    locations.length > 0
      ? [locations[0].latitude, locations[0].longitude]
      : defaultPosition;

  return (
    <MapContainer style={{ height: '400px', width: '100%' }}>
      <SetViewOnClick center={mapCenter} zoom={13} />
      <TileLayer url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png" />
      {locations.map((location) => (
        <Marker
          key={location.id}
          position={[location.latitude, location.longitude]}
        >
          <Popup>
            <b>{location.name}</b>
            <br />
            {location.address}
          </Popup>
        </Marker>
      ))}
    </MapContainer>
  );
};

export default LocationMap;

================
File: components/LocationSelector.tsx
================
import React from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import { setSelectedLocations } from '../redux/slices/userSlice';
import { FormControl, InputLabel, Select, MenuItem, Checkbox, ListItemText } from '@mui/material';

const LocationSelector: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const locations = useSelector((state: RootState) => state.locations.locations);
  const selectedLocations = useSelector((state: RootState) => state.user.selectedLocations);

  const handleLocationChange = (event: React.ChangeEvent<{ value: unknown }>) => {
    const locationIds = event.target.value as string[];
    dispatch(setSelectedLocations(locationIds));
  };

  return (
    <FormControl fullWidth>
      <InputLabel id="location-select-label">Locations</InputLabel>
      <Select
        labelId="location-select-label"
        id="location-select"
        multiple
        value={selectedLocations}
        onChange={handleLocationChange}
        renderValue={(selected) => (selected as string[]).join(', ')}
      >
        {locations.map((location) => (
          <MenuItem key={location.id} value={location.id}>
            <Checkbox checked={selectedLocations.indexOf(location.id) > -1} />
            <ListItemText primary={location.name} />
          </MenuItem>
        ))}
      </Select>
    </FormControl>
  );
};

export default LocationSelector;

================
File: components/LocationSettings.tsx
================
import React, { useState } from 'react';
import { useDispatch } from 'react-redux';
import { AppDispatch } from '../redux/store';
import { updateLocation } from '../redux/slices/locationSlice';
import { Location } from '../types';

const LocationSettings: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();

  const [selectedLocation, setSelectedLocation] = useState('');
  const [selectedProvider, setSelectedProvider] = useState('');

  const handleUpdateSettings = () => {
    const locationUpdate: Partial<Location> & { id: number } = {
      id: parseInt(selectedLocation),
      // Add any other fields you want to update
    };
    dispatch(updateLocation(locationUpdate));
  };

  return (
    <div>
      <h2>Location Settings</h2>
      <select
        value={selectedLocation}
        onChange={(e) => setSelectedLocation(e.target.value)}
      >
        <option value="">Select Location</option>
        {/* Add location options dynamically */}
      </select>
      <select
        value={selectedProvider}
        onChange={(e) => setSelectedProvider(e.target.value)}
      >
        <option value="">Select Provider</option>
        {/* Add provider options dynamically */}
      </select>
      <button onClick={handleUpdateSettings}>Update Settings</button>
    </div>
  );
};

export default LocationSettings;

================
File: components/Login.tsx
================
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { Typography, Button, Box } from '@mui/material';
import { useClientContext } from '../context/ClientContext';
import { UserRole } from '../types/userTypes';
import LoginForm from './LoginForm';

const Login: React.FC = () => {
  const [error, setError] = useState<string | null>(null);
  const navigate = useNavigate();
  const { client, subdomain } = useClientContext();

  if (!client) {
    return <div>Loading...</div>;
  }

  const handleLoginSuccess = (user: any) => {
    if (user.roles.includes(UserRole.CLIENT_ADMIN)) {
      navigate('/admin/dashboard');
    } else if (user.roles.includes(UserRole.GUEST)) {
      navigate('/guest/dashboard');
    } else {
      navigate('/');
    }
  };

  const handleLoginError = (err: any) => {
    setError('Invalid email or password');
    console.error(err);
  };

  return (
    <Box sx={{ maxWidth: 400, margin: 'auto', mt: 4 }}>
      <Typography variant="h4" component="h1" gutterBottom>
        Login to {client.name}
      </Typography>
      <LoginForm onSuccess={handleLoginSuccess} onError={handleLoginError} />
      {error && (
        <Typography color="error" sx={{ mt: 2 }}>
          {error}
        </Typography>
      )}
      <Box sx={{ mt: 2 }}>
        <Button
          fullWidth
          variant="outlined"
          color="secondary"
          onClick={() => navigate('/register')}
          sx={{ mb: 1 }}
        >
          Register
        </Button>
        <Button
          fullWidth
          variant="text"
          onClick={() => navigate('/forgot-password')}
        >
          Forgot Password?
        </Button>
      </Box>
    </Box>
  );
};

export default Login;

================
File: components/LoginForm.tsx
================
import React, { useEffect, useRef } from 'react';
import { useForm, SubmitHandler } from 'react-hook-form';
import { useDispatch, useSelector } from 'react-redux';
import { useNavigate } from 'react-router-dom';
import { loginUser } from '../redux/slices/authSlice';
import {
  Button,
  TextField,
  Typography,
  Box,
  CircularProgress,
} from '@mui/material';
import { AppDispatch, RootState } from '../redux/store';
import { unwrapResult } from '@reduxjs/toolkit';

export interface LoginFormInputs {
  email: string;
  password: string;
}

interface LoginFormProps {
  onSuccess?: (user: any) => void;
  onError?: (error: any) => void;
}

const LoginForm: React.FC<LoginFormProps> = ({ onSuccess, onError }) => {
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<LoginFormInputs>();
  const dispatch = useDispatch<AppDispatch>();
  const navigate = useNavigate();
  const emailRef = useRef<HTMLInputElement>(null);

  const authStatus = useSelector((state: RootState) => state.auth.status);
  const isLoading = authStatus === 'loading';

  const onSubmit: SubmitHandler<LoginFormInputs> = async (data) => {
    try {
      const actionResult = await dispatch(loginUser(data));
      const user = unwrapResult(actionResult);
      if (onSuccess) {
        onSuccess(user);
      } else {
        if (user.role === 'admin') {
          navigate('/admin/dashboard');
        } else {
          navigate('/');
        }
      }
    } catch (error) {
      console.error('Login failed', error);
      if (onError) {
        onError(error);
      } else {
        alert('Login failed. Please try again.');
      }
    }
  };

  useEffect(() => {
    if (emailRef.current) {
      emailRef.current.focus();
    }
  }, []);

  return (
    <Box component="form" onSubmit={handleSubmit(onSubmit)} noValidate sx={{ mt: 1 }}>
      <TextField
        margin="normal"
        required
        fullWidth
        label="Email Address"
        autoComplete="email"
        inputRef={emailRef}
        {...register('email', { required: 'Email is required' })}
        error={!!errors.email}
        helperText={errors.email ? errors.email.message : ''}
        disabled={isLoading}
      />
      <TextField
        margin="normal"
        required
        fullWidth
        label="Password"
        type="password"
        autoComplete="current-password"
        {...register('password', { required: 'Password is required' })}
        error={!!errors.password}
        helperText={errors.password ? errors.password.message : ''}
        disabled={isLoading}
      />
      <Button
        type="submit"
        fullWidth
        variant="contained"
        color="primary"
        sx={{ mt: 3, mb: 2 }}
        disabled={isLoading}
      >
        {isLoading ? <CircularProgress size={24} /> : 'Sign In'}
      </Button>
    </Box>
  );
};

export default LoginForm;

================
File: components/LoginModal.tsx
================
import React from 'react';
import { Dialog, DialogTitle, DialogContent } from '@mui/material';
import LoginForm, { LoginFormInputs } from './LoginForm';

interface LoginModalProps {
  isOpen: boolean;
  onClose: () => void;
  onLogin: (data: LoginFormInputs) => void;
}

const LoginModal: React.FC<LoginModalProps> = ({ isOpen, onClose, onLogin }) => {
  return (
    <Dialog open={isOpen} onClose={onClose}>
      <DialogTitle>Login</DialogTitle>
      <DialogContent>
        <LoginForm onSuccess={onLogin} onError={() => {}} />
      </DialogContent>
    </Dialog>
  );
};

export default LoginModal;

================
File: components/LoyaltyChallengeManager.tsx
================
import React, { useState, useEffect } from 'react';
import {
  fetchLoyaltyChallenges,
  createLoyaltyChallenge,
  updateLoyaltyChallenge,
  deleteLoyaltyChallenge,
} from '../api/loyaltyChallengeApi';
import { LoyaltyChallenge, MenuItem, MenuGroup } from '../types';
import { getMenuItems, getMenuGroups } from '../api/menuApi';
import {
  Typography,
  Button,
  TextField,
  Select,
  MenuItem as MuiMenuItem,
  FormControl,
  InputLabel,
  Box,
  Grid,
  Paper,
} from '@mui/material';

const LoyaltyChallengeManager: React.FC = () => {
  const [challenges, setChallenges] = useState<LoyaltyChallenge[]>([]);
  const [menuItems, setMenuItems] = useState<MenuItem[]>([]);
  const [menuGroups, setMenuGroups] = useState<MenuGroup[]>([]);
  const [newChallenge, setNewChallenge] = useState<Omit<LoyaltyChallenge, 'id'>>({
    name: '',
    description: '',
    conditions: {
      itemCount: 0,
      timeframe: '',
      minSpend: 0,
      frequency: 'unlimited',
      restrictedMenuItems: [],
      restrictedMenuGroups: [],
    },
    rewardConfig: {
      reward: '',
      points: 0,
      discount: 0,
    },
    challengeType: 'purchase-based',
    startDate: new Date(),
    endDate: new Date(),
    status: 'active',
    participantCount: 0,
    locationId: 0,
    clientId: 0,
  });

  useEffect(() => {
    fetchChallenges();
    fetchMenuItems();
    fetchMenuGroups();
  }, []);

  const fetchChallenges = async () => {
    try {
      const fetchedChallenges = await fetchLoyaltyChallenges();
      setChallenges(fetchedChallenges);
    } catch (error) {
      console.error('Error fetching loyalty challenges:', error);
    }
  };

  const fetchMenuItems = async () => {
    try {
      const items = await getMenuItems();
      setMenuItems(items);
    } catch (error) {
      console.error('Error fetching menu items:', error);
    }
  };

  const fetchMenuGroups = async () => {
    try {
      const groups = await getMenuGroups();
      setMenuGroups(groups);
    } catch (error) {
      console.error('Error fetching menu groups:', error);
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await createLoyaltyChallenge(newChallenge);
      setNewChallenge({
        name: '',
        description: '',
        conditions: {
          itemCount: 0,
          timeframe: '',
          minSpend: 0,
          frequency: 'unlimited',
          restrictedMenuItems: [],
          restrictedMenuGroups: [],
        },
        rewardConfig: {
          reward: '',
          points: 0,
          discount: 0,
        },
        challengeType: 'purchase-based',
        startDate: new Date(),
        endDate: new Date(),
        status: 'active',
        participantCount: 0,
        locationId: 0,
        clientId: 0,
      });
      fetchChallenges();
    } catch (error) {
      console.error('Error creating loyalty challenge:', error);
    }
  };

  const handleUpdate = async (
    id: number,
    updatedChallenge: Partial<LoyaltyChallenge>
  ) => {
    try {
      await updateLoyaltyChallenge(id, updatedChallenge);
      fetchChallenges();
    } catch (error) {
      console.error('Error updating loyalty challenge:', error);
    }
  };

  const handleDelete = async (id: number) => {
    try {
      await deleteLoyaltyChallenge(id);
      fetchChallenges();
    } catch (error) {
      console.error('Error deleting loyalty challenge:', error);
    }
  };

  return (
    <Box>
      <Typography variant="h2">Loyalty Challenge Manager</Typography>
      <Paper component="form" onSubmit={handleSubmit} sx={{ p: 2, mt: 2 }}>
        <Grid container spacing={2}>
          <Grid item xs={12} sm={6}>
            <TextField
              fullWidth
              label="Challenge Name"
              value={newChallenge.name}
              onChange={(e) =>
                setNewChallenge({ ...newChallenge, name: e.target.value })
              }
              required
            />
          </Grid>
          <Grid item xs={12} sm={6}>
            <TextField
              fullWidth
              label="Description"
              value={newChallenge.description}
              onChange={(e) =>
                setNewChallenge({ ...newChallenge, description: e.target.value })
              }
              required
            />
          </Grid>
          <Grid item xs={12} sm={6}>
            <FormControl fullWidth>
              <InputLabel>Challenge Type</InputLabel>
              <Select
                value={newChallenge.challengeType}
                onChange={(e) =>
                  setNewChallenge({ ...newChallenge, challengeType: e.target.value as 'purchase-based' | 'engagement-based' })
                }
                required
              >
                <MuiMenuItem value="purchase-based">Purchase-based</MuiMenuItem>
                <MuiMenuItem value="engagement-based">Engagement-based</MuiMenuItem>
              </Select>
            </FormControl>
          </Grid>
          {/* Add more form fields for other properties */}
          <Grid item xs={12}>
            <Button type="submit" variant="contained" color="primary">
              Create Loyalty Challenge
            </Button>
          </Grid>
        </Grid>
      </Paper>
      <Box mt={4}>
        <Typography variant="h3">Existing Challenges</Typography>
        {challenges.map((challenge) => (
          <Paper key={challenge.id} sx={{ p: 2, mt: 2 }}>
            <Typography variant="h4">{challenge.name}</Typography>
            <Typography>Type: {challenge.challengeType}</Typography>
            <Typography>Status: {challenge.status}</Typography>
            <Typography>
              Conditions: Item Count: {challenge.conditions.itemCount},
              Timeframe: {challenge.conditions.timeframe}, Min Spend: $
              {challenge.conditions.minSpend}, Frequency:{' '}
              {challenge.conditions.frequency.replace(/_/g, ' ')}
            </Typography>
            <Typography>Reward: {JSON.stringify(challenge.rewardConfig)}</Typography>
            <Typography>Start Date: {challenge.startDate.toLocaleDateString()}</Typography>
            <Typography>End Date: {challenge.endDate.toLocaleDateString()}</Typography>
            <Typography>Participants: {challenge.participantCount}</Typography>
            <Typography>
              Restricted Menu Items:{' '}
              {challenge.conditions.restrictedMenuItems?.join(', ') || 'None'}
            </Typography>
            <Typography>
              Restricted Menu Groups:{' '}
              {challenge.conditions.restrictedMenuGroups?.join(', ') || 'None'}
            </Typography>
            <Button onClick={() => handleDelete(challenge.id)} color="secondary">
              Delete
            </Button>
            <Button
              onClick={() =>
                handleUpdate(challenge.id, {
                  status: challenge.status === 'active' ? 'inactive' : 'active',
                })
              }
              color="primary"
            >
              {challenge.status === 'active' ? 'Deactivate' : 'Activate'}
            </Button>
          </Paper>
        ))}
      </Box>
    </Box>
  );
};

export default LoyaltyChallengeManager;

================
File: components/LoyaltyChallengeProgress.tsx
================
import React from 'react';
import { Typography, LinearProgress, Box } from '@mui/material';
import { LoyaltyChallenge } from '../types/loyaltyTypes';

interface LoyaltyChallengeProgressProps {
  challenge: LoyaltyChallenge;
  currentProgress: number;
}

const LoyaltyChallengeProgress: React.FC<LoyaltyChallengeProgressProps> = ({
  challenge,
  currentProgress,
}) => {
  const progressPercentage = (currentProgress / challenge.targetValue) * 100;

  return (
    <Box>
      <Typography variant="h6">{challenge.name}</Typography>
      <Typography variant="body2">{challenge.description}</Typography>
      <Box display="flex" alignItems="center">
        <Box width="100%" mr={1}>
          <LinearProgress variant="determinate" value={progressPercentage} />
        </Box>
        <Box minWidth={35}>
          <Typography variant="body2" color="textSecondary">
            {`${Math.round(progressPercentage)}%`}
          </Typography>
        </Box>
      </Box>
      <Typography variant="body2">
        Progress: {currentProgress} / {challenge.targetValue} {challenge.unit}
      </Typography>
    </Box>
  );
};

export default LoyaltyChallengeProgress;

================
File: components/LoyaltyRewards.tsx
================
import React, { useEffect, useState } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import {
  fetchLoyaltyRewards,
  createLoyaltyReward,
  updateLoyaltyReward,
  deleteLoyaltyReward,
} from '../redux/slices/loyaltySlice';
import { LoyaltyReward } from '../types';
import {
  TextField,
  Button,
  List,
  ListItem,
  IconButton,
  Typography,
  Box,
  Paper,
  Grid,
  CircularProgress,
} from '@mui/material';
import DeleteIcon from '@mui/icons-material/Delete';
import EditIcon from '@mui/icons-material/Edit';

const LoyaltyRewards: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { rewards, status, error } = useSelector(
    (state: RootState) => state.loyalty
  );
  const [newReward, setNewReward] = useState<Partial<LoyaltyReward>>({
    name: '',
    pointsRequired: 0,
    isActive: true,
  });
  const [editingReward, setEditingReward] = useState<LoyaltyReward | null>(null);

  useEffect(() => {
    dispatch(fetchLoyaltyRewards());
  }, [dispatch]);

  const handleCreateReward = () => {
    if (newReward.name && newReward.pointsRequired) {
      dispatch(createLoyaltyReward(newReward as LoyaltyReward));
      setNewReward({ name: '', pointsRequired: 0, isActive: true });
    }
  };

  const handleUpdateReward = (reward: LoyaltyReward) => {
    dispatch(updateLoyaltyReward(reward));
    setEditingReward(null);
  };

  const handleDeleteReward = (id: number) => {
    if (window.confirm('Are you sure you want to delete this reward?')) {
      dispatch(deleteLoyaltyReward(id));
    }
  };

  if (status === 'loading') return <CircularProgress />;
  if (status === 'failed') return <Typography color="error">Error: {error}</Typography>;

  return (
    <Box>
      <Typography variant="h2" gutterBottom>
        Loyalty Rewards
      </Typography>
      <Paper elevation={3} sx={{ p: 2, mb: 2 }}>
        <Grid container spacing={2} alignItems="center">
          <Grid item xs={12} sm={4}>
            <TextField
              fullWidth
              label="Reward Name"
              value={newReward.name}
              onChange={(e) => setNewReward({ ...newReward, name: e.target.value })}
            />
          </Grid>
          <Grid item xs={12} sm={4}>
            <TextField
              fullWidth
              label="Points Required"
              type="number"
              value={newReward.pointsRequired}
              onChange={(e) =>
                setNewReward({
                  ...newReward,
                  pointsRequired: parseInt(e.target.value, 10),
                })
              }
            />
          </Grid>
          <Grid item xs={12} sm={4}>
            <Button fullWidth variant="contained" color="primary" onClick={handleCreateReward}>
              Add Reward
            </Button>
          </Grid>
        </Grid>
      </Paper>

      <List>
        {rewards.map((reward) => (
          <ListItem key={reward.id} component={Paper} elevation={2} sx={{ mb: 1, p: 2 }}>
            {editingReward?.id === reward.id ? (
              <Grid container spacing={2} alignItems="center">
                <Grid item xs={12} sm={4}>
                  <TextField
                    fullWidth
                    value={editingReward.name}
                    onChange={(e) =>
                      setEditingReward({ ...editingReward, name: e.target.value })
                    }
                  />
                </Grid>
                <Grid item xs={12} sm={4}>
                  <TextField
                    fullWidth
                    type="number"
                    value={editingReward.pointsRequired}
                    onChange={(e) =>
                      setEditingReward({
                        ...editingReward,
                        pointsRequired: parseInt(e.target.value, 10),
                      })
                    }
                  />
                </Grid>
                <Grid item xs={12} sm={4}>
                  <Button onClick={() => handleUpdateReward(editingReward)}>
                    Save
                  </Button>
                  <Button onClick={() => setEditingReward(null)}>
                    Cancel
                  </Button>
                </Grid>
              </Grid>
            ) : (
              <Grid container spacing={2} alignItems="center">
                <Grid item xs={12} sm={4}>
                  <Typography variant="body1">{reward.name}</Typography>
                </Grid>
                <Grid item xs={12} sm={4}>
                  <Typography variant="body2">{reward.pointsRequired} points</Typography>
                </Grid>
                <Grid item xs={12} sm={4}>
                  <Button
                    onClick={() =>
                      handleUpdateReward({ ...reward, isActive: !reward.isActive })
                    }
                  >
                    {reward.isActive ? 'Deactivate' : 'Activate'}
                  </Button>
                  <IconButton onClick={() => setEditingReward(reward)}>
                    <EditIcon />
                  </IconButton>
                  <IconButton onClick={() => handleDeleteReward(reward.id)}>
                    <DeleteIcon />
                  </IconButton>
                </Grid>
              </Grid>
            )}
          </ListItem>
        ))}
      </List>
    </Box>
  );
};

export default LoyaltyRewards;

================
File: components/LoyaltyRewardSelector.tsx
================
import React, { useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { useParams } from 'react-router-dom';
import {
  fetchLoyaltyConfig,
  fetchLoyaltyRewards,
  selectLoyaltyRewards,
  selectLoyaltyStatus,
} from '../redux/slices/loyaltySlice';
import { AppDispatch, RootState } from '../types';
import { Typography, List, ListItem, ListItemText, CircularProgress } from '@mui/material';
import { fetchLoyaltyRewards } from 'frontend/src/api/loyaltyApi';

const LoyaltyRewardSelector: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { clientId } = useParams<{ clientId: string }>();

  const loyaltyRewards = useSelector((state: RootState) =>
    selectLoyaltyRewards(state)
  );
  const status = useSelector((state: RootState) => selectLoyaltyStatus(state));

  useEffect(() => {
    if (status === 'idle' && clientId) {
      dispatch(fetchLoyaltyConfig(Number(clientId)));
      dispatch(fetchLoyaltyRewards(Number(clientId)));
    }
  }, [status, clientId, dispatch]);

  if (status === 'loading') {
    return <CircularProgress />;
  }

  if (status === 'failed') {
    return <Typography color="error">Failed to load loyalty rewards. Please try again later.</Typography>;
  }

  return (
    <div>
      <Typography variant="h2">Select Loyalty Reward</Typography>
      <List>
        {loyaltyRewards.map((reward) => (
          <ListItem key={reward.id}>
            <ListItemText 
              primary={reward.name} 
              secondary={`${reward.pointsRequired} points`} 
            />
          </ListItem>
        ))}
      </List>
    </div>
  );
};

export default LoyaltyRewardSelector;

================
File: components/LoyaltyTiers.tsx
================
import React, { useEffect, useState } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import {
  fetchLoyaltyConfig,
  updateLoyaltyConfig,
} from '../redux/slices/loyaltySlice';
import { LoyaltyConfig, LoyaltyTier } from '../types';
import {
  TextField,
  Button,
  List,
  ListItem,
  IconButton,
  Typography,
  Box,
  Paper,
  CircularProgress,
} from '@mui/material';
import DeleteIcon from '@mui/icons-material/Delete';
import AddIcon from '@mui/icons-material/Add';
import { fetchLoyaltyTiers } from 'frontend/src/api/loyaltyApi';

const LoyaltyTiers: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { config, status, error } = useSelector(
    (state: RootState) => state.loyalty
  );
  const [editingConfig, setEditingConfig] = useState<LoyaltyConfig | null>(
    null
  );

  useEffect(() => {
    dispatch(fetchLoyaltyConfig());
  }, [dispatch]);

  useEffect(() => {
    if (config) {
      setEditingConfig(config);
    }
  }, [config]);

  const handleUpdateConfig = () => {
    if (editingConfig) {
      dispatch(updateLoyaltyConfig(editingConfig));
    }
  };

  const handleAddTier = () => {
    if (editingConfig) {
      const newTier: LoyaltyTier = { 
        tierName: '',
        pointThreshold: 0,
        benefits: [],
      };
      setEditingConfig({
        ...editingConfig,
        tiers: [...editingConfig.tiers, newTier],
      });
    }
  };

  const handleRemoveTier = (index: number) => {
    if (editingConfig) {
      const newTiers = editingConfig.tiers.filter((_, i) => i !== index);
      setEditingConfig({ ...editingConfig, tiers: newTiers });
    }
  };

  const handleTierChange = (index: number, field: keyof LoyaltyTier, value: string | number) => {
    if (editingConfig) {
      const newTiers = [...editingConfig.tiers];
      newTiers[index] = { ...newTiers[index], [field]: value };
      setEditingConfig({ ...editingConfig, tiers: newTiers });
    }
  };

  if (status === 'loading') return <CircularProgress />;
  if (status === 'failed') return <Typography color="error">Error: {error}</Typography>;

  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Loyalty Tiers
      </Typography>
      {editingConfig && (
        <Paper elevation={3} sx={{ p: 2 }}>
          <List>
            {editingConfig.tiers.map((tier, index) => (
              <ListItem key={index} sx={{ mb: 2 }}>
                <TextField
                  label="Tier Name"
                  value={tier.tierName}
                  onChange={(e) => handleTierChange(index, 'tierName', e.target.value)}
                  sx={{ mr: 2 }}
                />
                <TextField
                  label="Point Threshold"
                  type="number"
                  value={tier.pointThreshold}
                  onChange={(e) => handleTierChange(index, 'pointThreshold', parseInt(e.target.value))}
                  sx={{ mr: 2 }}
                />
                <IconButton onClick={() => handleRemoveTier(index)}>
                  <DeleteIcon />
                </IconButton>
              </ListItem>
            ))}
          </List>
          <Button startIcon={<AddIcon />} onClick={handleAddTier} sx={{ mt: 2 }}>
            Add Tier
          </Button>
          <Button variant="contained" color="primary" onClick={handleUpdateConfig} sx={{ mt: 2, ml: 2 }}>
            Save Configuration
          </Button>
        </Paper>
      )}
    </Box>
  );
};

export default LoyaltyTiers;

================
File: components/MarketingCampaigns.tsx
================
import React, { useState, useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { AppDispatch, RootState } from '../redux/store';
import {
  fetchCampaigns,
  createCampaign,
  updateCampaign,
  deleteCampaign,
} from '../redux/slices/marketingSlice';
import {
  Box,
  Typography,
  Button,
  List,
  ListItem,
  TextField,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  IconButton,
} from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';

const MarketingCampaigns: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const campaigns = useSelector((state: RootState) => state.marketing.campaigns);
  const [open, setOpen] = useState(false);
  const [editingCampaign, setEditingCampaign] = useState<any>(null);

  useEffect(() => {
    dispatch(fetchCampaigns());
  }, [dispatch]);

  const handleOpen = (campaign: any = null) => {
    setEditingCampaign(campaign);
    setOpen(true);
  };

  const handleClose = () => {
    setEditingCampaign(null);
    setOpen(false);
  };

  const handleSave = (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    const formData = new FormData(event.currentTarget);
    const campaignData = {
      name: formData.get('name') as string,
      description: formData.get('description') as string,
      startDate: formData.get('startDate') as string,
      endDate: formData.get('endDate') as string,
    };

    if (editingCampaign) {
      dispatch(updateCampaign({ id: editingCampaign.id, ...campaignData }));
    } else {
      dispatch(createCampaign(campaignData));
    }
    handleClose();
  };

  const handleDelete = (id: string) => {
    if (window.confirm('Are you sure you want to delete this campaign?')) {
      dispatch(deleteCampaign(id));
    }
  };

  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Marketing Campaigns
      </Typography>
      <Button startIcon={<AddIcon />} onClick={() => handleOpen()} sx={{ mb: 2 }}>
        Create Campaign
      </Button>
      <List>
        {campaigns.map((campaign) => (
          <ListItem key={campaign.id} sx={{ border: '1px solid #ddd', mb: 1, borderRadius: 1 }}>
            <Box sx={{ flexGrow: 1 }}>
              <Typography variant="h6">{campaign.name}</Typography>
              <Typography variant="body2">{campaign.description}</Typography>
              <Typography variant="caption">
                {new Date(campaign.startDate).toLocaleDateString()} - {new Date(campaign.endDate).toLocaleDateString()}
              </Typography>
            </Box>
            <IconButton onClick={() => handleOpen(campaign)}>
              <EditIcon />
            </IconButton>
            <IconButton onClick={() => handleDelete(campaign.id)}>
              <DeleteIcon />
            </IconButton>
          </ListItem>
        ))}
      </List>
      <Dialog open={open} onClose={handleClose}>
        <form onSubmit={handleSave}>
          <DialogTitle>{editingCampaign ? 'Edit Campaign' : 'Create Campaign'}</DialogTitle>
          <DialogContent>
            <TextField
              autoFocus
              margin="dense"
              name="name"
              label="Campaign Name"
              fullWidth
              defaultValue={editingCampaign?.name || ''}
            />
            <TextField
              margin="dense"
              name="description"
              label="Description"
              fullWidth
              multiline
              rows={4}
              defaultValue={editingCampaign?.description || ''}
            />
            <TextField
              margin="dense"
              name="startDate"
              label="Start Date"
              type="date"
              fullWidth
              InputLabelProps={{ shrink: true }}
              defaultValue={editingCampaign?.startDate || ''}
            />
            <TextField
              margin="dense"
              name="endDate"
              label="End Date"
              type="date"
              fullWidth
              InputLabelProps={{ shrink: true }}
              defaultValue={editingCampaign?.endDate || ''}
            />
          </DialogContent>
          <DialogActions>
            <Button onClick={handleClose}>Cancel</Button>
            <Button type="submit">{editingCampaign ? 'Update' : 'Create'}</Button>
          </DialogActions>
        </form>
      </Dialog>
    </Box>
  );
};

export default MarketingCampaigns;

================
File: components/MarketingDashboard.tsx
================
import React, { useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import { fetchMarketingMetricsAsync } from '../redux/slices/marketingSlice';
import ABTestManager from './ABTestManager';
import MarketingCampaigns from './MarketingCampaigns';
import {
  Typography,
  Grid,
  Paper,
  Box,
  CircularProgress,
} from '@mui/material';

const MarketingDashboard: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { metrics, status, error } = useSelector(
    (state: RootState) => state.marketing
  );

  useEffect(() => {
    dispatch(fetchMarketingMetricsAsync());
  }, [dispatch]);

  if (status === 'loading') return <CircularProgress />;
  if (status === 'failed') return <Typography color="error">Error: {error}</Typography>;

  return (
    <Box className="marketing-dashboard">
      <Typography variant="h4" gutterBottom>Marketing Dashboard</Typography>
      <Grid container spacing={3}>
        <Grid item xs={12} md={6} lg={3}>
          <Paper elevation={3} sx={{ p: 2 }}>
            <Typography variant="h6">Customer Acquisition Cost</Typography>
            <Typography variant="h4">${metrics.customerAcquisitionCost.toFixed(2)}</Typography>
          </Paper>
        </Grid>
        <Grid item xs={12} md={6} lg={3}>
          <Paper elevation={3} sx={{ p: 2 }}>
            <Typography variant="h6">Customer Lifetime Value</Typography>
            <Typography variant="h4">${metrics.customerLifetimeValue.toFixed(2)}</Typography>
          </Paper>
        </Grid>
        <Grid item xs={12} md={6} lg={3}>
          <Paper elevation={3} sx={{ p: 2 }}>
            <Typography variant="h6">Conversion Rate</Typography>
            <Typography variant="h4">{(metrics.conversionRate * 100).toFixed(2)}%</Typography>
          </Paper>
        </Grid>
        <Grid item xs={12} md={6} lg={3}>
          <Paper elevation={3} sx={{ p: 2 }}>
            <Typography variant="h6">Average Order Value</Typography>
            <Typography variant="h4">${metrics.averageOrderValue.toFixed(2)}</Typography>
          </Paper>
        </Grid>
      </Grid>
      <Box mt={4}>
        <Typography variant="h5" gutterBottom>A/B Testing</Typography>
        <ABTestManager />
      </Box>
      <Box mt={4}>
        <Typography variant="h5" gutterBottom>Marketing Campaigns</Typography>
        <MarketingCampaigns />
      </Box>
    </Box>
  );
};

export default MarketingDashboard;

================
File: components/Menu.tsx
================
import React, { useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';
import { fetchMenu } from 'frontend/src/api/menuApi';
import { MenuItem } from '../types';
import { useSocket } from '../context/SocketContext';

const Menu: React.FC = () => {
  const { locationId } = useParams<{ locationId: string }>();
  const [menuItems, setMenuItems] = useState<MenuItem[]>([]);
  const socket = useSocket();

  useEffect(() => {
    const loadMenu = async () => {
      const items = await fetchMenu(locationId);
      setMenuItems(items);
    };
    loadMenu();

    if (socket) {
      socket.emit('join-location', locationId);

      socket.on('inventory-update', (update) => {
        setMenuItems((prevItems) =>
          prevItems.map((item) =>
            item.id === update.menuItemId
              ? { ...item, onlineInventoryOffset: update.newInventory }
              : item
          )
        );
      });
    }

    return () => {
      if (socket) {
        socket.off('inventory-update');
      }
    };
  }, [locationId, socket]);

  return (
    <div>
      <h2>Menu</h2>
      {menuItems.map((item) => (
        <div key={item.id}>
          <h3>{item.name}</h3>
          <p>{item.description}</p>
          <p>Price: ${item.price}</p>
          {item.isAvailable ? (
            <button>Add to Cart</button>
          ) : (
            <span>Out of Stock</span>
          )}
        </div>
      ))}
    </div>
  );
};

export default Menu;

================
File: components/MenuBuilder.tsx
================
import React, { useState, useEffect, useCallback } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import { MenuService } from '../../services/MenuService';
import { Menu, MenuGroup } from '../types/menuTypes';
import { updateLocationMenu } from '../redux/slices/menuSlice';
import {
  Box,
  Typography,
  Button,
  TextField,
  List,
  ListItem,
  ListItemText,
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
} from '@mui/material';
import {
  Add as AddIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
} from '@mui/icons-material';
import { fetchMenuItems, updateMenuItem } from 'frontend/src/api/menuApi';

const MenuBuilder: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const locationId = useSelector(
    (state: RootState) => state.location.currentLocation?.id
  );
  const menu = useSelector((state: RootState) => state.menu.locationMenu);

  const [isAddingGroup, setIsAddingGroup] = useState(false);
  const [newGroupName, setNewGroupName] = useState('');
  const [editingGroup, setEditingGroup] = useState<MenuGroup | null>(null);

  const menuService = React.useMemo(() => new MenuService(), []);

  const fetchMenu = useCallback(async () => {
    if (locationId) {
      try {
        const fetchedMenu: Menu = await menuService.getLocationMenu(locationId);
        dispatch(updateLocationMenu(fetchedMenu));
      } catch (error) {
        console.error('Failed to fetch menu:', error);
      }
    }
  }, [locationId, menuService, dispatch]);

  useEffect(() => {
    fetchMenu();
  }, [fetchMenu]);

  const handleAddGroup = useCallback(async () => {
    if (locationId && newGroupName.trim()) {
      try {
        const updatedMenu: Menu = await menuService.addMenuGroup(
          locationId,
          newGroupName
        );
        dispatch(updateLocationMenu(updatedMenu));
        setNewGroupName('');
        setIsAddingGroup(false);
      } catch (error) {
        console.error('Failed to add menu group:', error);
      }
    }
  }, [locationId, newGroupName, menuService, dispatch]);

  const handleEditGroup = useCallback(async () => {
    if (locationId && editingGroup) {
      try {
        const updatedMenu: Menu = await menuService.updateMenuGroup(
          locationId,
          editingGroup.id,
          editingGroup.name
        );
        dispatch(updateLocationMenu(updatedMenu));
        setEditingGroup(null);
      } catch (error) {
        console.error('Failed to update menu group:', error);
      }
    }
  }, [locationId, editingGroup, menuService, dispatch]);

  const handleDeleteGroup = useCallback(
    async (groupId: number) => {
      if (locationId) {
        try {
          const updatedMenu: Menu = await menuService.deleteMenuGroup(
            locationId,
            groupId
          );
          dispatch(updateLocationMenu(updatedMenu));
        } catch (error) {
          console.error('Failed to delete menu group:', error);
        }
      }
    },
    [locationId, menuService, dispatch]
  );

  return (
    <Box>
      <Typography variant="h4">Menu Builder</Typography>
      <Button startIcon={<AddIcon />} onClick={() => setIsAddingGroup(true)}>
        Add Menu Group
      </Button>
      <List>
        {menu?.groups.map((group) => (
          <ListItem key={group.id}>
            <ListItemText primary={group.name} />
            <IconButton onClick={() => setEditingGroup(group)}>
              <EditIcon />
            </IconButton>
            <IconButton onClick={() => handleDeleteGroup(group.id)}>
              <DeleteIcon />
            </IconButton>
          </ListItem>
        ))}
      </List>

      <Dialog open={isAddingGroup} onClose={() => setIsAddingGroup(false)}>
        <DialogTitle>Add Menu Group</DialogTitle>
        <DialogContent>
          <TextField
            margin="dense"
            label="Group Name"
            fullWidth
            value={newGroupName}
            onChange={(e) => setNewGroupName(e.target.value)}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setIsAddingGroup(false)}>Cancel</Button>
          <Button onClick={handleAddGroup}>Add</Button>
        </DialogActions>
      </Dialog>

      <Dialog open={!!editingGroup} onClose={() => setEditingGroup(null)}>
        <DialogTitle>Edit Menu Group</DialogTitle>
        <DialogContent>
          <TextField
            margin="dense"
            label="Group Name"
            fullWidth
            value={editingGroup?.name || ''}
            onChange={(e) =>
              setEditingGroup(
                editingGroup ? { ...editingGroup, name: e.target.value } : null
              )
            }
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setEditingGroup(null)}>Cancel</Button>
          <Button onClick={handleEditGroup}>Save</Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default MenuBuilder;

================
File: components/MenuGroupComponent.tsx
================
import React from 'react';
import { useDispatch } from 'react-redux';
import { AppDispatch } from '../redux/store';
import { updateMenu } from '../redux/slices/menuSlice';
import { Menu, MenuGroup, MenuItem } from '../types/menuTypes';

interface MenuGroupComponentProps {
  menu: Menu;
  group: MenuGroup;
}

const MenuGroupComponent: React.FC<MenuGroupComponentProps> = ({ menu, group }) => {
  const dispatch = useDispatch<AppDispatch>();

  const handleAddItem = (newItem: Omit<MenuItem, 'id' | 'isModified'>) => {
    const updatedGroup = {
      ...group,
      items: [...group.items, { ...newItem, id: Date.now().toString(), isModified: true }],
      isModified: true,
    };
    const updatedMenu = {
      ...menu,
      groups: menu.groups.map((g: MenuGroup) => g.id === group.id ? updatedGroup : g),
      isModified: true,
    };
    dispatch(updateMenu({
      locationId: menu.locationId,
      menuId: menu.id,
      menuData: updatedMenu,
    }));
  };

  const handleUpdateItem = (updatedItem: MenuItem) => {
    const updatedGroup = {
      ...group,
      items: group.items.map((item: MenuItem) => 
        item.id === updatedItem.id ? { ...updatedItem, isModified: true } : item
      ),
      isModified: true,
    };
    const updatedMenu = {
      ...menu,
      groups: menu.groups.map((g: MenuGroup) => g.id === group.id ? updatedGroup : g),
      isModified: true,
    };
    dispatch(updateMenu({
      locationId: menu.locationId,
      menuId: menu.id,
      menuData: updatedMenu,
    }));
  };

  const handleRemoveItem = (itemId: string) => {
    const updatedGroup = {
      ...group,
      items: group.items.filter((item: MenuItem) => item.id !== itemId),
      isModified: true,
    };
    const updatedMenu = {
      ...menu,
      groups: menu.groups.map((g: MenuGroup) => g.id === group.id ? updatedGroup : g),
      isModified: true,
    };
    dispatch(updateMenu({
      locationId: menu.locationId,
      menuId: menu.id,
      menuData: updatedMenu,
    }));
  };

  return (
    <div>
      <h2>{group.name}</h2>
      {group.items.map((item) => (
        <div key={item.id}>
          <span>{item.name} - ${item.price}</span>
          {item.isModified && <span> (Modified)</span>}
          <button onClick={() => handleUpdateItem({ ...item, price: item.price + 1 })}>
            Increase Price
          </button>
          <button onClick={() => handleRemoveItem(item.id)}>Remove</button>
        </div>
      ))}
      <button onClick={() => handleAddItem({ name: 'New Item', price: 9.99 })}>
        Add New Item
      </button>
    </div>
  );
};

export default MenuGroupComponent;

================
File: components/MenuItem.tsx
================
import React, { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import { fetchReviewsForMenuItem } from '../redux/slices/reviewSlice';
import { Typography, Box, Button } from '@mui/material';
import ItemReviews from './ItemReviews';
import SubmitReview from './SubmitReview';

interface MenuItemProps {
  id: number;
  name: string;
  description: string;
  price: number;
  addToCart: (itemId: number) => void;
}

const MenuItem: React.FC<MenuItemProps> = ({
  id,
  name,
  description,
  price,
  addToCart,
}) => {
  const dispatch = useDispatch<AppDispatch>();
  const reviews = useSelector(
    (state: RootState) => state.reviews.itemReviews[id] || []
  );

  useEffect(() => {
    dispatch(fetchReviewsForMenuItem(id));
  }, [dispatch, id]);

  return (
    <Box>
      <Typography variant="h6">{name}</Typography>
      <Typography variant="body1">{description}</Typography>
      <Typography variant="body2">${price.toFixed(2)}</Typography>
      <Button onClick={() => addToCart(id)}>Add to Cart</Button>
      <ItemReviews reviews={reviews} />
      <SubmitReview menuItemId={id} />
    </Box>
  );
};

export default MenuItem;

================
File: components/MenuItemCard.tsx
================
import React from 'react';
import { Card, CardContent, CardMedia, Typography, Button, Box } from '@mui/material';
import { MenuItem } from '../types/menuTypes';

interface MenuItemCardProps {
  item: MenuItem;
  onSelect: (item: MenuItem) => void;
}

const MenuItemCard: React.FC<MenuItemCardProps> = ({ item, onSelect }) => {
  const handleKeyPress = (event: React.KeyboardEvent) => {
    if (event.key === 'Enter' || event.key === ' ') {
      onSelect(item);
    }
  };

  return (
    <Card 
      sx={{ 
        maxWidth: 345, 
        m: 2, 
        display: 'flex', 
        flexDirection: 'column',
        height: '100%',
        '&:hover': {
          boxShadow: 6,
        },
      }}
    >
      <CardMedia
        component="img"
        height="140"
        image={item.image || '/placeholder-image.jpg'}
        alt={item.name}
      />
      <CardContent sx={{ flexGrow: 1 }}>
        <Typography gutterBottom variant="h5" component="div">
          {item.name}
        </Typography>
        <Typography variant="body2" color="text.secondary">
          {item.description}
        </Typography>
        <Typography variant="h6" color="primary" sx={{ mt: 2 }}>
          ${item.price.toFixed(2)}
        </Typography>
      </CardContent>
      <Box sx={{ p: 2 }}>
        <Button
          variant="contained"
          color="primary"
          onClick={() => onSelect(item)}
          onKeyPress={handleKeyPress}
          fullWidth
          aria-label={`Add ${item.name} to cart`}
        >
          Add to Cart
        </Button>
      </Box>
    </Card>
  );
};

export default MenuItemCard;

================
File: components/MenuItemComponent.tsx
================
import React from 'react';

interface Modifier {
  id: number;
  name: string;
  price: number;
}

interface MenuItem {
  id: number;
  name: string;
  price: number;
  modifiers: Modifier[];
}

interface Props {
  item: MenuItem;
}

const MenuItemComponent: React.FC<Props> = ({ item }) => {
  return (
    <div className="border p-4 rounded">
      <h4 className="text-md font-semibold">{item.name}</h4>
      <p className="text-sm text-gray-600">${item.price.toFixed(2)}</p>
      <div className="mt-2">
        <h5 className="text-sm font-bold">Modifiers:</h5>
        <ul className="list-disc ml-4">
          {item.modifiers.map((modifier) => (
            <li key={modifier.id}>
              {modifier.name} (+${modifier.price.toFixed(2)})
            </li>
          ))}
        </ul>
      </div>
    </div>
  );
};

export default MenuItemComponent;

================
File: components/MenuItemDisplay.tsx
================
import React, { useState, KeyboardEvent } from 'react';
import { Typography, Box, Button, Collapse, Paper } from '@mui/material';
import { MenuItem } from '../types/menuTypes';

interface MenuItemDisplayProps {
  item: MenuItem;
  onAddToCart: (item: MenuItem) => void;
}

const MenuItemDisplay: React.FC<MenuItemDisplayProps> = ({
  item,
  onAddToCart,
}) => {
  const [expanded, setExpanded] = useState(false);

  const toggleExpanded = () => {
    setExpanded(!expanded);
  };

  const handleKeyDown = (event: KeyboardEvent<HTMLDivElement>) => {
    if (event.key === 'Enter' || event.key === ' ') {
      toggleExpanded();
    }
  };

  return (
    <Paper
      elevation={3}
      sx={{
        border: '1px solid #ddd',
        borderRadius: '4px',
        padding: '16px',
        marginBottom: '16px',
        cursor: 'pointer',
        '&:hover': {
          boxShadow: 6,
        },
      }}
      onClick={toggleExpanded}
      onKeyDown={handleKeyDown}
      tabIndex={0}
      role="button"
      aria-expanded={expanded}
    >
      <Box display="flex" justifyContent="space-between" alignItems="center">
        <Typography variant="h6">{item.name}</Typography>
        <Typography variant="h6" color="primary">${item.price.toFixed(2)}</Typography>
      </Box>
      <Typography variant="body2" color="text.secondary">{item.description}</Typography>
      <Collapse in={expanded}>
        <Box mt={2}>
          {item.calories && (
            <Typography variant="body2">Calories: {item.calories}</Typography>
          )}
          {item.allergens && item.allergens.length > 0 && (
            <Typography variant="body2">
              Allergens: {item.allergens.join(', ')}
            </Typography>
          )}
          {item.nutritionalInfo && (
            <Typography variant="body2">
              Nutritional Info: {item.nutritionalInfo}
            </Typography>
          )}
          <Button
            variant="contained"
            color="primary"
            onClick={(e) => {
              e.stopPropagation();
              onAddToCart(item);
            }}
            sx={{ mt: 2 }}
          >
            Add to Cart
          </Button>
        </Box>
      </Collapse>
    </Paper>
  );
};

export default MenuItemDisplay;

================
File: components/MenuItemModal.tsx
================
import React, { useState } from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Typography,
  TextField,
  Box,
} from '@mui/material';
import { MenuItem } from '../types/menuTypes';

interface MenuItemModalProps {
  item: MenuItem;
  onClose: () => void;
  onAddToCart: (item: MenuItem, quantity: number) => void;
}

const MenuItemModal: React.FC<MenuItemModalProps> = ({ item, onClose, onAddToCart }) => {
  const [quantity, setQuantity] = useState(1);

  const handleQuantityChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setQuantity(Math.max(1, parseInt(event.target.value) || 1));
  };

  const handleAddToCart = () => {
    onAddToCart(item, quantity);
    onClose();
  };

  return (
    <Dialog open={true} onClose={onClose} maxWidth="sm" fullWidth>
      <DialogTitle>{item.name}</DialogTitle>
      <DialogContent>
        <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
          <img src={item.image} alt={item.name} style={{ maxWidth: '100%', height: 'auto' }} />
          <Typography variant="body1">{item.description}</Typography>
          <Typography variant="h6" color="primary">
            ${item.price.toFixed(2)}
          </Typography>
          <TextField
            label="Quantity"
            type="number"
            value={quantity}
            onChange={handleQuantityChange}
            InputProps={{ inputProps: { min: 1 } }}
          />
        </Box>
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose}>Cancel</Button>
        <Button onClick={handleAddToCart} variant="contained" color="primary">
          Add to Cart
        </Button>
      </DialogActions>
    </Dialog>
  );
};

export default MenuItemModal;

================
File: components/MenuManager.tsx
================
import React, { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import { fetchMenuItems } from '../redux/slices/menuSlice';
import {
  Box,
  Typography,
  List,
  ListItem,
  ListItemText,
  Button,
} from '@mui/material';
import MenuBuilder from './MenuBuilder';

const MenuManager: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const menuItems = useSelector((state: RootState) => state.menu.items);

  useEffect(() => {
    dispatch(fetchMenuItems());
  }, [dispatch]);

  return (
    <Box>
      <Typography variant="h5">Menu Manager</Typography>
      <List>
        {menuItems.map((item) => (
          <ListItem key={item.id}>
            <ListItemText primary={item.name} secondary={`$${item.price}`} />
            <Button>Edit</Button>
          </ListItem>
        ))}
      </List>
      <MenuBuilder />
    </Box>
  );
};

export default MenuManager;

================
File: components/MultiLocationMenuManager.tsx
================
import React, { useState, useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import { fetchMenus, updateMenuItem, addMenuItem, removeMenuItem } from '../redux/slices/menuSlice';
import { selectSelectedLocations, selectCurrentUser } from '../redux/slices/userSlice';
import { Table, TableBody, TableCell, TableContainer, TableHead, TableRow, Paper, Button, TextField, Typography, Box } from '@mui/material';
import LocationSelector from './LocationSelector';

const MenuDashboard: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const selectedLocations = useSelector(selectSelectedLocations);
  const user = useSelector(selectCurrentUser);
  const menus = useSelector((state: RootState) => state.menu.menus);
  const [editingItem, setEditingItem] = useState<string | null>(null);

  useEffect(() => {
    if (selectedLocations.length > 0) {
      dispatch(fetchMenus(selectedLocations));
    }
  }, [dispatch, selectedLocations]);

  // ... (rest of the implementation)

  return (
    <Box>
      <Typography variant="h4" gutterBottom>Menu Dashboard</Typography>
      {user?.role === 'admin' && <LocationSelector />}
      
      <TableContainer component={Paper}>
        {/* ... (table implementation) */}
      </TableContainer>
    </Box>
  );
};

export default MenuDashboard;

================
File: components/OrderDashboard.tsx
================
import React, { useState, useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import { fetchOrders, updateOrderStatus } from '../redux/slices/orderSlice';
import { selectSelectedLocations, selectCurrentUser } from '../redux/slices/userSlice';
import { 
  Table, TableBody, TableCell, TableContainer, TableHead, TableRow, Paper, 
  Select, MenuItem, Typography, CircularProgress, Box, Tabs, Tab
} from '@mui/material';
import LocationSelector from './LocationSelector';

const OrderDashboard: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { orders, status, error } = useSelector((state: RootState) => state.orders);
  const selectedLocations = useSelector(selectSelectedLocations);
  const user = useSelector(selectCurrentUser);
  const [activeTab, setActiveTab] = useState(0);

  useEffect(() => {
    if (selectedLocations.length > 0) {
      dispatch(fetchOrders(selectedLocations));
    }
  }, [dispatch, selectedLocations]);

  const handleStatusChange = (orderId: string, newStatus: string) => {
    dispatch(updateOrderStatus({ orderId, status: newStatus }));
  };

  const handleTabChange = (event: React.SyntheticEvent, newValue: number) => {
    setActiveTab(newValue);
  };

  if (status === 'loading') return <CircularProgress />;
  if (status === 'failed') return <Typography color="error">Error: {error}</Typography>;

  return (
    <Box>
      <Typography variant="h4" gutterBottom>Order Dashboard</Typography>
      {user?.role === 'admin' && <LocationSelector />}
      
      <Tabs value={activeTab} onChange={handleTabChange} sx={{ mb: 2 }}>
        <Tab label="All Orders" />
        <Tab label="Pending" />
        <Tab label="In Progress" />
        <Tab label="Completed" />
      </Tabs>

      <TableContainer component={Paper}>
        <Table>
          <TableHead>
            <TableRow>
              <TableCell>Order ID</TableCell>
              <TableCell>Location</TableCell>
              <TableCell>Customer</TableCell>
              <TableCell>Date</TableCell>
              <TableCell>Total</TableCell>
              <TableCell>Status</TableCell>
              <TableCell>Actions</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {orders
              .filter(order => {
                if (activeTab === 0) return true;
                if (activeTab === 1) return order.status === 'pending';
                if (activeTab === 2) return order.status === 'in_progress';
                if (activeTab === 3) return order.status === 'completed';
                return true;
              })
              .map((order) => (
                <TableRow key={order.id}>
                  <TableCell>{order.id}</TableCell>
                  <TableCell>{order.locationName}</TableCell>
                  <TableCell>{order.customerName}</TableCell>
                  <TableCell>{new Date(order.orderDate).toLocaleString()}</TableCell>
                  <TableCell>${order.totalAmount.toFixed(2)}</TableCell>
                  <TableCell>{order.status}</TableCell>
                  <TableCell>
                    <Select
                      value={order.status}
                      onChange={(e) => handleStatusChange(order.id, e.target.value as string)}
                    >
                      <MenuItem value="pending">Pending</MenuItem>
                      <MenuItem value="in_progress">In Progress</MenuItem>
                      <MenuItem value="completed">Completed</MenuItem>
                      <MenuItem value="cancelled">Cancelled</MenuItem>
                    </Select>
                  </TableCell>
                </TableRow>
              ))}
          </TableBody>
        </Table>
      </TableContainer>
    </Box>
  );
};

export default OrderDashboard;

================
File: components/OrderManagement.tsx
================
import React, { useState, useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import { fetchOrders, updateOrderStatus } from '../redux/slices/orderSlice';
import { selectSelectedLocations } from '../redux/slices/userSlice';
import { Table, TableBody, TableCell, TableContainer, TableHead, TableRow, Paper, Select, MenuItem } from '@mui/material';

const OrderManagement: React.FC = () => {
  // ... (implementation as provided in the previous response)
};

export default OrderManagement;

================
File: components/OrderProvider.tsx
================
import React, { useState } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import { updateOrderProvider } from '../../redux/slices/orderProviderSlice';
import DoordashMarketplaceSettings from './DoordashMarketplaceSettings';
import {
  TextField,
  Button,
  Switch,
  FormControlLabel,
  Typography,
  Box,
} from '@mui/material';

interface OrderProviderProps {
  providerId: number;
}

const OrderProvider: React.FC<OrderProviderProps> = ({ providerId }) => {
  const dispatch = useDispatch<AppDispatch>();
  const provider = useSelector((state: RootState) =>
    state.orderProviders.providers.find((p) => p.id === providerId)
  );

  const [handleScheduledOrders, setHandleScheduledOrders] = useState(
    provider?.handleScheduledOrders || false
  );
  const [scheduledOrderLeadTime, setScheduledOrderLeadTime] = useState(
    provider?.scheduledOrderLeadTime || 30
  );

  if (!provider) {
    return <div>Provider not found</div>;
  }

  const handleSave = () => {
    dispatch(
      updateOrderProvider({
        id: providerId,
        handleScheduledOrders,
        scheduledOrderLeadTime,
      })
    );
  };

  return (
    <Box>
      <Typography variant="h5">{provider.name}</Typography>
      <FormControlLabel
        control={
          <Switch
            checked={handleScheduledOrders}
            onChange={(e) => setHandleScheduledOrders(e.target.checked)}
          />
        }
        label="Handle Scheduled Orders"
      />
      <TextField
        fullWidth
        margin="normal"
        label="Scheduled Order Lead Time (minutes)"
        type="number"
        value={scheduledOrderLeadTime}
        onChange={(e) => setScheduledOrderLeadTime(parseInt(e.target.value))}
        disabled={!handleScheduledOrders}
      />
      <Button onClick={handleSave} variant="contained" color="primary">
        Save General Settings
      </Button>

      {/* Provider-specific settings */}
      {provider.type === 'doordash' && (
        <DoordashMarketplaceSettings providerId={providerId} />
      )}
      {/* Add other provider-specific settings components here */}
    </Box>
  );
};

export default OrderProvider;

================
File: components/Orders.tsx
================
import React, { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { fetchOrders } from '../redux/slices/orderSlice';
import { RootState, AppDispatch } from '../types';
import { 
  Typography, 
  Table, 
  TableBody, 
  TableCell, 
  TableContainer, 
  TableHead, 
  TableRow, 
  Paper,
  CircularProgress,
} from '@mui/material';

const Orders: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { orders, status, error } = useSelector((state: RootState) => state.orders);

  useEffect(() => {
    dispatch(fetchOrders());
  }, [dispatch]);

  if (status === 'loading') {
    return <CircularProgress />;
  }

  if (status === 'failed') {
    return <Typography color="error">Error: {error}</Typography>;
  }

  return (
    <div>
      <Typography variant="h4" gutterBottom>Orders</Typography>
      <TableContainer component={Paper}>
        <Table>
          <TableHead>
            <TableRow>
              <TableCell>Order ID</TableCell>
              <TableCell>Customer</TableCell>
              <TableCell>Date</TableCell>
              <TableCell>Total</TableCell>
              <TableCell>Status</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {orders.map((order) => (
              <TableRow key={order.id}>
                <TableCell>{order.id}</TableCell>
                <TableCell>{order.customerName}</TableCell>
                <TableCell>{new Date(order.orderDate).toLocaleString()}</TableCell>
                <TableCell>${order.totalAmount.toFixed(2)}</TableCell>
                <TableCell>{order.status}</TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>
    </div>
  );
};

export default Orders;

================
File: components/POSAlerts.tsx
================
import React, { useState, useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import { POSAlert } from '../types';
import { fetchPOSAlerts } from '../redux/slices/posAlertsSlice';
import { Typography, List, ListItem, ListItemText, Paper, Box } from '@mui/material';

const POSAlerts: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { alerts, status, error } = useSelector((state: RootState) => state.posAlerts);
  const posProfiles = useSelector((state: RootState) => state.posProfiles.profiles);

  useEffect(() => {
    dispatch(fetchPOSAlerts());
  }, [dispatch]);

  const getAlertSeverity = (errorCode: string, posProfileId: number) => {
    const profile = posProfiles.find((p) => p.id === posProfileId);
    if (!profile) return 'unknown';

    switch (profile.provider) {
      case 'Toast':
        return errorCode.startsWith('E') ? 'high' : 'medium';
      case 'Revel':
        return errorCode.startsWith('ERR') ? 'high' : 'low';
      default:
        return 'unknown';
    }
  };

  if (status === 'loading') {
    return <Typography>Loading POS alerts...</Typography>;
  }

  if (status === 'failed') {
    return <Typography color="error">Error: {error}</Typography>;
  }

  return (
    <Paper elevation={3}>
      <Box p={2}>
        <Typography variant="h5" gutterBottom>POS Alerts</Typography>
        {alerts.length === 0 ? (
          <Typography>No active alerts</Typography>
        ) : (
          <List>
            {alerts.map((alert) => (
              <ListItem
                key={alert.id}
                sx={{
                  bgcolor: getAlertSeverity(alert.errorCode, alert.posProfileId) === 'high' ? 'error.light' :
                    getAlertSeverity(alert.errorCode, alert.posProfileId) === 'medium' ? 'warning.light' : 'info.light',
                  mb: 1,
                  borderRadius: 1,
                }}
              >
                <ListItemText
                  primary={
                    <Typography variant="subtitle1">
                      <strong>{alert.errorCode}</strong>: {alert.message}
                    </Typography>
                  }
                  secondary={
                    <>
                      <Typography variant="body2" component="span">
                        POS Profile: {posProfiles.find((p) => p.id === alert.posProfileId)?.name}
                      </Typography>
                      <br />
                      <Typography variant="body2" component="span">
                        Time: {new Date(alert.timestamp).toLocaleString()}
                      </Typography>
                    </>
                  }
                />
              </ListItem>
            ))}
          </List>
        )}
      </Box>
    </Paper>
  );
};

export default POSAlerts;

================
File: components/POSDiscountSync.tsx
================
import React, { useState, useEffect, useCallback } from 'react';
import { Button, Typography, CircularProgress, Paper, Box } from '@mui/material';
import { POSIntegrationService } from '../services/POSIntegrationService';
import { useAuth } from '../contexts/AuthContext';
import { User } from '../types/userTypes';
import { useDispatch, useSelector } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import { syncDiscounts, fetchLastSyncTime } from '../redux/slices/posDiscountSlice';
import { syncPOSDiscounts } from 'frontend/src/api/discountApi';

const POSDiscountSync: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { isSyncing, lastSyncTime, error } = useSelector((state: RootState) => state.posDiscount);
  const { user } = useAuth();

  const posIntegrationService = React.useMemo(
    () => new POSIntegrationService(),
    []
  );

  const fetchLastSync = useCallback(() => {
    if (user && (user as User).clientId) {
      dispatch(fetchLastSyncTime((user as User).clientId));
    }
  }, [user, dispatch]);

  useEffect(() => {
    fetchLastSync();
  }, [fetchLastSync]);

  const handleSync = async () => {
    if (user && (user as User).clientId) {
      dispatch(syncDiscounts((user as User).clientId));
    }
  };

  return (
    <Paper elevation={3}>
      <Box p={2}>
        <Typography variant="h6" gutterBottom>POS Discount Sync</Typography>
        <Typography variant="body1" gutterBottom>
          Last sync: {lastSyncTime ? new Date(lastSyncTime).toLocaleString() : 'Never'}
        </Typography>
        <Button
          variant="contained"
          color="primary"
          onClick={handleSync}
          disabled={isSyncing}
          startIcon={isSyncing ? <CircularProgress size={20} color="inherit" /> : null}
        >
          {isSyncing ? 'Syncing...' : 'Sync Discounts'}
        </Button>
        {error && <Typography color="error" mt={2}>{error}</Typography>}
      </Box>
    </Paper>
  );
};

export default POSDiscountSync;

================
File: components/POSIntegrationSelector.tsx
================
import React, { useState, useEffect } from 'react';
import {
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  Button,
  TextField,
  Grid,
  Typography,
  List,
  ListItem,
  ListItemText,
  ListItemSecondaryAction,
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Paper,
  Box,
} from '@mui/material';
import SyncIcon from '@mui/icons-material/Sync';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import { useDispatch, useSelector } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import {
  fetchProfiles,
  createProfile,
  updateProfile,
  deleteProfile,
  syncProfile,
} from '../redux/slices/posIntegrationSlice';
import { POSType, POSProfile } from '../types/posIntegrationTypes';

const POSIntegrationSelector: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { profiles, status, error } = useSelector((state: RootState) => state.posIntegration);
  const [newProfile, setNewProfile] = useState<Partial<POSProfile>>({
    name: '',
    posType: POSType.TOAST,
    apiEndpoint: '',
    apiKey: '',
  });
  const [editingProfile, setEditingProfile] = useState<POSProfile | null>(null);
  const [isDialogOpen, setIsDialogOpen] = useState(false);

  useEffect(() => {
    dispatch(fetchProfiles());
  }, [dispatch]);

  const handleProfileInputChange = (
    event: React.ChangeEvent<HTMLInputElement | { name?: string; value: unknown }>
  ) => {
    const { name, value } = event.target;
    setNewProfile((prev) => ({ ...prev, [name as string]: value }));
  };

  const handleCreateProfile = async () => {
    dispatch(createProfile(newProfile as POSProfile));
    setNewProfile({
      name: '',
      posType: POSType.TOAST,
      apiEndpoint: '',
      apiKey: '',
    });
  };

  const handleEditProfile = (profile: POSProfile) => {
    setEditingProfile(profile);
    setIsDialogOpen(true);
  };

  const handleUpdateProfile = async () => {
    if (editingProfile) {
      dispatch(updateProfile(editingProfile));
      setIsDialogOpen(false);
    }
  };

  const handleDeleteProfile = async (profileId: number) => {
    if (window.confirm('Are you sure you want to delete this profile?')) {
      dispatch(deleteProfile(profileId));
    }
  };

  const handleSyncProfile = async (profileId: number) => {
    dispatch(syncProfile(profileId));
  };

  if (status === 'loading') {
    return <Typography>Loading POS profiles...</Typography>;
  }

  if (status === 'failed') {
    return <Typography color="error">Error: {error}</Typography>;
  }

  return (
    <Paper elevation={3}>
      <Box p={2}>
        <Grid container spacing={3}>
          <Grid item xs={12}>
            <Typography variant="h4" gutterBottom>POS Integration Manager</Typography>
          </Grid>
          <Grid item xs={12}>
            <Typography variant="h5" gutterBottom>Create New POS Profile</Typography>
            <TextField
              name="name"
              label="Profile Name"
              value={newProfile.name}
              onChange={handleProfileInputChange}
              fullWidth
              margin="normal"
            />
            <FormControl fullWidth margin="normal">
              <InputLabel id="pos-type-select-label">POS Type</InputLabel>
              <Select
                labelId="pos-type-select-label"
                name="posType"
                value={newProfile.posType}
                onChange={handleProfileInputChange}
              >
                {Object.values(POSType).map((type) => (
                  <MenuItem key={type} value={type}>
                    {type}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
            <TextField
              name="apiEndpoint"
              label="API Endpoint"
              value={newProfile.apiEndpoint}
              onChange={handleProfileInputChange}
              fullWidth
              margin="normal"
            />
            <TextField
              name="apiKey"
              label="API Key"
              value={newProfile.apiKey}
              onChange={handleProfileInputChange}
              fullWidth
              margin="normal"
            />
            <Button
              onClick={handleCreateProfile}
              variant="contained"
              color="primary"
            >
              Create Profile
            </Button>
          </Grid>
          <Grid item xs={12}>
            <Typography variant="h5" gutterBottom>Existing POS Profiles</Typography>
            <List>
              {profiles.map((profile) => (
                <ListItem key={profile.id}>
                  <ListItemText
                    primary={profile.name}
                    secondary={`${profile.posType} - ${profile.apiEndpoint}`}
                  />
                  <ListItemSecondaryAction>
                    <IconButton
                      edge="end"
                      aria-label="edit"
                      onClick={() => handleEditProfile(profile)}
                    >
                      <EditIcon />
                    </IconButton>
                    <IconButton
                      edge="end"
                      aria-label="delete"
                      onClick={() => handleDeleteProfile(profile.id)}
                    >
                      <DeleteIcon />
                    </IconButton>
                    <IconButton
                      edge="end"
                      aria-label="sync"
                      onClick={() => handleSyncProfile(profile.id)}
                    >
                      <SyncIcon />
                    </IconButton>
                  </ListItemSecondaryAction>
                </ListItem>
              ))}
            </List>
          </Grid>
        </Grid>
      </Box>
      <Dialog open={isDialogOpen} onClose={() => setIsDialogOpen(false)}>
        <DialogTitle>Edit POS Profile</DialogTitle>
        <DialogContent>
          {editingProfile && (
            <>
              <TextField
                name="name"
                label="Profile Name"
                value={editingProfile.name}
                onChange={(event) =>
                  setEditingProfile({
                    ...editingProfile,
                    name: event.target.value,
                  })
                }
                fullWidth
                margin="normal"
              />
              <FormControl fullWidth margin="normal">
                <InputLabel id="pos-type-select-label">POS Type</InputLabel>
                <Select
                  labelId="pos-type-select-label"
                  name="posType"
                  value={editingProfile.posType}
                  onChange={(event) =>
                    setEditingProfile({
                      ...editingProfile,
                      posType: event.target.value as POSType,
                    })
                  }
                >
                  {Object.values(POSType).map((type) => (
                    <MenuItem key={type} value={type}>
                      {type}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
              <TextField
                name="apiEndpoint"
                label="API Endpoint"
                value={editingProfile.apiEndpoint}
                onChange={(event) =>
                  setEditingProfile({
                    ...editingProfile,
                    apiEndpoint: event.target.value,
                  })
                }
                fullWidth
                margin="normal"
              />
              <TextField
                name="apiKey"
                label="API Key"
                value={editingProfile.apiKey}
                onChange={(event) =>
                  setEditingProfile({
                    ...editingProfile,
                    apiKey: event.target.value,
                  })
                }
                fullWidth
                margin="normal"
              />
            </>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setIsDialogOpen(false)}>Cancel</Button>
          <Button
            onClick={handleUpdateProfile}
            variant="contained"
            color="primary"
          >
            Update
          </Button>
        </DialogActions>
      </Dialog>
    </Paper>
  );
};

export default POSIntegrationSelector;

================
File: components/POSSettingsForm.tsx
================
import React, { useState, useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import {
  updatePOSSettings,
  fetchPOSSettings,
} from '../redux/slices/posSettingsSlice';

const POSSettingsForm: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const posSettings = useSelector((state: RootState) => state.posSettings);
  const [modifierSendMethod, setModifierSendMethod] = useState('');

  useEffect(() => {
    dispatch(fetchPOSSettings());
  }, [dispatch]);

  useEffect(() => {
    if (posSettings.modifierSendMethod) {
      setModifierSendMethod(posSettings.modifierSendMethod);
    }
  }, [posSettings]);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    dispatch(updatePOSSettings({ modifierSendMethod }));
  };

  return (
    <form onSubmit={handleSubmit}>
      <h2>POS Settings</h2>
      <div>
        <label htmlFor="modifierSendMethod">Modifier Send Method:</label>
        <select
          id="modifierSendMethod"
          value={modifierSendMethod}
          onChange={(e) => setModifierSendMethod(e.target.value)}
        >
          <option value="list">Send as List</option>
          <option value="individual">Send Individually</option>
        </select>
      </div>
      <button type="submit">Save Settings</button>
    </form>
  );
};

export default POSSettingsForm;

================
File: components/PrivateRoute.tsx
================
import React from 'react';
import { Navigate, Outlet } from 'react-router-dom';
import { useSelector } from 'react-redux';
import { RootState } from '../redux/store';
import { useClientContext } from '../context/ClientContext';
import { UserRole } from '../types/userTypes';
import { CircularProgress, Box } from '@mui/material';

interface PrivateRouteProps {
  allowedRoles: UserRole[];
}

const PrivateRoute: React.FC<PrivateRouteProps> = ({ allowedRoles }) => {
  const { isAuthenticated, user } = useSelector((state: RootState) => state.auth);
  const { client, isLoading } = useClientContext();

  if (isLoading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" height="100vh">
        <CircularProgress />
      </Box>
    );
  }

  if (!client) {
    return <Navigate to="/login" replace />;
  }

  if (!isAuthenticated || !user) {
    return <Navigate to="/login" replace />;
  }

  const hasAllowedRole = user.roles.some((role) => allowedRoles.includes(role as UserRole));

  if (!hasAllowedRole) {
    return <Navigate to="/" replace />;
  }

  return <Outlet />;
};

export default PrivateRoute;

================
File: components/ProtectedRoute.tsx
================
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useSelector } from 'react-redux';
import { RootState } from '../redux/store';
import { CircularProgress, Box } from '@mui/material';

interface ProtectedRouteProps {
  children: React.ReactNode;
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {
  const { user, isAuthenticated, loading } = useSelector((state: RootState) => state.auth);
  const location = useLocation();

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" height="100vh">
        <CircularProgress />
      </Box>
    );
  }

  if (!isAuthenticated || !user) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return <>{children}</>;
};

export default ProtectedRoute;

================
File: components/ProviderList.tsx
================
import React, { useEffect, useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { fetchProviders } from '../redux/slices/providerSlice';
import { Provider } from '../types/providerTypes';
import { AppDispatch, RootState } from '../redux/store';
import { Typography, List, ListItem, ListItemText, Paper, Box, CircularProgress } from '@mui/material';

const ProviderList: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { providers, loading, error } = useSelector((state: RootState) => state.provider);

  useEffect(() => {
    dispatch(fetchProviders());
  }, [dispatch]);

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" minHeight="200px">
        <CircularProgress />
      </Box>
    );
  }

  if (error) {
    return (
      <Typography color="error" align="center">
        Error: {error}
      </Typography>
    );
  }

  return (
    <Paper elevation={3}>
      <Box p={3}>
        <Typography variant="h4" gutterBottom>
          Providers
        </Typography>
        <List>
          {providers.map((provider: Provider) => (
            <ListItem key={provider.id}>
              <ListItemText
                primary={provider.name}
                secondary={`Type: ${provider.type} | Status: ${provider.status}`}
              />
            </ListItem>
          ))}
        </List>
      </Box>
    </Paper>
  );
};

export default ProviderList;

================
File: components/RealtimeMetricsTicker.tsx
================
import React, { useEffect, useState } from 'react';
import { Typography, Box, Paper } from '@mui/material';
import { useSelector, useDispatch } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import { fetchRealtimeMetrics } from '../api/metricsApi';

const RealtimeMetricsTicker: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const realtimeMetrics = useSelector((state: RootState) => state.realtimeMetrics.metrics);
  const [currentMetricIndex, setCurrentMetricIndex] = useState(0);

  useEffect(() => {
    const fetchMetrics = () => {
      dispatch(fetchRealtimeMetrics());
    };

    fetchMetrics();
    const interval = setInterval(fetchMetrics, 60000); // Fetch every minute

    return () => clearInterval(interval);
  }, [dispatch]);

  useEffect(() => {
    const rotateMetrics = setInterval(() => {
      setCurrentMetricIndex((prevIndex) => (prevIndex + 1) % Object.keys(realtimeMetrics).length);
    }, 5000);

    return () => clearInterval(rotateMetrics);
  }, [realtimeMetrics]);

  const currentMetric = Object.entries(realtimeMetrics)[currentMetricIndex];

  return (
    <Paper elevation={3}>
      <Box p={2}>
        <Typography variant="h6">Real-time Metrics</Typography>
        {currentMetric && (
          <Typography variant="h5">
            {currentMetric[0]}: {currentMetric[1]}
          </Typography>
        )}
        <Typography variant="caption">
          Data updates every minute. Metric rotates every 5 seconds. Check the dashboard for more metrics.
        </Typography>
      </Box>
    </Paper>
  );
};

export default RealtimeMetricsTicker;

================
File: components/RevenueChart.tsx
================
import React from 'react';
import { Line } from 'react-chartjs-2';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend,
} from 'chart.js';
import { RevenueData } from '../types/revenueTypes';
import { Box, Paper, Typography, TextField } from '@mui/material';

ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend
);

interface Props {
  data: RevenueData[];
  dateRange: { start: Date; end: Date };
  setDateRange: (dateRange: { start: Date; end: Date }) => void;
}

const RevenueChart: React.FC<Props> = ({ data, dateRange, setDateRange }) => {
  const chartData = {
    labels: data.map((item) => new Date(item.date).toLocaleDateString()),
    datasets: [
      {
        label: 'Revenue',
        data: data.map((item) => item.amount),
        borderColor: 'rgb(75, 192, 192)',
        tension: 0.1,
      },
    ],
  };

  const options = {
    responsive: true,
    plugins: {
      legend: {
        position: 'top' as const,
      },
      title: {
        display: true,
        text: 'Revenue Over Time',
      },
    },
  };

  const handleDateChange = (
    e: React.ChangeEvent<HTMLInputElement>,
    type: 'start' | 'end'
  ) => {
    setDateRange({
      ...dateRange,
      [type]: new Date(e.target.value),
    });
  };

  return (
    <Paper elevation={3}>
      <Box p={3}>
        <Typography variant="h5" gutterBottom>
          Revenue Chart
        </Typography>
        <Box display="flex" justifyContent="space-between" mb={2}>
          <TextField
            label="Start Date"
            type="date"
            value={dateRange.start.toISOString().split('T')[0]}
            onChange={(e) => handleDateChange(e, 'start')}
            InputLabelProps={{
              shrink: true,
            }}
          />
          <TextField
            label="End Date"
            type="date"
            value={dateRange.end.toISOString().split('T')[0]}
            onChange={(e) => handleDateChange(e, 'end')}
            InputLabelProps={{
              shrink: true,
            }}
          />
        </Box>
        <Box height={400}>
          <Line data={chartData} options={options} />
        </Box>
      </Box>
    </Paper>
  );
};

export default RevenueChart;

================
File: components/ReviewManager.tsx
================
import React, { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import {
  fetchPendingReviews,
  approveReview,
  deleteReview,
} from '../redux/slices/reviewSlice';
import {
  Typography,
  List,
  ListItem,
  ListItemText,
  Button,
  Box,
  Rating,
} from '@mui/material';
import { fetchReviews, updateReview } from 'frontend/src/api/reviewApi';

const ReviewManager: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const pendingReviews = useSelector(
    (state: RootState) => state.reviews.pendingReviews
  );

  useEffect(() => {
    dispatch(fetchPendingReviews());
  }, [dispatch]);

  const handleApprove = (reviewId: number) => {
    dispatch(approveReview(reviewId));
  };

  const handleDelete = (reviewId: number) => {
    dispatch(deleteReview(reviewId));
  };

  return (
    <Box>
      <Typography variant="h5">Pending Reviews</Typography>
      <List>
        {pendingReviews.map((review) => (
          <ListItem key={review.id}>
            <ListItemText
              primary={`${review.firstName} ${review.lastInitial}. - ${review.MenuItem.name}`}
              secondary={
                <>
                  <Rating value={review.rating} readOnly size="small" />
                  <Typography variant="body2">{review.comment}</Typography>
                </>
              }
            />
            <Button onClick={() => handleApprove(review.id)}>Approve</Button>
            <Button onClick={() => handleDelete(review.id)}>Delete</Button>
          </ListItem>
        ))}
      </List>
    </Box>
  );
};

export default ReviewManager;

================
File: components/RoleManagement.tsx
================
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  List,
  ListItem,
  ListItemText,
  Button,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Checkbox,
  FormControlLabel,
} from '@mui/material';

interface Role {
  id: string;
  name: string;
  permissions: string[];
}

const RoleManagement: React.FC = () => {
  const [selectedRole, setSelectedRole] = useState<Role | null>(null);
  const [isDialogOpen, setIsDialogOpen] = useState(false);

  useEffect(() => {
    // Fetch roles from API
    // setRoles(fetchedRoles);
  }, []);

  const handleEditRole = (role: Role) => {
    setSelectedRole(role);
    setIsDialogOpen(true);
  };

  const handleCloseDialog = () => {
    setSelectedRole(null);
    setIsDialogOpen(false);
  };

  const handleUpdateRole = () => {
    // Implement role update logic here
    handleCloseDialog();
  };

  const handleAddRole = () => {
    setSelectedRole({ id: '', name: '', permissions: [] });
    setIsDialogOpen(true);
  };

  return (
    <Box>
      <Typography variant="h5">Role Management</Typography>
      <List>
        {roles.map((role) => (
          <ListItem key={role.id}>
            <ListItemText
              primary={role.name}
              secondary={`Permissions: ${role.permissions.join(', ')}`}
            />
            <Button onClick={() => handleEditRole(role)}>Edit</Button>
          </ListItem>
        ))}
      </List>
      <Button variant="contained" color="primary" onClick={handleAddRole}>
        Add New Role
      </Button>
      <Dialog open={isDialogOpen} onClose={handleCloseDialog}>
        <DialogTitle>
          {selectedRole?.id ? 'Edit Role' : 'Add New Role'}
        </DialogTitle>
        <DialogContent>
          <TextField
            autoFocus
            margin="dense"
            label="Role Name"
            type="text"
            fullWidth
            value={selectedRole?.name || ''}
            onChange={(e) =>
              setSelectedRole({ ...selectedRole!, name: e.target.value })
            }
          />
          <Typography variant="subtitle1">Permissions:</Typography>
          {/* Add checkboxes for permissions */}
          <FormControlLabel
            control={
              <Checkbox
                checked={selectedRole?.permissions.includes('read') || false}
                onChange={(e) => {
                  const newPermissions = e.target.checked
                    ? [...selectedRole!.permissions, 'read']
                    : selectedRole!.permissions.filter((p) => p !== 'read');
                  setSelectedRole({
                    ...selectedRole!,
                    permissions: newPermissions,
                  });
                }}
              />
            }
            label="Read"
          />
          {/* Add more permission checkboxes as needed */}
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseDialog}>Cancel</Button>
          <Button onClick={handleUpdateRole} color="primary">
            {selectedRole?.id ? 'Update' : 'Add'}
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default RoleManagement;

================
File: components/SalesByCategoryChart.tsx
================
import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { Typography, Box, Paper } from '@mui/material';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import {
  PieChart,
  Pie,
  Cell,
  ResponsiveContainer,
  Legend,
  Tooltip,
} from 'recharts';
import { format } from 'date-fns';
import { useDispatch, useSelector } from 'react-redux';
import { fetchSalesByCategory } from '../redux/slices/analyticsSlice';
import { AppDispatch, RootState } from '../redux/store';
import { SalesByCategory } from '../types/analyticsTypes';

const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042', '#8884D8'];

const SalesByCategoryChart: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { salesByCategory, loading, error } = useSelector((state: RootState) => state.analytics);
  const [dateRange, setDateRange] = useState<[Date | null, Date | null]>([
    new Date(new Date().setDate(new Date().getDate() - 30)),
    new Date(),
  ]);

  const fetchSalesData = useCallback(() => {
    const [startDate, endDate] = dateRange;
    if (startDate && endDate) {
      const formattedStartDate = format(startDate, 'yyyy-MM-dd');
      const formattedEndDate = format(endDate, 'yyyy-MM-dd');
      dispatch(fetchSalesByCategory({ startDate: formattedStartDate, endDate: formattedEndDate }));
    }
  }, [dateRange, dispatch]);

  useEffect(() => {
    fetchSalesData();
  }, [fetchSalesData]);

  const chartData = useMemo(() => {
    return salesByCategory.map((item: SalesByCategory) => ({
      name: item.category,
      value: item.sales,
    }));
  }, [salesByCategory]);

  if (loading) return <Typography>Loading sales data...</Typography>;
  if (error) return <Typography color="error">{error}</Typography>;

  return (
    <Paper elevation={3}>
      <Box p={3}>
        <Typography variant="h5" gutterBottom>
          Sales by Category
        </Typography>
        <LocalizationProvider dateAdapter={AdapterDateFns}>
          <Box display="flex" justifyContent="space-between" mb={2}>
            <DatePicker
              label="Start Date"
              value={dateRange[0]}
              onChange={(newValue: Date | null) => setDateRange([newValue, dateRange[1]])}
            />
            <DatePicker
              label="End Date"
              value={dateRange[1]}
              onChange={(newValue: Date | null) => setDateRange([dateRange[0], newValue])}
            />
          </Box>
        </LocalizationProvider>
        <ResponsiveContainer width="100%" height={400}>
          <PieChart>
            <Pie
              data={chartData}
              cx="50%"
              cy="50%"
              labelLine={false}
              outerRadius={80}
              fill="#8884d8"
              dataKey="value"
            >
              {chartData.map((entry: any, index: number) => (
                <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
              ))}
            </Pie>
            <Tooltip />
            <Legend />
          </PieChart>
        </ResponsiveContainer>
      </Box>
    </Paper>
  );
};

export default SalesByCategoryChart;

================
File: components/ServiceFeeBuilder.tsx
================
import React, { useState, useEffect } from 'react';
import { TextField, Button, Typography, Box, Paper, Select, MenuItem, FormControl, InputLabel } from '@mui/material';
import { useDispatch, useSelector } from 'react-redux';
import { fetchServiceFees, createServiceFee } from '../redux/slices/serviceFeeSlice';
import { ServiceFee } from '../types/serviceFeeTypes';
import { AppDispatch, RootState } from '../redux/store';

const ServiceFeeBuilder: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { serviceFees, loading, error } = useSelector((state: RootState) => state.serviceFee);
  const [newFee, setNewFee] = useState<Omit<ServiceFee, 'id'>>({
    name: '',
    amount: 0,
    type: 'FIXED',
    clientId: '',
  });

  useEffect(() => {
    dispatch(fetchServiceFees());
  }, [dispatch]);

  const handleInputChange = (event: React.ChangeEvent<HTMLInputElement | { name?: string; value: unknown }>) => {
    const { name, value } = event.target;
    setNewFee((prev) => ({
      ...prev,
      [name as string]: name === 'amount' ? parseFloat(value as string) : value,
    }));
  };

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    try {
      await dispatch(createServiceFee(newFee));
      setNewFee({ name: '', amount: 0, type: 'FIXED', clientId: '' });
    } catch (error) {
      console.error('Failed to create service fee:', error);
    }
  };

  if (loading) {
    return <Typography>Loading service fees...</Typography>;
  }

  if (error) {
    return <Typography color="error">{error}</Typography>;
  }

  return (
    <Paper elevation={3}>
      <Box p={3}>
        <Typography variant="h5" gutterBottom>
          Service Fee Builder
        </Typography>
        <form onSubmit={handleSubmit}>
          <TextField
            name="name"
            label="Fee Name"
            value={newFee.name}
            onChange={handleInputChange}
            fullWidth
            margin="normal"
            required
          />
          <TextField
            name="amount"
            label="Fee Amount"
            type="number"
            value={newFee.amount}
            onChange={handleInputChange}
            fullWidth
            margin="normal"
            required
          />
          <FormControl fullWidth margin="normal">
            <InputLabel id="fee-type-label">Fee Type</InputLabel>
            <Select
              labelId="fee-type-label"
              name="type"
              value={newFee.type}
              onChange={handleInputChange}
              required
            >
              <MenuItem value="FIXED">Fixed</MenuItem>
              <MenuItem value="PERCENTAGE">Percentage</MenuItem>
            </Select>
          </FormControl>
          <TextField
            name="clientId"
            label="Client ID"
            value={newFee.clientId}
            onChange={handleInputChange}
            fullWidth
            margin="normal"
            required
          />
          <Button type="submit" variant="contained" color="primary">
            Add Service Fee
          </Button>
        </form>
        <Typography variant="h6" gutterBottom sx={{ mt: 4 }}>
          Existing Service Fees
        </Typography>
        {serviceFees.map((fee) => (
          <Box key={fee.id} sx={{ mb: 2 }}>
            <Typography>
              {fee.name}: {fee.amount} ({fee.type}) - Client ID: {fee.clientId}
            </Typography>
          </Box>
        ))}
      </Box>
    </Paper>
  );
};

export default ServiceFeeBuilder;

================
File: components/ServiceFeeManager.tsx
================
import React, { useState } from 'react';
import { useDispatch } from 'react-redux';
import {
  addServiceFee,
  updateServiceFee,
} from '../redux/slices/serviceFeeSlice';
import { AppDispatch } from '../redux/store';
import { ServiceFee } from '../types';

const ServiceFeeManager: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const [feeName, setFeeName] = useState('');
  const [feeAmount, setFeeAmount] = useState<number | string>('');

  const handleAddFee = () => {
    if (feeName && feeAmount) {
      const newFee: Omit<ServiceFee, 'id'> = {
        name: feeName,
        amount: Number(feeAmount),
        value: Number(feeAmount),
      };
      dispatch(addServiceFee(newFee));
      setFeeName('');
      setFeeAmount('');
    }
  };

  const handleUpdateFee = (id: number) => {
    if (feeAmount) {
      dispatch(
        updateServiceFee({
          id,
          amount: Number(feeAmount),
          value: Number(feeAmount),
        })
      );
      setFeeAmount('');
    }
  };

  return (
    <div>
      <h2>Manage Service Fees</h2>
      <input
        type="text"
        placeholder="Fee Name"
        value={feeName}
        onChange={(e) => setFeeName(e.target.value)}
      />
      <input
        type="number"
        placeholder="Fee Amount"
        value={feeAmount}
        onChange={(e) => setFeeAmount(e.target.value)}
      />
      <button onClick={handleAddFee}>Add Service Fee</button>
      <button onClick={() => handleUpdateFee(1)}>Update Fee</button>
    </div>
  );
};

export default ServiceFeeManager;

================
File: components/SettingsManager.tsx
================
import React, { useState, useEffect, useMemo } from 'react';
import { TextField, Button, Typography, Box } from '@mui/material';
import { SettingsService } from '../../services/SettingsService';
import { useAuth } from '../../contexts/AuthContext';
import { Settings } from '../types/settingsTypes';
import { fetchSettings, updateSettings } from '../api/settingsApi';

const SettingsManager: React.FC = () => {
  const [settings, setSettings] = useState<Settings | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const { user } = useAuth();

  const settingsService = useMemo(() => new SettingsService(), []);

  useEffect(() => {
    const fetchSettings = async () => {
      try {
        setIsLoading(true);
        const fetchedSettings = await settingsService.getSettings(
          user.clientId
        );
        setSettings(fetchedSettings);
        setError(null);
      } catch (err) {
        setError('Failed to fetch settings');
        console.error(err);
      } finally {
        setIsLoading(false);
      }
    };

    fetchSettings();
  }, [settingsService, user.clientId]);

  const handleSettingChange = (
    key: keyof Settings,
    value: string | number | boolean
  ) => {
    if (settings) {
      setSettings({ ...settings, [key]: value });
    }
  };

  const handleSaveSettings = async () => {
    if (settings) {
      try {
        await settingsService.updateSettings(user.clientId, settings);
        setError(null);
      } catch (err) {
        setError('Failed to save settings');
        console.error(err);
      }
    }
  };

  if (isLoading) return <Typography>Loading settings...</Typography>;
  if (error) return <Typography color="error">{error}</Typography>;
  if (!settings) return <Typography>No settings found</Typography>;

  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Settings Manager
      </Typography>
      {Object.entries(settings).map(([key, value]) => (
        <TextField
          key={key}
          label={key}
          value={value}
          onChange={(e) =>
            handleSettingChange(key as keyof Settings, e.target.value)
          }
          fullWidth
          margin="normal"
        />
      ))}
      <Button variant="contained" color="primary" onClick={handleSaveSettings}>
        Save Settings
      </Button>
    </Box>
  );
};

export default SettingsManager;

================
File: components/StaffScheduler.tsx
================
import React from 'react';

const StaffScheduler: React.FC = () => {
  return (
    <div className="staff-scheduler">
      <h4>Staff Scheduler</h4>
      <p>Staff scheduling functionality to be implemented.</p>
    </div>
  );
};

export default StaffScheduler;

================
File: components/SubmitReview.tsx
================
import React, { useState } from 'react';
import { useDispatch } from 'react-redux';
import { AppDispatch } from '../redux/store';
import { createReview } from '../api/reviewApi';
import { fetchReviewsForMenuItem } from '../redux/slices/reviewSlice';
import { TextField, Button, Rating, Box, Typography } from '@mui/material';

interface SubmitReviewProps {
  menuItemId: number;
}

const SubmitReview: React.FC<SubmitReviewProps> = ({ menuItemId }) => {
  const dispatch = useDispatch<AppDispatch>();
  const [firstName, setFirstName] = useState('');
  const [lastInitial, setLastInitial] = useState('');
  const [rating, setRating] = useState<number | null>(null);
  const [comment, setComment] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (rating === null) return;

    try {
      await createReview({
        menuItemId,
        firstName,
        lastInitial,
        rating,
        comment,
      });
      dispatch(fetchReviewsForMenuItem(menuItemId));
      // Reset form
      setFirstName('');
      setLastInitial('');
      setRating(null);
      setComment('');
    } catch (error) {
      console.error('Error submitting review:', error);
    }
  };

  return (
    <Box component="form" onSubmit={handleSubmit}>
      <Typography variant="h6">Submit a Review</Typography>
      <TextField
        label="First Name"
        value={firstName}
        onChange={(e) => setFirstName(e.target.value)}
        required
        fullWidth
        margin="normal"
      />
      <TextField
        label="Last Initial"
        value={lastInitial}
        onChange={(e) => setLastInitial(e.target.value)}
        required
        fullWidth
        margin="normal"
      />
      <Box my={2}>
        <Typography component="legend">Rating</Typography>
        <Rating
          name="rating"
          value={rating}
          onChange={(_, newValue) => setRating(newValue)}
        />
      </Box>
      <TextField
        label="Comment"
        value={comment}
        onChange={(e) => setComment(e.target.value)}
        multiline
        rows={4}
        fullWidth
        margin="normal"
      />
      <Button type="submit" variant="contained" color="primary">
        Submit Review
      </Button>
    </Box>
  );
};

export default SubmitReview;

================
File: components/ThemeProvider.tsx
================
import React from 'react';
import { ThemeProvider as EmotionThemeProvider } from '@emotion/react';
import { createTheme, Theme } from '@mui/material/styles';

const theme: Theme = createTheme({
  palette: {
    primary: {
      main: '#0070f3',
    },
    secondary: {
      main: '#ff4081',
    },
  },
  typography: {
    fontFamily: 'Arial, sans-serif',
  },
});

const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => <EmotionThemeProvider theme={theme}>{children}</EmotionThemeProvider>;

export default ThemeProvider;

================
File: components/TopSellingItemsChart.tsx
================
import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { Typography, Box } from '@mui/material';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  Tooltip,
  ResponsiveContainer,
} from 'recharts';
import { format } from 'date-fns';
import { TopSellingItem } from '../types/analyticsTypes';
import { AnalyticsService } from '../services/AnalyticsService';
import { fetchTopSellingItems } from '../api/analyticsApi';

const TopSellingItemsChart: React.FC = () => {
  const [topSellingItems, setTopSellingItems] = useState<TopSellingItem[]>([]);
  const [dateRange, setDateRange] = useState<[Date | null, Date | null]>([
    null,
    null,
  ]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const analyticsService = useMemo(() => new AnalyticsService(), []);

  const fetchTopSellingItems = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      const [startDate, endDate] = dateRange;
      const formattedStartDate = startDate
        ? format(startDate, 'yyyy-MM-dd')
        : undefined;
      const formattedEndDate = endDate
        ? format(endDate, 'yyyy-MM-dd')
        : undefined;
      const items = await analyticsService.getTopSellingItems(
        formattedStartDate,
        formattedEndDate
      );
      setTopSellingItems(items);
    } catch (err) {
      setError('Failed to fetch top selling items');
      console.error(err);
    } finally {
      setIsLoading(false);
    }
  }, [dateRange, analyticsService]);

  useEffect(() => {
    fetchTopSellingItems();
  }, [fetchTopSellingItems]);

  if (isLoading) return <Typography>Loading top selling items...</Typography>;
  if (error) return <Typography color="error">{error}</Typography>;

  return (
    <Box>
      <Typography variant="h6" gutterBottom>
        Top Selling Items
      </Typography>
      <LocalizationProvider dateAdapter={AdapterDateFns}>
        <Box display="flex" justifyContent="space-between" mb={2}>
          <DatePicker
            label="Start Date"
            value={dateRange[0]}
            onChange={(newValue: Date | null) =>
              setDateRange([newValue, dateRange[1]])
            }
          />
          <DatePicker
            label="End Date"
            value={dateRange[1]}
            onChange={(newValue: Date | null) =>
              setDateRange([dateRange[0], newValue])
            }
          />
        </Box>
      </LocalizationProvider>
      <ResponsiveContainer width="100%" height={300}>
        <BarChart data={topSellingItems}>
          <XAxis dataKey="name" />
          <YAxis />
          <Tooltip />
          <Bar dataKey="quantity" fill="#8884d8" />
        </BarChart>
      </ResponsiveContainer>
    </Box>
  );
};

export default TopSellingItemsChart;

================
File: components/UserManager.tsx
================
import React, { useEffect, useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import { fetchUsers, updateUser } from 'frontend/src/api/userApi';
import {
  Box,
  Typography,
  List,
  ListItem,
  ListItemText,
  Button,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Select,
  MenuItem,
} from '@mui/material';

interface User {
  id: string;
  name: string;
  email: string;
  role: string;
  clientId?: string;
}

const UserManager: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const users = useSelector((state: RootState) => state.users.users);
  const [selectedUser, setSelectedUser] = useState<User | null>(null);
  const [isDialogOpen, setIsDialogOpen] = useState(false);

  useEffect(() => {
    dispatch(fetchUsers());
  }, [dispatch]);

  const handleEditUser = (user: User) => {
    setSelectedUser(user);
    setIsDialogOpen(true);
  };

  const handleCloseDialog = () => {
    setSelectedUser(null);
    setIsDialogOpen(false);
  };

  const handleUpdateUser = () => {
    // Implement user update logic here
    handleCloseDialog();
  };

  const handleAddUser = () => {
    setSelectedUser({ id: '', name: '', email: '', role: '' });
    setIsDialogOpen(true);
  };

  return (
    <Box>
      <Typography variant="h5">User Manager</Typography>
      <List>
        {users.map((user) => (
          <ListItem key={user.id}>
            <ListItemText primary={user.name} secondary={user.email} />
            <Button onClick={() => handleEditUser(user)}>Edit</Button>
          </ListItem>
        ))}
      </List>
      <Button variant="contained" color="primary" onClick={handleAddUser}>
        Add New User
      </Button>
      <Dialog open={isDialogOpen} onClose={handleCloseDialog}>
        <DialogTitle>
          {selectedUser?.id ? 'Edit User' : 'Add New User'}
        </DialogTitle>
        <DialogContent>
          <TextField
            autoFocus
            margin="dense"
            label="Name"
            type="text"
            fullWidth
            value={selectedUser?.name || ''}
            onChange={(e) =>
              setSelectedUser({ ...selectedUser!, name: e.target.value })
            }
          />
          <TextField
            margin="dense"
            label="Email"
            type="email"
            fullWidth
            value={selectedUser?.email || ''}
            onChange={(e) =>
              setSelectedUser({ ...selectedUser!, email: e.target.value })
            }
          />
          <Select
            margin="dense"
            fullWidth
            value={selectedUser?.role || ''}
            onChange={(e) =>
              setSelectedUser({ ...selectedUser!, role: e.target.value })
            }
          >
            <MenuItem value="admin">Admin</MenuItem>
            <MenuItem value="user">User</MenuItem>
          </Select>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseDialog}>Cancel</Button>
          <Button onClick={handleUpdateUser} color="primary">
            {selectedUser?.id ? 'Update' : 'Add'}
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default UserManager;

================
File: components/WalletDrop.tsx
================
import React, { useState } from 'react';
import { TextField, Button, Typography, Box } from '@mui/material';
import { WalletDropService } from '../services/WalletDropService';
import { WalletDrop as WalletDropType } from '../types/walletTypes';
import { fetchWalletDrops } from 'frontend/src/api/walletDropApi';

const WalletDrop: React.FC = () => {
  const [walletDrop, setWalletDrop] = useState<WalletDropType>({
    amount: 0,
    expirationDate: '',
    description: '',
  });
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);

  const walletDropService = new WalletDropService();

  const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = event.target;
    setWalletDrop((prev) => ({ ...prev, [name]: value }));
  };

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    setError(null);
    setSuccess(null);

    try {
      await walletDropService.createWalletDrop(walletDrop);
      setSuccess('Wallet drop created successfully');
      setWalletDrop({ amount: 0, expirationDate: '', description: '' });
    } catch (err) {
      setError('Failed to create wallet drop');
      console.error(err);
    }
  };

  return (
    <Box component="form" onSubmit={handleSubmit}>
      <Typography variant="h6" gutterBottom>
        Create Wallet Drop
      </Typography>
      <TextField
        name="amount"
        label="Amount"
        type="number"
        value={walletDrop.amount}
        onChange={handleInputChange}
        fullWidth
        margin="normal"
        required
      />
      <TextField
        name="expirationDate"
        label="Expiration Date"
        type="date"
        value={walletDrop.expirationDate}
        onChange={handleInputChange}
        fullWidth
        margin="normal"
        required
        InputLabelProps={{ shrink: true }}
      />
      <TextField
        name="description"
        label="Description"
        value={walletDrop.description}
        onChange={handleInputChange}
        fullWidth
        margin="normal"
        multiline
        rows={4}
      />
      <Button type="submit" variant="contained" color="primary">
        Create Wallet Drop
      </Button>
      {error && <Typography color="error">{error}</Typography>}
      {success && <Typography color="success">{success}</Typography>}
    </Box>
  );
};

export default WalletDrop;

================
File: context/AuthContext.tsx
================
import React, { createContext, useContext, useState, useEffect } from 'react';
import { login, logout } from 'frontend/src/api/authApi';

interface User {
  id: string;
  email: string;
  // Add other user properties as needed
}

interface AuthContextType {
  isAuthenticated: boolean;
  user: User | null;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [isAuthenticated, setIsAuthenticated] = useState<boolean>(false);
  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    const token = localStorage.getItem('token');
    if (token) {
      setIsAuthenticated(true);
      // Optionally fetch user data here
    }
  }, []);

  const login = async (email: string, password: string) => {
    try {
      const response = await api.post('/auth/login', { email, password });
      const { token, user } = response.data;
      localStorage.setItem('token', token);
      setIsAuthenticated(true);
      setUser(user);
    } catch (error) {
      console.error('Login failed:', error);
      throw error;
    }
  };

  const logout = () => {
    localStorage.removeItem('token');
    setIsAuthenticated(false);
    setUser(null);
  };

  return (
    <AuthContext.Provider value={{ isAuthenticated, user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

================
File: context/CartContext.tsx
================
import React, { createContext, useState, useContext, ReactNode } from 'react';

interface CartItem {
  id: string;
  name: string;
  price: number;
  quantity: number;
  // Add other properties as needed
}

interface CartContextType {
  cartItems: CartItem[];
  addToCart: (item: CartItem) => void;
  removeFromCart: (itemId: string) => void;
  clearCart: () => void;
}

const CartContext = createContext<CartContextType | undefined>(undefined);

export const CartProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [cartItems, setCartItems] = useState<CartItem[]>([]);

  const addToCart = (item: CartItem) => {
    setCartItems((prevItems) => [...prevItems, item]);
  };

  const removeFromCart = (itemId: string) => {
    setCartItems((prevItems) => prevItems.filter((item) => item.id !== itemId));
  };

  const clearCart = () => {
    setCartItems([]);
  };

  return (
    <CartContext.Provider value={{ cartItems, addToCart, removeFromCart, clearCart }}>
      {children}
    </CartContext.Provider>
  );
};

export const useCart = (): CartContextType => {
  const context = useContext(CartContext);
  if (!context) {
    throw new Error('useCart must be used within a CartProvider');
  }
  return context;
};

================
File: context/ClientContext.tsx
================
import React, {
  createContext,
  useContext,
  useState,
  useEffect,
  ReactNode,
} from 'react';
import { getSubdomain } from '../utils/subdomain';
import { fetchClientBySubdomain } from '../api/clientApi';

interface Client {
  id: number;
  name: string;
  // Add other client properties
}

interface ClientContextType {
  client: Client | null;
  clientId: number | null;
  subdomain: string | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;
  setClientId: (id: number | null) => void;
  setIsAuthenticated: (value: boolean) => void;
}

const ClientContext = createContext<ClientContextType | undefined>(undefined);

export const ClientProvider: React.FC<{ children: ReactNode }> = ({
  children,
}) => {
  const [client, setClient] = useState<Client | null>(null);
  const [subdomain, setSubdomain] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [clientId, setClientId] = useState<number | null>(null);
  const [isAuthenticated, setIsAuthenticated] = useState(false);

  useEffect(() => {
    const loadClient = async () => {
      const detectedSubdomain = getSubdomain();
      setSubdomain(detectedSubdomain);

      if (detectedSubdomain) {
        try {
          const clientData = await fetchClientBySubdomain(detectedSubdomain);
          setClient(clientData);
          setClientId(clientData.id); // Set clientId here
        } catch (err) {
          setError('Failed to load client data');
          console.error(err);
        }
      } else {
        setError('Invalid subdomain');
      }
      setIsLoading(false);
    };

    loadClient();
  }, []);

  return (
    <ClientContext.Provider
      value={{
        client,
        clientId,
        subdomain,
        isAuthenticated,
        isLoading,
        error,
        setClientId,
        setIsAuthenticated,
      }}
    >
      {children}
    </ClientContext.Provider>
  );
};

export const useClientContext = () => {
  const context = useContext(ClientContext);
  if (context === undefined) {
    throw new Error('useClientContext must be used within a ClientProvider');
  }
  return context;
};

================
File: context/SocketContext.tsx
================
import React, { createContext, useContext, useEffect, useState } from 'react';
import io, { Socket } from 'socket.io-client';

const SocketContext = createContext<Socket | null>(null);

export const useSocket = () => useContext(SocketContext);

export const SocketProvider: React.FC = ({ children }) => {
  const [socket, setSocket] = useState<Socket | null>(null);

  useEffect(() => {
    const newSocket = io('http://localhost:3000');
    setSocket(newSocket);

    return () => {
      newSocket.close();
    };
  }, []);

  return (
    <SocketContext.Provider value={socket}>{children}</SocketContext.Provider>
  );
};

================
File: features/menuSlice.ts
================
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import axios from '../api/axios';

export const fetchMenuItems = createAsyncThunk(
  'menu/fetchMenuItems',
  async () => {
    const response = await axios.get('/menu/items');
    return response.data;
  }
);

interface MenuItem {
  id: number;
  name: string;
  price: number;
}

export interface MenuState {
  items: MenuItem[];
  status: 'idle' | 'loading' | 'succeeded' | 'failed';
  error: string | null;
}

const initialState: MenuState = {
  items: [],
  status: 'idle',
  error: null,
};

const menuSlice = createSlice({
  name: 'menu',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchMenuItems.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchMenuItems.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.items = action.payload;
      })
      .addCase(fetchMenuItems.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.error.message || null;
      });
  },
});

export default menuSlice.reducer;

================
File: features/ordersSlice.ts
================
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import axios from 'axios';

interface Order {
  id: number;
  items: Array<{
    id: number;
    name: string;
    quantity: number;
    price: number;
  }>;
  total: number;
  status: string;
}

interface OrdersState {
  orders: Order[];
  status: 'idle' | 'loading' | 'succeeded' | 'failed';
  error: string | null;
}

const initialState: OrdersState = {
  orders: [],
  status: 'idle',
  error: null,
};

export const fetchOrders = createAsyncThunk('orders/fetchOrders', async () => {
  const response = await axios.get<Order[]>('/api/orders');
  return response.data;
});

const ordersSlice = createSlice({
  name: 'orders',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchOrders.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(
        fetchOrders.fulfilled,
        (state, action: PayloadAction<Order[]>) => {
          state.status = 'succeeded';
          state.orders = action.payload;
        }
      )
      .addCase(fetchOrders.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.error.message || null;
      });
  },
});

export default ordersSlice.reducer;

================
File: features/rolesSlice.ts
================
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import axios from 'axios';

interface Role {
  id: number;
  name: string;
}

interface RolesState {
  roles: Role[];
  status: 'idle' | 'loading' | 'succeeded' | 'failed';
  error: string | null;
}

const initialState: RolesState = {
  roles: [],
  status: 'idle',
  error: null,
};

export const fetchRoles = createAsyncThunk('roles/fetchRoles', async () => {
  const response = await axios.get('/api/roles');
  return response.data;
});

const rolesSlice = createSlice({
  name: 'roles',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchRoles.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchRoles.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.roles = action.payload;
      })
      .addCase(fetchRoles.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.error.message || null;
      });
  },
});

export default rolesSlice.reducer;

================
File: hooks/useAuth.ts
================
import { useSelector } from 'react-redux';
import { RootState } from '../redux/store';

export const useAuth = () => {
  const user = useSelector((state: RootState) => state.auth.user);
  const isGlobalAdmin = user?.role === 'GLOBAL_ADMIN';
  const authToken = useSelector((state: RootState) => state.auth.token);

  return { user, isGlobalAdmin, authToken };
};

================
File: hooks/useClientBranding.ts
================
import { useSelector } from 'react-redux';
import { RootState } from '../redux/store';

export const useClientBranding = () => {
  return useSelector((state: RootState) => state.clientBranding.branding);
};

================
File: hooks/useLazyImage.ts
================
import { useState, useEffect } from 'react';

export const useLazyImage = (src: string, placeholder: string) => {
  const [imageSrc, setImageSrc] = useState(placeholder);

  useEffect(() => {
    const img = new Image();
    img.src = src;
    img.onload = () => {
      setImageSrc(src);
    };
  }, [src]);

  return imageSrc;
};

================
File: hooks/useQuery.ts
================
import { useState, useEffect } from 'react';
import axiosInstance from '../api/axios';

interface QueryResult<T> {
  data: T | null;
  isLoading: boolean;
  error: Error | null;
}

export function useQuery<T>(url: string): QueryResult<T> {
  const [data, setData] = useState<T | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    let isMounted = true;

    const fetchData = async () => {
      try {
        const response = await axiosInstance.get<T>(url);
        if (isMounted) {
          setData(response.data);
          setIsLoading(false);
        }
      } catch (error) {
        if (isMounted) {
          setError(error as Error);
          setIsLoading(false);
        }
      }
    };

    fetchData();

    return () => {
      isMounted = false;
    };
  }, [url]);

  return { data, isLoading, error };
}

================
File: hooks/useQueryWithCache.ts
================
import { useQuery, QueryKey, UseQueryOptions } from 'react-query';
import axiosInstance from '../api/axios';

export function useQueryWithCache<T>(
  queryKey: QueryKey,
  url: string,
  options?: UseQueryOptions<T, Error>
) {
  return useQuery<T, Error>(
    queryKey,
    async () => {
      const { data } = await axiosInstance.get<T>(url);
      return data;
    },
    {
      staleTime: 5 * 60 * 1000, // 5 minutes
      cacheTime: 10 * 60 * 1000, // 10 minutes
      ...options,
    }
  );
}

================
File: hooks/useSelectedLocation.ts
================
import { useSelector } from 'react-redux';
import { RootState } from '../redux/store';

export const useSelectedLocation = () => {
  const selectedLocation = useSelector((state: RootState) => state.location.selectedLocation);
  return { selectedLocation };
};

================
File: pages/ABTestManagement.tsx
================
import React, { useEffect, useState } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import {
  fetchABTestsAsync,
  createABTestAsync,
  updateABTestAsync,
  deleteABTestAsync,
} from '../redux/slices/abTestSlice';
import { fetchClientsAsync } from '../redux/slices/clientSlice';
import { fetchLocationsAsync } from '../redux/slices/locationSlice';
import { ABTest } from '../types/abTestTypes';
import { Client } from '../types/clientTypes';
import { Location } from '../types/locationTypes';
import {
  TextField,
  Button,
  List,
  ListItem,
  IconButton,
  Typography,
  Box,
  Switch,
  Select,
  MenuItem,
} from '@mui/material';
import DeleteIcon from '@mui/icons-material/Delete';

const ABTestManagement: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { tests, status, error } = useSelector(
    (state: RootState) => state.abTest
  );
  const clients = useSelector((state: RootState) => state.client.clients);
  const locations = useSelector((state: RootState) => state.location.locations);
  const [newTest, setNewTest] = useState<Partial<ABTest>>({
    name: '',
    description: '',
    variantA: '',
    variantB: '',
    isActive: false,
    clientId: 0,
    locationId: 0,
  });

  useEffect(() => {
    dispatch(fetchABTestsAsync());
    dispatch(fetchClientsAsync());
    dispatch(fetchLocationsAsync());
  }, [dispatch]);

  const handleCreateTest = () => {
    dispatch(createABTestAsync(newTest as ABTest));
    setNewTest({
      name: '',
      description: '',
      variantA: '',
      variantB: '',
      isActive: false,
      clientId: 0,
      locationId: 0,
    });
  };

  const handleUpdateTest = (test: ABTest) => {
    dispatch(updateABTestAsync(test));
  };

  const handleDeleteTest = (id: number) => {
    if (window.confirm('Are you sure you want to delete this AB test?')) {
      dispatch(deleteABTestAsync(id));
    }
  };

  if (status === 'loading') return <Typography>Loading...</Typography>;
  if (status === 'failed') return <Typography>Error: {error}</Typography>;

  return (
    <Box sx={{ padding: 3 }}>
      <Typography variant="h4" gutterBottom>
        AB Test Management
      </Typography>
      <Box sx={{ marginBottom: 2 }}>
        <TextField
          label="Test Name"
          value={newTest.name}
          onChange={(e) => setNewTest({ ...newTest, name: e.target.value })}
          sx={{ marginRight: 1 }}
        />
        <TextField
          label="Description"
          value={newTest.description}
          onChange={(e) => setNewTest({ ...newTest, description: e.target.value })}
          sx={{ marginRight: 1 }}
        />
        <TextField
          label="Variant A"
          value={newTest.variantA}
          onChange={(e) => setNewTest({ ...newTest, variantA: e.target.value })}
          sx={{ marginRight: 1 }}
        />
        <TextField
          label="Variant B"
          value={newTest.variantB}
          onChange={(e) => setNewTest({ ...newTest, variantB: e.target.value })}
          sx={{ marginRight: 1 }}
        />
        <Select
          value={newTest.clientId}
          onChange={(e) => setNewTest({ ...newTest, clientId: e.target.value as number })}
          sx={{ marginRight: 1 }}
        >
          {clients.map((client: Client) => (
            <MenuItem key={client.id} value={client.id}>
              {client.name}
            </MenuItem>
          ))}
        </Select>
        <Select
          value={newTest.locationId}
          onChange={(e) => setNewTest({ ...newTest, locationId: e.target.value as number })}
          sx={{ marginRight: 1 }}
        >
          {locations.map((location: Location) => (
            <MenuItem key={location.id} value={location.id}>
              {location.name}
            </MenuItem>
          ))}
        </Select>
        <Switch
          checked={newTest.isActive}
          onChange={(e) => setNewTest({ ...newTest, isActive: e.target.checked })}
        />
        <Button variant="contained" onClick={handleCreateTest}>
          Create Test
        </Button>
      </Box>
      <List>
        {tests.map((test: ABTest) => (
          <ListItem key={test.id}>
            <TextField
              value={test.name}
              onChange={(e) => handleUpdateTest({ ...test, name: e.target.value })}
            />
            <TextField
              value={test.description}
              onChange={(e) => handleUpdateTest({ ...test, description: e.target.value })}
            />
            <TextField
              value={test.variantA}
              onChange={(e) => handleUpdateTest({ ...test, variantA: e.target.value })}
            />
            <TextField
              value={test.variantB}
              onChange={(e) => handleUpdateTest({ ...test, variantB: e.target.value })}
            />
            <Switch
              checked={test.isActive}
              onChange={(e) => handleUpdateTest({ ...test, isActive: e.target.checked })}
            />
            <IconButton onClick={() => handleDeleteTest(test.id)}>
              <DeleteIcon />
            </IconButton>
          </ListItem>
        ))}
      </List>
    </Box>
  );
};

export default ABTestManagement;

================
File: pages/AdminDashboard.tsx
================
import React from 'react';
import ClientBrandingManager from '../components/ClientBrandingManager';
import POSSettingsForm from '../components/POSSettingsForm';
// ... other imports ...

const AdminDashboard: React.FC = () => {
  return (
    <div className="admin-dashboard">
      <h1>Admin Dashboard</h1>
      <section>
        <h2>Client Branding</h2>
        <ClientBrandingManager />
      </section>
      <section>
        <h2>POS Settings</h2>
        <POSSettingsForm />
      </section>
      {/* ... other admin components ... */}
    </div>
  );
};

export default AdminDashboard;

================
File: pages/AdminDiscounts.tsx
================
import React, { useEffect, useState } from 'react';
import {
  createDiscount,
  fetchDiscountsByLocation,
  updateDiscount,
  deleteDiscount,
  scheduleDiscountDrop,
} from '../api/discountApi';
import { Discount } from '../types';

const AdminDiscounts: React.FC = () => {
  const [discounts, setDiscounts] = useState<Discount[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    loadDiscounts();
  }, []);

  const loadDiscounts = async () => {
    try {
      setLoading(true);
      const data = await fetchDiscountsByLocation(1);
      setDiscounts(data);
    } catch (err) {
      setError('Failed to load discounts.');
    } finally {
      setLoading(false);
    }
  };

  const handleCreateDiscount = async () => {
    try {
      const newDiscount = {
        name: 'New Discount',
        value: 10,
        type: 'percentage',
        expirationDate: new Date().toISOString(),
        locationId: 1,
        conditions: {},
        startDate: new Date().toISOString(),
        endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),
      };
      await createDiscount(newDiscount);
      loadDiscounts();
    } catch (err) {
      setError('Failed to create discount.');
    }
  };

  const handleUpdateDiscount = async (discountId: number) => {
    try {
      const updatedDiscount = {
        name: 'Updated Discount',
        value: 15,
      };
      await updateDiscount(discountId, updatedDiscount);
      loadDiscounts();
    } catch (err) {
      setError('Failed to update discount.');
    }
  };

  const handleDeleteDiscount = async (discountId: number) => {
    try {
      await deleteDiscount(discountId);
      loadDiscounts();
    } catch (err) {
      setError('Failed to delete discount.');
    }
  };

  const handleScheduleDiscountDrop = async () => {
    try {
      const scheduleData = {
        startDate: new Date().toISOString(),
        endDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),
        recurrence: 'daily' as const,
        discountId: discounts[0]?.id ? Number(discounts[0].id) : 0,
      };
      await scheduleDiscountDrop(scheduleData);
      loadDiscounts();
    } catch (err) {
      setError('Failed to schedule discount drop.');
    }
  };

  return (
    <div>
      <h2>Discount Management</h2>
      {loading && <p>Loading...</p>}
      {error && <p>{error}</p>}
      <button onClick={handleCreateDiscount}>Create Discount</button>
      <button onClick={handleScheduleDiscountDrop}>
        Schedule Discount Drop
      </button>
      {discounts.map((discount) => (
        <div key={discount.id}>
          <p>
            {discount.name} - {discount.value}%
          </p>
          <button onClick={() => handleUpdateDiscount(Number(discount.id))}>
            Update
          </button>
          <button onClick={() => handleDeleteDiscount(Number(discount.id))}>
            Delete
          </button>
        </div>
      ))}
    </div>
  );
};

export default AdminDiscounts;

================
File: pages/AdminLocationManagement.tsx
================
import React, { useEffect, useState } from 'react';
import {
  fetchLocations,
  createLocation,
  updateLocation,
  deleteLocation,
} from '../api/locationApi';
import { Location } from '../types';

const AdminLocationManagement: React.FC = () => {
  const [locations, setLocations] = useState<Location[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    loadLocations();
  }, []);

  const loadLocations = async () => {
    try {
      setLoading(true);
      const data = await fetchLocations();
      setLocations(data);
      setLoading(false);
    } catch (err) {
      setError('Failed to load locations.');
      setLoading(false);
    }
  };

  const handleCreateLocation = async () => {
    try {
      const newLocation = {
        name: 'New Location',
        address: '1234 Main St',
      };
      await createLocation(newLocation);
      loadLocations();
    } catch (err) {
      setError('Failed to create location.');
    }
  };

  const handleUpdateLocation = async (locationId: number) => {
    try {
      const updatedLocation = {
        name: 'Updated Location',
        address: '5678 Elm St',
      };
      await updateLocation(locationId, updatedLocation);
      loadLocations();
    } catch (err) {
      setError('Failed to update location.');
    }
  };

  const handleDeleteLocation = async (locationId: number) => {
    try {
      await deleteLocation(locationId);
      loadLocations();
    } catch (err) {
      setError('Failed to delete location.');
    }
  };

  return (
    <div>
      <h2>Admin Location Management</h2>
      {loading ? (
        <p>Loading...</p>
      ) : error ? (
        <p>{error}</p>
      ) : (
        <>
          <button onClick={handleCreateLocation}>Create Location</button>
          <ul>
            {locations.map((location) => (
              <li key={location.id}>
                {location.name}: {location.address}
                <button onClick={() => handleUpdateLocation(location.id)}>
                  Update
                </button>
                <button onClick={() => handleDeleteLocation(location.id)}>
                  Delete
                </button>
              </li>
            ))}
          </ul>
        </>
      )}
    </div>
  );
};

export default AdminLocationManagement;

================
File: pages/AdminLoyaltyManagement.tsx
================
import React from 'react';
import { Typography, Tabs, Tab, Box } from '@mui/material';
import LoyaltyRewards from '../components/LoyaltyRewards';
import LoyaltyTiers from '../components/LoyaltyTiers';

const AdminLoyaltyManagement: React.FC = () => {
  const [tabValue, setTabValue] = React.useState(0);

  const handleTabChange = (event: React.SyntheticEvent, newValue: number) => {
    setTabValue(newValue);
  };

  return (
    <Box sx={{ padding: 3 }}>
      <Typography variant="h4" gutterBottom>
        Loyalty Program Management
      </Typography>
      <Tabs value={tabValue} onChange={handleTabChange}>
        <Tab label="Rewards" />
        <Tab label="Tiers" />
      </Tabs>
      {tabValue === 0 && <LoyaltyRewards />}
      {tabValue === 1 && <LoyaltyTiers />}
    </Box>
  );
};

export default AdminLoyaltyManagement;

================
File: pages/AdminLoyaltyRewards.tsx
================
import React, { useState, useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { useParams } from 'react-router-dom';
import {
  fetchLoyaltyRewards,
  addReward,
  updateReward,
  selectLoyaltyRewards,
} from '../redux/slices/loyaltySlice';
import { AppDispatch, LoyaltyReward } from '../types';

const AdminLoyaltyRewards: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { clientId } = useParams<{ clientId: string }>(); // Extract clientId from params
  const loyaltyRewards = useSelector(selectLoyaltyRewards);
  const [rewardName, setRewardName] = useState('');
  const [pointsRequired, setPointsRequired] = useState<number | string>('');

  useEffect(() => {
    if (clientId) {
      dispatch(fetchLoyaltyRewards(Number(clientId))); // Pass clientId as number
    }
  }, [dispatch, clientId]);

  const handleAddReward = () => {
    if (rewardName && pointsRequired) {
      dispatch(
        addReward({
          id: Date.now(),
          name: rewardName,
          pointsRequired: parseInt(pointsRequired as string, 10),
          isActive: true, // Default to active when added
        })
      );
      setRewardName('');
      setPointsRequired('');
    }
  };

  return (
    <div>
      <h2>Loyalty Rewards Management</h2>
      <input
        type="text"
        placeholder="Reward Name"
        value={rewardName}
        onChange={(e) => setRewardName(e.target.value)}
      />
      <input
        type="number"
        placeholder="Points Required"
        value={pointsRequired}
        onChange={(e) => setPointsRequired(e.target.value)}
      />
      <button onClick={handleAddReward}>Add Reward</button>
      <ul>
        {loyaltyRewards.map((reward: LoyaltyReward) => (
          <li key={reward.id}>
            {reward.name} - {reward.pointsRequired} points
            <button
              onClick={() =>
                dispatch(
                  updateReward({
                    id: reward.id,
                    pointsRequired: 200,
                    isActive: true,
                  })
                )
              }
            >
              Update Points to 200
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
};

export default AdminLoyaltyRewards;

================
File: pages/AdminMenuManagement.tsx
================
import React, { useEffect, useState, useCallback } from 'react';
import { createMenu, updateMenu, deleteMenu, fetchMenus } from '../api/menuApi';
import { useParams } from 'react-router-dom';
import { Menu } from '../types';

const AdminMenuManagement: React.FC = () => {
  const { clientId } = useParams<{ clientId: string }>();
  const [menuId, setMenuId] = useState<number>(0);
  const [menuData, setMenuData] = useState<Partial<Menu>>({});
  const [updatedMenu, setUpdatedMenu] = useState<Partial<Menu>>({});
  const [menus, setMenus] = useState<Menu[]>([]);

  const loadMenus = useCallback(async () => {
    if (clientId) {
      const loadedMenus = await fetchMenus(Number(clientId));
      setMenus(loadedMenus);
    }
  }, [clientId]);

  useEffect(() => {
    loadMenus();
  }, [loadMenus]);

  const handleCreateMenu = async () => {
    if (clientId && menuData.name) {
      await createMenu(Number(clientId), menuData);
      loadMenus();
      setMenuData({});
    }
  };

  const handleUpdateMenu = async () => {
    if (clientId && menuId && updatedMenu) {
      await updateMenu(Number(clientId), menuId, updatedMenu);
      loadMenus();
      setUpdatedMenu({});
    }
  };

  const handleDeleteMenu = async () => {
    if (clientId && menuId) {
      await deleteMenu(Number(clientId), menuId);
      loadMenus();
      setMenuId(0);
    }
  };

  return (
    <div>
      <h2>Menu Management</h2>
      <div>
        <h3>Create New Menu</h3>
        <input
          type="text"
          placeholder="Menu Name"
          value={menuData.name || ''}
          onChange={(e) => setMenuData({ ...menuData, name: e.target.value })}
        />
        <button onClick={handleCreateMenu}>Create Menu</button>
      </div>
      <div>
        <h3>Update Menu</h3>
        <select
          value={menuId}
          onChange={(e) => setMenuId(Number(e.target.value))}
        >
          <option value={0}>Select a menu</option>
          {menus.map((menu) => (
            <option key={menu.id} value={menu.id}>
              {menu.name}
            </option>
          ))}
        </select>
        <input
          type="text"
          placeholder="New Menu Name"
          value={updatedMenu.name || ''}
          onChange={(e) =>
            setUpdatedMenu({ ...updatedMenu, name: e.target.value })
          }
        />
        <button onClick={handleUpdateMenu}>Update Menu</button>
      </div>
      <div>
        <h3>Delete Menu</h3>
        <select
          value={menuId}
          onChange={(e) => setMenuId(Number(e.target.value))}
        >
          <option value={0}>Select a menu</option>
          {menus.map((menu) => (
            <option key={menu.id} value={menu.id}>
              {menu.name}
            </option>
          ))}
        </select>
        <button onClick={handleDeleteMenu}>Delete Menu</button>
      </div>
    </div>
  );
};

export default AdminMenuManagement;

================
File: pages/AdminPanel.tsx
================
import React from 'react';
import { useAppSelector, useAppDispatch } from '../redux/store';
import { fetchClientConfig, selectClientConfig, selectClientConfigStatus, selectClientConfigError } from '../redux/slices/clientConfigSlice';

interface AdminPanelProps {
  isGlobalAdmin: boolean;
}

const AdminPanel: React.FC<AdminPanelProps> = ({ isGlobalAdmin }) => {
  const dispatch = useAppDispatch();
  const clientConfig = useAppSelector(selectClientConfig);
  const status = useAppSelector(selectClientConfigStatus);
  const error = useAppSelector(selectClientConfigError);

  React.useEffect(() => {
    if (isGlobalAdmin) {
      dispatch(fetchClientConfig('global'));
    }
  }, [dispatch, isGlobalAdmin]);

  return (
    <div>
      <h1>{isGlobalAdmin ? 'Global Admin Panel' : 'Admin Panel'}</h1>
      {status === 'loading' && <p>Loading...</p>}
      {status === 'failed' && <p>Error: {error}</p>}
      {status === 'succeeded' && clientConfig && (
        <div>
          <h2>Client Configuration</h2>
          <pre>{JSON.stringify(clientConfig, null, 2)}</pre>
        </div>
      )}
    </div>
  );
};

export default AdminPanel;

================
File: pages/AdminWalletManagement.tsx
================
import React, { useEffect, useState, useCallback } from 'react';
import { useSelector } from 'react-redux';
import { fetchWalletData } from '../api/walletApi';
import { Wallet, Discount } from '../types';
import { selectGuestProfile } from '../redux/slices/guestSlice';

const AdminWalletManagement: React.FC = () => {
  const [wallet, setWallet] = useState<Wallet | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const guestProfile = useSelector(selectGuestProfile);
  const guestId = guestProfile.id;

  const loadWalletData = useCallback(async () => {
    try {
      setLoading(true);
      const balance = await fetchWalletData();
      setWallet({
        balance: balance.balance,
        guestId: guestId,
        discounts: balance.discounts || [],
      });
    } catch (err) {
      setError('Failed to load wallet data.');
    } finally {
      setLoading(false);
    }
  }, [guestId]);

  useEffect(() => {
    loadWalletData();
  }, [loadWalletData]);

  return (
    <div>
      <h2>Admin Wallet Management</h2>
      {loading && <p>Loading...</p>}
      {error && <p>{error}</p>}
      {wallet && (
        <div>
          <p>Guest ID: {wallet.guestId}</p>
          <p>Balance: ${wallet.balance.toFixed(2)}</p>
          <h3>Discounts:</h3>
          {wallet.discounts && wallet.discounts.length > 0 ? (
            <ul>
              {wallet.discounts.map((discount: Discount) => (
                <li key={discount.id}>
                  {discount.name} - {discount.value}%{' (Expires: '}
                  {new Date(discount.expirationDate).toLocaleDateString()}
                  {')'}
                </li>
              ))}
            </ul>
          ) : (
            <p>No discounts available</p>
          )}
        </div>
      )}
      <button onClick={loadWalletData}>Refresh Wallet Data</button>
    </div>
  );
};

export default AdminWalletManagement;

================
File: pages/BrandingManagement.tsx
================
import React, { useEffect, useState } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import {
  fetchBrandingProfiles,
  createBrandingProfile,
  updateBrandingProfile,
  deleteBrandingProfile,
} from '../redux/slices/brandingSlice';
import { BrandingProfile, Client } from '../types';
import {
  TextField,
  Button,
  List,
  ListItem,
  IconButton,
  Typography,
  Box,
  Select,
  MenuItem,
} from '@mui/material';
import DeleteIcon from '@mui/icons-material/Delete';

const BrandingManagement: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { profiles, status, error } = useSelector(
    (state: RootState) => state.branding
  );
  const clients = useSelector((state: RootState) => state.clients.clients);
  const [newProfile, setNewProfile] = useState<Partial<BrandingProfile>>({
    name: '',
    logoUrl: '',
    primaryColor: '',
    secondaryColor: '',
    fontColor: '',
    clientId: 0,
  });

  useEffect(() => {
    dispatch(fetchBrandingProfiles());
  }, [dispatch]);

  const handleCreateProfile = () => {
    dispatch(createBrandingProfile(newProfile));
    setNewProfile({
      name: '',
      logoUrl: '',
      primaryColor: '',
      secondaryColor: '',
      fontColor: '',
      clientId: 0,
    });
  };

  const handleUpdateProfile = (profile: BrandingProfile) => {
    dispatch(updateBrandingProfile(profile));
  };

  const handleDeleteProfile = (id: number) => {
    if (
      window.confirm('Are you sure you want to delete this branding profile?')
    ) {
      dispatch(deleteBrandingProfile(id));
    }
  };

  if (status === 'loading') return <Typography>Loading...</Typography>;
  if (status === 'failed') return <Typography>Error: {error}</Typography>;

  return (
    <Box sx={{ padding: 3 }}>
      <Typography variant="h4" gutterBottom>
        Branding Management
      </Typography>
      <Box sx={{ marginBottom: 2 }}>
        <TextField
          label="Profile Name"
          value={newProfile.name}
          onChange={(e) =>
            setNewProfile({ ...newProfile, name: e.target.value })
          }
          sx={{ marginRight: 1 }}
        />
        <TextField
          label="Logo URL"
          value={newProfile.logoUrl}
          onChange={(e) =>
            setNewProfile({ ...newProfile, logoUrl: e.target.value })
          }
          sx={{ marginRight: 1 }}
        />
        <TextField
          label="Primary Color"
          value={newProfile.primaryColor}
          onChange={(e) =>
            setNewProfile({ ...newProfile, primaryColor: e.target.value })
          }
          sx={{ marginRight: 1 }}
        />
        <TextField
          label="Secondary Color"
          value={newProfile.secondaryColor}
          onChange={(e) =>
            setNewProfile({ ...newProfile, secondaryColor: e.target.value })
          }
          sx={{ marginRight: 1 }}
        />
        <TextField
          label="Font Color"
          value={newProfile.fontColor}
          onChange={(e) =>
            setNewProfile({ ...newProfile, fontColor: e.target.value })
          }
          sx={{ marginRight: 1 }}
        />
        <Select
          value={newProfile.clientId}
          onChange={(e) =>
            setNewProfile({ ...newProfile, clientId: e.target.value as number })
          }
          sx={{ marginRight: 1 }}
        >
          {clients.map((client: Client) => (
            <MenuItem key={client.id} value={client.id}>
              {client.name}
            </MenuItem>
          ))}
        </Select>
        <Button onClick={handleCreateProfile} variant="contained">
          Add Profile
        </Button>
      </Box>

      <List>
        {profiles.map((profile) => (
          <ListItem key={profile.id}>
            <TextField
              value={profile.name}
              onChange={(e) =>
                handleUpdateProfile({ ...profile, name: e.target.value })
              }
              sx={{ marginRight: 1 }}
            />
            <TextField
              value={profile.logoUrl}
              onChange={(e) =>
                handleUpdateProfile({ ...profile, logoUrl: e.target.value })
              }
              sx={{ marginRight: 1 }}
            />
            <TextField
              value={profile.primaryColor}
              onChange={(e) =>
                handleUpdateProfile({
                  ...profile,
                  primaryColor: e.target.value,
                })
              }
              sx={{ marginRight: 1 }}
            />
            <TextField
              value={profile.secondaryColor}
              onChange={(e) =>
                handleUpdateProfile({
                  ...profile,
                  secondaryColor: e.target.value,
                })
              }
              sx={{ marginRight: 1 }}
            />
            <TextField
              value={profile.fontColor}
              onChange={(e) =>
                handleUpdateProfile({ ...profile, fontColor: e.target.value })
              }
              sx={{ marginRight: 1 }}
            />
            <Select
              value={profile.clientId}
              onChange={(e) =>
                handleUpdateProfile({
                  ...profile,
                  clientId: e.target.value as number,
                })
              }
              sx={{ marginRight: 1 }}
            >
              {clients.map((client: Client) => (
                <MenuItem key={client.id} value={client.id}>
                  {client.name}
                </MenuItem>
              ))}
            </Select>
            <IconButton onClick={() => handleDeleteProfile(profile.id)}>
              <DeleteIcon />
            </IconButton>
          </ListItem>
        ))}
      </List>
    </Box>
  );
};

export default BrandingManagement;

================
File: pages/BrandingSettings.tsx
================
import React, { useEffect, useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import {
  selectBrandingProfiles,
  addBrandingProfile,
  updateBrandingProfile,
  fetchBrandingProfiles,
} from '../redux/slices/brandingSlice';
import { RootState, AppDispatch, BrandingProfile } from '../types';
import { useParams } from 'react-router-dom';
import { fetchClientId } from '../api/clientApi';

const BrandingSettings: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const brandingProfiles = useSelector((state: RootState) =>
    selectBrandingProfiles(state)
  );
  const { clientId } = useParams<{ clientId: string }>();
  const [currentProfile, setCurrentProfile] = useState<BrandingProfile>({
    id: 0,
    clientId: Number(clientId),
    name: '',
    logoUrl: '',
    primaryColor: '',
    secondaryColor: '',
    fontColor: '',
    secondaryFontColor: '',
  });
  const [logoFile, setLogoFile] = useState<File | null>(null);

  useEffect(() => {
    if (clientId) {
      dispatch(fetchBrandingProfiles(Number(clientId)));
    }
  }, [dispatch, clientId]);

  useEffect(() => {
    if (brandingProfiles.length > 0) {
      setCurrentProfile((prev) => ({
        ...prev,
        ...brandingProfiles[0],
        id: brandingProfiles[0].id || 0,
      }));
    }
  }, [brandingProfiles]);

  useEffect(() => {
    const fetchClient = async () => {
      const id = await fetchClientId();
      // Use the fetched client ID if needed
      console.log('Fetched client ID:', id);
    };

    fetchClient();
  }, []);

  const handleLogoUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files.length > 0) {
      setLogoFile(e.target.files[0]);
    }
  };

  const handleSave = async () => {
    if (logoFile) {
      // Handle logo upload
      const formData = new FormData();
      formData.append('file', logoFile);
      formData.append('clientId', clientId?.toString() || '');

      try {
        const response = await fetch('/api/branding/upload-logo', {
          method: 'POST',
          body: formData,
        });
        const data = await response.json();

        if (data.url) {
          setCurrentProfile((prev) => ({ ...prev, logoUrl: data.url }));
        }
      } catch (error) {
        console.error('Error uploading logo:', error);
      }
    }

    if (currentProfile.id === 0) {
      dispatch(addBrandingProfile(currentProfile));
    } else {
      dispatch(updateBrandingProfile(currentProfile));
    }
  };

  return (
    <div className="p-4 bg-white shadow rounded-md">
      <h2 className="text-2xl font-bold mb-4">Branding Settings</h2>
      <div className="space-y-4">
        <input
          type="text"
          placeholder="Name"
          value={currentProfile.name}
          onChange={(e) =>
            setCurrentProfile((prev) => ({ ...prev, name: e.target.value }))
          }
          className="w-full p-2 border rounded"
        />
        <input
          type="text"
          placeholder="Logo URL"
          value={currentProfile.logoUrl}
          onChange={(e) =>
            setCurrentProfile((prev) => ({ ...prev, logoUrl: e.target.value }))
          }
          className="w-full p-2 border rounded"
        />
        <input
          type="file"
          accept="image/*"
          onChange={handleLogoUpload}
          className="w-full p-2 border rounded"
        />
        <input
          type="color"
          placeholder="Primary Color"
          value={currentProfile.primaryColor}
          onChange={(e) =>
            setCurrentProfile((prev) => ({
              ...prev,
              primaryColor: e.target.value,
            }))
          }
          className="w-full p-2 border rounded"
        />
        <input
          type="color"
          placeholder="Secondary Color"
          value={currentProfile.secondaryColor}
          onChange={(e) =>
            setCurrentProfile((prev) => ({
              ...prev,
              secondaryColor: e.target.value,
            }))
          }
          className="w-full p-2 border rounded"
        />
        <input
          type="color"
          placeholder="Font Color"
          value={currentProfile.fontColor}
          onChange={(e) =>
            setCurrentProfile((prev) => ({
              ...prev,
              fontColor: e.target.value,
            }))
          }
          className="w-full p-2 border rounded"
        />
        <input
          type="color"
          placeholder="Secondary Font Color"
          value={currentProfile.secondaryFontColor}
          onChange={(e) =>
            setCurrentProfile((prev) => ({
              ...prev,
              secondaryFontColor: e.target.value,
            }))
          }
          className="w-full p-2 border rounded"
        />
        <button
          onClick={handleSave}
          className="bg-blue-500 text-white px-4 py-2 rounded"
        >
          Save Branding
        </button>
      </div>
    </div>
  );
};

export default BrandingSettings;

================
File: pages/BusinessAdminDashboard.tsx
================
import React from 'react';
import { useClientContext } from '../context/ClientContext';

const BusinessAdminDashboard: React.FC = () => {
  const { client } = useClientContext();

  if (!client) {
    return <div>Loading...</div>;
  }

  return (
    <div>
      <h1>{client.name} Admin Dashboard</h1>
      {/* Add dashboard content here */}
    </div>
  );
};

export default BusinessAdminDashboard;

================
File: pages/CateringMenuItems.tsx
================
import React, { useState, useCallback } from 'react';
import { useQuery, useMutation, useQueryClient } from 'react-query';
import axios from 'axios';
import {
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Button,
  TextField,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  Select,
  MenuItem,
  InputLabel,
  FormControl,
} from '@mui/material';

interface CateringMenuItem {
  id: number;
  name: string;
  description: string;
  price: number;
  menuId: number;
}

interface CateringMenu {
  id: number;
  name: string;
}

const API_URL = process.env.REACT_APP_API_URL || '/api';

const CateringMenuItems: React.FC = () => {
  const queryClient = useQueryClient();
  const [open, setOpen] = useState(false);
  const [newItem, setNewItem] = useState({
    name: '',
    description: '',
    price: 0,
    menuId: 0,
  });

  const {
    data: menuItems,
    isLoading,
    isError,
  } = useQuery<CateringMenuItem[]>('cateringMenuItems', async () => {
    const response = await axios.get(`${API_URL}/catering-menu-items`);
    return response.data;
  });

  const { data: menus } = useQuery<CateringMenu[]>(
    'cateringMenus',
    async () => {
      const response = await axios.get(`${API_URL}/catering-menus`);
      return response.data;
    }
  );

  const createItemMutation = useMutation(
    (newItem: Omit<CateringMenuItem, 'id'>) =>
      axios.post(`${API_URL}/catering-menu-items`, newItem),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('cateringMenuItems');
        setOpen(false);
        setNewItem({ name: '', description: '', price: 0, menuId: 0 });
      },
    }
  );

  const handleCreateItem = useCallback(() => {
    createItemMutation.mutate(newItem);
  }, [createItemMutation, newItem]);

  const handleInputChange = useCallback(
    (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
      const { name, value } = e.target;
      setNewItem((prev) => ({
        ...prev,
        [name]: name === 'price' ? parseFloat(value) : value,
      }));
    },
    []
  );

  if (isLoading) return <div>Loading...</div>;
  if (isError) return <div>Error loading menu items</div>;

  return (
    <div>
      <h1>Catering Menu Items</h1>
      <Button variant="contained" color="primary" onClick={() => setOpen(true)}>
        Add New Menu Item
      </Button>
      <TableContainer component={Paper}>
        <Table>
          <TableHead>
            <TableRow>
              <TableCell>Name</TableCell>
              <TableCell>Description</TableCell>
              <TableCell>Price</TableCell>
              <TableCell>Menu</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {menuItems?.map((item) => (
              <TableRow key={item.id}>
                <TableCell>{item.name}</TableCell>
                <TableCell>{item.description}</TableCell>
                <TableCell>${item.price.toFixed(2)}</TableCell>
                <TableCell>
                  {menus?.find((menu) => menu.id === item.menuId)?.name}
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>
      <Dialog open={open} onClose={() => setOpen(false)}>
        <DialogTitle>Add New Menu Item</DialogTitle>
        <DialogContent>
          <TextField
            margin="dense"
            label="Name"
            name="name"
            fullWidth
            value={newItem.name}
            onChange={handleInputChange}
          />
          <TextField
            margin="dense"
            label="Description"
            name="description"
            fullWidth
            value={newItem.description}
            onChange={handleInputChange}
          />
          <TextField
            margin="dense"
            label="Price"
            name="price"
            type="number"
            fullWidth
            value={newItem.price}
            onChange={handleInputChange}
          />
          <FormControl fullWidth margin="dense">
            <InputLabel>Menu</InputLabel>
            <Select
              value={newItem.menuId}
              onChange={(e) =>
                setNewItem((prev) => ({
                  ...prev,
                  menuId: e.target.value as number,
                }))
              }
            >
              {menus?.map((menu) => (
                <MenuItem key={menu.id} value={menu.id}>
                  {menu.name}
                </MenuItem>
              ))}
            </Select>
          </FormControl>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setOpen(false)}>Cancel</Button>
          <Button onClick={handleCreateItem}>Add</Button>
        </DialogActions>
      </Dialog>
    </div>
  );
};

export default CateringMenuItems;

================
File: pages/CateringMenus.tsx
================
import React, { useState, useCallback } from 'react';
import { useQuery, useMutation, useQueryClient } from 'react-query';
import axios from 'axios';
import {
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Button,
  TextField,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
} from '@mui/material';

interface CateringMenu {
  id: number;
  name: string;
  description: string;
}

const API_URL = process.env.REACT_APP_API_URL || '/api';

const CateringMenus: React.FC = () => {
  const queryClient = useQueryClient();
  const [open, setOpen] = useState(false);
  const [newMenu, setNewMenu] = useState({ name: '', description: '' });

  const {
    data: menus,
    isLoading,
    isError,
  } = useQuery<CateringMenu[]>('cateringMenus', async () => {
    const response = await axios.get(`${API_URL}/catering-menus`);
    return response.data;
  });

  const createMenuMutation = useMutation(
    (newMenu: Omit<CateringMenu, 'id'>) =>
      axios.post(`${API_URL}/catering-menus`, newMenu),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('cateringMenus');
        setOpen(false);
        setNewMenu({ name: '', description: '' });
      },
    }
  );

  const handleCreateMenu = useCallback(() => {
    createMenuMutation.mutate(newMenu);
  }, [createMenuMutation, newMenu]);

  const handleInputChange = useCallback(
    (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
      const { name, value } = e.target;
      setNewMenu((prev) => ({ ...prev, [name]: value }));
    },
    []
  );

  if (isLoading) return <div>Loading...</div>;
  if (isError) return <div>Error loading menus</div>;

  return (
    <div>
      <h1>Catering Menus</h1>
      <Button variant="contained" color="primary" onClick={() => setOpen(true)}>
        Add New Menu
      </Button>
      <TableContainer component={Paper}>
        <Table>
          <TableHead>
            <TableRow>
              <TableCell>Name</TableCell>
              <TableCell>Description</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {menus?.map((menu) => (
              <TableRow key={menu.id}>
                <TableCell>{menu.name}</TableCell>
                <TableCell>{menu.description}</TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>
      <Dialog open={open} onClose={() => setOpen(false)}>
        <DialogTitle>Add New Catering Menu</DialogTitle>
        <DialogContent>
          <TextField
            margin="dense"
            label="Name"
            name="name"
            fullWidth
            value={newMenu.name}
            onChange={handleInputChange}
          />
          <TextField
            margin="dense"
            label="Description"
            name="description"
            fullWidth
            value={newMenu.description}
            onChange={handleInputChange}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setOpen(false)}>Cancel</Button>
          <Button onClick={handleCreateMenu}>Add</Button>
        </DialogActions>
      </Dialog>
    </div>
  );
};

export default CateringMenus;

================
File: pages/CateringOrderAssignments.tsx
================
import React from 'react';

const CateringOrderAssignments: React.FC = () => {
  return (
    <div>
      <h1>Catering Order Assignments</h1>
      {/* Add your component logic here */}
    </div>
  );
};

export default CateringOrderAssignments;

================
File: pages/CateringOrders.tsx
================
import React, { useState } from 'react';
import { useQuery, useMutation, useQueryClient } from 'react-query';
import axios from 'axios';
import {
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Button,
  TextField,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  Chip,
} from '@mui/material';
import { DateTimePicker } from '@mui/x-date-pickers/DateTimePicker';

interface CateringOrder {
  id: number;
  customerId: number;
  houseAccountId: number | null;
  orderDate: string;
  deliveryDate: string;
  status: string;
  totalAmount: number;
}

interface Customer {
  id: number;
  name: string;
}

interface HouseAccount {
  id: number;
  name: string;
  balance: number;
}

const API_URL = process.env.REACT_APP_API_URL || '/api';

const CateringOrders: React.FC = () => {
  const queryClient = useQueryClient();
  const [open, setOpen] = useState(false);
  const [newOrder, setNewOrder] = useState<Partial<CateringOrder>>({
    customerId: 0,
    houseAccountId: null,
    orderDate: new Date().toISOString(),
    deliveryDate: new Date().toISOString(),
    status: 'Pending',
    totalAmount: 0,
  });

  const {
    data: orders,
    isLoading,
    isError,
  } = useQuery<CateringOrder[]>('cateringOrders', async () => {
    const response = await axios.get(`${API_URL}/catering-orders`);
    return response.data;
  });

  const { data: customers } = useQuery<Customer[]>('customers', async () => {
    const response = await axios.get(`${API_URL}/customers`);
    return response.data;
  });

  const { data: houseAccounts } = useQuery<HouseAccount[]>(
    'houseAccounts',
    async () => {
      const response = await axios.get(`${API_URL}/house-accounts`);
      return response.data;
    }
  );

  const createOrderMutation = useMutation(
    (newOrder: Partial<CateringOrder>) =>
      axios.post(`${API_URL}/catering-orders`, newOrder),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('cateringOrders');
        setOpen(false);
        setNewOrder({
          customerId: 0,
          houseAccountId: null,
          orderDate: new Date().toISOString(),
          deliveryDate: new Date().toISOString(),
          status: 'Pending',
          totalAmount: 0,
        });
      },
    }
  );

  if (isLoading) return <div>Loading...</div>;
  if (isError) return <div>Error loading catering orders</div>;

  return (
    <div>
      <h1>Catering Orders</h1>
      <Button variant="contained" color="primary" onClick={() => setOpen(true)}>
        Create New Order
      </Button>
      <TableContainer component={Paper}>
        <Table>
          <TableHead>
            <TableRow>
              <TableCell>Order ID</TableCell>
              <TableCell>Customer</TableCell>
              <TableCell>House Account</TableCell>
              <TableCell>Order Date</TableCell>
              <TableCell>Delivery Date</TableCell>
              <TableCell>Status</TableCell>
              <TableCell>Total Amount</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {orders?.map((order) => (
              <TableRow key={order.id}>
                <TableCell>{order.id}</TableCell>
                <TableCell>
                  {customers?.find((c) => c.id === order.customerId)?.name}
                </TableCell>
                <TableCell>
                  {order.houseAccountId
                    ? houseAccounts?.find(
                        (ha) => ha.id === order.houseAccountId
                      )?.name
                    : 'N/A'}
                </TableCell>
                <TableCell>
                  {new Date(order.orderDate).toLocaleString()}
                </TableCell>
                <TableCell>
                  {new Date(order.deliveryDate).toLocaleString()}
                </TableCell>
                <TableCell>
                  <Chip
                    label={order.status}
                    color={
                      order.status === 'Completed'
                        ? 'success'
                        : order.status === 'In Progress'
                          ? 'warning'
                          : 'default'
                    }
                  />
                </TableCell>
                <TableCell>${order.totalAmount.toFixed(2)}</TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>
      <Dialog open={open} onClose={() => setOpen(false)}>
        <DialogTitle>Create New Catering Order</DialogTitle>
        <DialogContent>
          <FormControl fullWidth margin="dense">
            <InputLabel>Customer</InputLabel>
            <Select
              value={newOrder.customerId}
              onChange={(e) =>
                setNewOrder({
                  ...newOrder,
                  customerId: e.target.value as number,
                })
              }
            >
              {customers?.map((customer) => (
                <MenuItem key={customer.id} value={customer.id}>
                  {customer.name}
                </MenuItem>
              ))}
            </Select>
          </FormControl>
          <FormControl fullWidth margin="dense">
            <InputLabel>House Account (Optional)</InputLabel>
            <Select
              value={newOrder.houseAccountId || ''}
              onChange={(e) =>
                setNewOrder({
                  ...newOrder,
                  houseAccountId: e.target.value as number | null,
                })
              }
            >
              <MenuItem value="">None</MenuItem>
              {houseAccounts?.map((account) => (
                <MenuItem key={account.id} value={account.id}>
                  {account.name} (Balance: ${account.balance.toFixed(2)})
                </MenuItem>
              ))}
            </Select>
          </FormControl>
          <DateTimePicker
            label="Order Date"
            value={newOrder.orderDate}
            onChange={(date) =>
              setNewOrder({ ...newOrder, orderDate: date?.toISOString() || '' })
            }
          />
          <DateTimePicker
            label="Delivery Date"
            value={newOrder.deliveryDate}
            onChange={(date) =>
              setNewOrder({
                ...newOrder,
                deliveryDate: date?.toISOString() || '',
              })
            }
          />
          <FormControl fullWidth margin="dense">
            <InputLabel>Status</InputLabel>
            <Select
              value={newOrder.status}
              onChange={(e) =>
                setNewOrder({ ...newOrder, status: e.target.value as string })
              }
            >
              <MenuItem value="Pending">Pending</MenuItem>
              <MenuItem value="In Progress">In Progress</MenuItem>
              <MenuItem value="Completed">Completed</MenuItem>
            </Select>
          </FormControl>
          <TextField
            margin="dense"
            label="Total Amount"
            type="number"
            fullWidth
            value={newOrder.totalAmount}
            onChange={(e) =>
              setNewOrder({
                ...newOrder,
                totalAmount: parseFloat(e.target.value),
              })
            }
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setOpen(false)}>Cancel</Button>
          <Button onClick={() => createOrderMutation.mutate(newOrder)}>
            Create
          </Button>
        </DialogActions>
      </Dialog>
    </div>
  );
};

export default CateringOrders;

================
File: pages/CateringOrdersAdmin.tsx
================
import React, { useCallback, useMemo, useState, useEffect } from 'react';
import { useQuery, useMutation, useQueryClient } from 'react-query';
import {
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Button,
  Modal,
  TextField,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  Typography,
  Snackbar,
  Alert,
  CircularProgress,
  Grid,
  Box,
  IconButton,
  SelectChangeEvent,
} from '@mui/material';
import { Edit as EditIcon, Delete as DeleteIcon } from '@mui/icons-material';
import { useParams } from 'react-router-dom';
import { cateringOrderApi } from '../api/cateringOrderApi';
import { useAuth } from '../contexts/AuthContext';
import {
  CateringOrder,
  OrderStatus,
  OrderStatistics,
} from '../types/cateringOrderTypes';

const CateringOrdersAdmin: React.FC = () => {
  const queryClient = useQueryClient();
  const [selectedStatus, setSelectedStatus] = useState<string>('all');
  const [isEditModalOpen, setIsEditModalOpen] = useState(false);
  const [editingOrder, setEditingOrder] = useState<CateringOrder | null>(null);
  const [isDeleteModalOpen, setIsDeleteModalOpen] = useState(false);
  const [deletingOrderId, setDeletingOrderId] = useState<number | null>(null);
  const [snackbarOpen, setSnackbarOpen] = useState(false);
  const [snackbarMessage, setSnackbarMessage] = useState('');
  const [orderStatistics, setOrderStatistics] = useState<OrderStatistics | null>(null);

  const { clientId } = useParams<{ clientId: string }>();
  const { user } = useAuth();

  const {
    data: orders,
    isLoading,
    isError,
  } = useQuery(['cateringOrders', selectedStatus, clientId], () =>
    cateringOrderApi.fetchOrders(clientId, selectedStatus)
  );

  const updateOrderStatusMutation = useMutation(
    ({ orderId, newStatus }: { orderId: number; newStatus: OrderStatus }) =>
      cateringOrderApi.updateOrderStatus(clientId, orderId, newStatus),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['cateringOrders', selectedStatus, clientId]);
        setSnackbarMessage('Order status updated successfully');
        setSnackbarOpen(true);
      },
      onError: () => {
        setSnackbarMessage('Failed to update order status');
        setSnackbarOpen(true);
      },
    }
  );

  const deleteOrderMutation = useMutation(
    (orderId: number) => cateringOrderApi.deleteOrder(clientId, orderId),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['cateringOrders', selectedStatus, clientId]);
        setSnackbarMessage('Order deleted successfully');
        setSnackbarOpen(true);
      },
      onError: () => {
        setSnackbarMessage('Failed to delete order');
        setSnackbarOpen(true);
      },
    }
  );

  const handleStatusChange = useCallback(
    (orderId: number, newStatus: OrderStatus) => {
      updateOrderStatusMutation.mutate({ orderId, newStatus });
    },
    [updateOrderStatusMutation]
  );

  const handleFilterChange = useCallback(
    (event: SelectChangeEvent<string>) => {
      setSelectedStatus(event.target.value);
    },
    []
  );

  const handleEditClick = useCallback((order: CateringOrder) => {
    setEditingOrder(order);
    setIsEditModalOpen(true);
  }, []);

  const handleDeleteClick = useCallback((orderId: number) => {
    setDeletingOrderId(orderId);
    setIsDeleteModalOpen(true);
  }, []);

  const handleEditSubmit = useCallback(() => {
    if (editingOrder) {
      updateOrderStatusMutation.mutate({
        orderId: editingOrder.id,
        newStatus: editingOrder.status,
      });
      setIsEditModalOpen(false);
    }
  }, [editingOrder, updateOrderStatusMutation]);

  const handleDeleteConfirm = useCallback(() => {
    if (deletingOrderId) {
      deleteOrderMutation.mutate(deletingOrderId);
      setIsDeleteModalOpen(false);
    }
  }, [deletingOrderId, deleteOrderMutation]);

  // Calculate order statistics
  useEffect(() => {
    if (orders) {
      const stats: OrderStatistics = {
        totalOrders: orders.length,
        totalRevenue: orders.reduce((sum: number, order: CateringOrder) => sum + order.totalAmount, 0),
        averageOrderValue: orders.length > 0
          ? orders.reduce((sum: number, order: CateringOrder) => sum + order.totalAmount, 0) / orders.length
          : 0,
      };
      setOrderStatistics(stats);
    }
  }, [orders]);

  if (isLoading) return <CircularProgress />;
  if (isError) return <Typography color="error">Error loading orders</Typography>;

  return (
    <Box sx={{ p: 3 }}>
      <Typography variant="h4" gutterBottom>
        Catering Orders Management
      </Typography>
      <Grid container spacing={3} sx={{ mb: 3 }}>
        <Grid item xs={12} sm={4}>
          <Paper sx={{ p: 2 }}>
            <Typography variant="h6">Total Orders</Typography>
            <Typography variant="h4">{orderStatistics?.totalOrders}</Typography>
          </Paper>
        </Grid>
        <Grid item xs={12} sm={4}>
          <Paper sx={{ p: 2 }}>
            <Typography variant="h6">Total Revenue</Typography>
            <Typography variant="h4">${orderStatistics?.totalRevenue.toFixed(2)}</Typography>
          </Paper>
        </Grid>
        <Grid item xs={12} sm={4}>
          <Paper sx={{ p: 2 }}>
            <Typography variant="h6">Average Order Value</Typography>
            <Typography variant="h4">${orderStatistics?.averageOrderValue.toFixed(2)}</Typography>
          </Paper>
        </Grid>
      </Grid>
      <FormControl fullWidth sx={{ mb: 3 }}>
        <InputLabel>Filter by Status</InputLabel>
        <Select value={selectedStatus} onChange={handleFilterChange}>
          <MenuItem value="all">All</MenuItem>
          <MenuItem value="pending">Pending</MenuItem>
          <MenuItem value="confirmed">Confirmed</MenuItem>
          <MenuItem value="completed">Completed</MenuItem>
          <MenuItem value="cancelled">Cancelled</MenuItem>
        </Select>
      </FormControl>
      <TableContainer component={Paper}>
        <Table>
          <TableHead>
            <TableRow>
              <TableCell>Order ID</TableCell>
              <TableCell>Customer</TableCell>
              <TableCell>Date</TableCell>
              <TableCell>Status</TableCell>
              <TableCell>Total</TableCell>
              <TableCell>Actions</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {orders?.map((order: CateringOrder) => (
              <TableRow key={order.id}>
                <TableCell>{order.id}</TableCell>
                <TableCell>{order.customerName}</TableCell>
                <TableCell>{new Date(order.orderDate).toLocaleDateString()}</TableCell>
                <TableCell>{order.status}</TableCell>
                <TableCell>${order.totalAmount.toFixed(2)}</TableCell>
                <TableCell>
                  <IconButton onClick={() => handleEditClick(order)}>
                    <EditIcon />
                  </IconButton>
                  <IconButton onClick={() => handleDeleteClick(order.id)}>
                    <DeleteIcon />
                  </IconButton>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>
      <Modal open={isEditModalOpen} onClose={() => setIsEditModalOpen(false)}>
        <Box sx={{ position: 'absolute', top: '50%', left: '50%', transform: 'translate(-50%, -50%)', bgcolor: 'background.paper', boxShadow: 24, p: 4 }}>
          <Typography variant="h6" gutterBottom>Edit Order</Typography>
          {editingOrder && (
            <FormControl fullWidth sx={{ mb: 2 }}>
              <InputLabel>Status</InputLabel>
              <Select
                value={editingOrder.status}
                onChange={(e) => setEditingOrder({ ...editingOrder, status: e.target.value as OrderStatus })}
              >
                <MenuItem value="pending">Pending</MenuItem>
                <MenuItem value="confirmed">Confirmed</MenuItem>
                <MenuItem value="completed">Completed</MenuItem>
                <MenuItem value="cancelled">Cancelled</MenuItem>
              </Select>
            </FormControl>
          )}
          <Button onClick={handleEditSubmit} variant="contained">Save Changes</Button>
        </Box>
      </Modal>
      <Modal open={isDeleteModalOpen} onClose={() => setIsDeleteModalOpen(false)}>
        <Box sx={{ position: 'absolute', top: '50%', left: '50%', transform: 'translate(-50%, -50%)', bgcolor: 'background.paper', boxShadow: 24, p: 4 }}>
          <Typography variant="h6" gutterBottom>Confirm Deletion</Typography>
          <Typography>Are you sure you want to delete this order?</Typography>
          <Button onClick={handleDeleteConfirm} variant="contained" color="error" sx={{ mt: 2 }}>Delete</Button>
        </Box>
      </Modal>
      <Snackbar open={snackbarOpen} autoHideDuration={6000} onClose={() => setSnackbarOpen(false)}>
        <Alert onClose={() => setSnackbarOpen(false)} severity="success" sx={{ width: '100%' }}>
          {snackbarMessage}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default CateringOrdersAdmin;

================
File: pages/CheckoutPage.tsx
================
import React, { useState, useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { useNavigate } from 'react-router-dom';
import { RootState, AppDispatch } from '../redux/store';
import {
  removeFromCart,
  updateCartItemQuantity,
  clearCart,
} from '../redux/slices/cartSlice';
import { createOrder } from '../api/orderApi';
import { fetchGuestRewards } from '../api/guestApi';
import { OrderType, Reward, CartItem } from '../types';

const CheckoutPage: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const navigate = useNavigate();
  const cartItems = useSelector((state: RootState) => state.cart.items);
  const location = useSelector(
    (state: RootState) => state.location.selectedLocation
  );
  const guest = useSelector((state: RootState) => state.auth.currentGuest);

  const [orderType, setOrderType] = useState<OrderType>('pickup');
  const [kitchenTip, setKitchenTip] = useState<number>(0);
  const [driverTip, setDriverTip] = useState<number>(0);
  const [appliedDiscounts, setAppliedDiscounts] = useState<string[]>([]);
  const [availableRewards, setAvailableRewards] = useState<Reward[]>([]);

  useEffect(() => {
    if (guest) {
      fetchGuestRewards(guest.id).then(setAvailableRewards);
    }
  }, [guest]);

  const handleQuantityChange = (index: number, newQuantity: number) => {
    if (newQuantity < 1) return;
    dispatch(updateCartItemQuantity({ index, quantity: newQuantity }));
  };

  const handleRemoveItem = (index: number) => {
    dispatch(removeFromCart(index));
  };

  const calculateItemTotal = (item: CartItem) => {
    const itemTotal = item.menuItem.price * item.quantity;
    const modifierTotal =
      item.selectedModifiers.reduce((sum, mod) => sum + mod.price, 0) *
      item.quantity;
    return itemTotal + modifierTotal;
  };

  const calculateSubtotal = () => {
    return cartItems.reduce(
      (total, item) => total + calculateItemTotal(item),
      0
    );
  };

  const calculateTax = (subtotal: number) => {
    return subtotal * (location?.taxRate || 0);
  };

  const calculateServiceCharge = (subtotal: number) => {
    const rate =
      orderType === 'catering'
        ? location?.cateringServiceChargeRate
        : location?.serviceChargeRate;
    return subtotal * (rate || 0);
  };

  const calculateTotal = () => {
    const subtotal = calculateSubtotal();
    const tax = calculateTax(subtotal);
    const serviceCharge = calculateServiceCharge(subtotal);
    const tips = orderType === 'catering' ? kitchenTip + driverTip : 0;
    return subtotal + tax + serviceCharge + tips;
  };

  const handleCheckout = async () => {
    try {
      if (!location) {
        throw new Error('Location not selected');
      }
      const orderData = {
        items: cartItems,
        orderType,
        locationId: location.id,
        guestId: guest?.id,
        subtotal: calculateSubtotal(),
        tax: calculateTax(calculateSubtotal()),
        serviceCharge: calculateServiceCharge(calculateSubtotal()),
        kitchenTip,
        driverTip,
        total: calculateTotal(),
        appliedDiscounts,
      };
      const response = await createOrder(orderData);
      const orderId = response.data.id;
      dispatch(clearCart());
      navigate(`/order-confirmation/${orderId}`);
    } catch (error) {
      console.error('Error creating order:', error);
      // Handle error (e.g., show error message to user)
    }
  };

  return (
    <div className="checkout-page">
      <h1>Checkout</h1>
      <div className="order-type-selector">
        <label>
          Order Type:
          <select
            value={orderType}
            onChange={(e) => setOrderType(e.target.value as OrderType)}
            aria-label="Select Order Type"
          >
            <option value="pickup">Pickup</option>
            <option value="delivery">Delivery</option>
            <option value="catering">Catering</option>
          </select>
        </label>
      </div>
      {cartItems.map((item, index) => (
        <div key={index} className="cart-item">
          <h3>{item.menuItem.name}</h3>
          <p>
            Quantity:
            <input
              type="number"
              value={item.quantity}
              onChange={(e) =>
                handleQuantityChange(index, parseInt(e.target.value, 10))
              }
              min="1"
              aria-label="Item Quantity"
            />
          </p>
          <p>Price: ${calculateItemTotal(item).toFixed(2)}</p>
          {item.selectedModifiers.map((mod, modIndex) => (
            <p key={modIndex}>
              {mod.name}: ${(mod.price * item.quantity).toFixed(2)}
            </p>
          ))}
          <button onClick={() => handleRemoveItem(index)}>Remove</button>
        </div>
      ))}
      <div className="order-summary">
        <h2>Order Summary</h2>
        <p>Subtotal: ${calculateSubtotal().toFixed(2)}</p>
        <p>Tax: ${calculateTax(calculateSubtotal()).toFixed(2)}</p>
        <p>
          Service Charge: $
          {calculateServiceCharge(calculateSubtotal()).toFixed(2)}
        </p>
        {orderType === 'catering' && (
          <>
            <label>
              Kitchen Tip: $
              <input
                type="number"
                value={kitchenTip}
                onChange={(e) => setKitchenTip(parseFloat(e.target.value))}
                min="0"
                step="0.01"
                aria-label="Kitchen Tip"
              />
            </label>
            <label>
              Driver Tip: $
              <input
                type="number"
                value={driverTip}
                onChange={(e) => setDriverTip(parseFloat(e.target.value))}
                min="0"
                step="0.01"
                aria-label="Driver Tip"
              />
            </label>
          </>
        )}
        <h3>Total: ${calculateTotal().toFixed(2)}</h3>
      </div>
      {availableRewards.length > 0 && (
        <div className="available-rewards">
          <h3>Available Rewards</h3>
          {availableRewards.map((reward) => (
            <div key={reward.id}>
              <p>
                {reward.name} - {reward.description}
              </p>
              <button
                onClick={() =>
                  setAppliedDiscounts([...appliedDiscounts, reward.id])
                }
              >
                Apply
              </button>
            </div>
          ))}
        </div>
      )}
      <button onClick={handleCheckout}>Place Order</button>
    </div>
  );
};

export default CheckoutPage;

================
File: pages/ClientLocationsPage.tsx
================
import React, { useState, useEffect } from 'react';
import { useParams } from 'react-router-dom';
import axios from 'axios';
import { GoogleMap, LoadScript, Marker } from '@react-google-maps/api';
import LocationCard from '../components/LocationCard';
import { Location } from '../types';

const ClientLocationsPage: React.FC = () => {
  const { clientId } = useParams<{ clientId: string }>();
  const [locations, setLocations] = useState<Location[]>([]);
  const [loading, setLoading] = useState<boolean>(true);

  useEffect(() => {
    const fetchLocations = async () => {
      try {
        const response = await axios.get<Location[]>(
          `/api/clients/${clientId}/locations`
        );
        setLocations(response.data);
      } catch (error) {
        console.error('Error fetching locations', error);
      } finally {
        setLoading(false);
      }
    };

    fetchLocations();
  }, [clientId]);

  if (loading) return <p>Loading...</p>;

  return (
    <div>
      <h1>Client Locations</h1>
      <div className="location-list">
        {locations.map((location) => (
          <LocationCard key={location.id} location={location} />
        ))}
      </div>
      <LoadScript
        googleMapsApiKey={process.env.REACT_APP_GOOGLE_MAPS_API_KEY || ''}
      >
        <GoogleMap
          mapContainerStyle={{ height: '400px', width: '100%' }}
          center={
            locations.length > 0
              ? { lat: locations[0].latitude, lng: locations[0].longitude }
              : { lat: 0, lng: 0 }
          }
          zoom={10}
        >
          {locations.map((location) => (
            <Marker
              key={location.id}
              position={{ lat: location.latitude, lng: location.longitude }}
              title={location.name}
            />
          ))}
        </GoogleMap>
      </LoadScript>
    </div>
  );
};

export default ClientLocationsPage;

================
File: pages/ClientSettings.tsx
================
import React, { useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { RootState } from '../redux/store';
import { updateClientStatus } from '../redux/slices/clientSlice';
import { AppDispatch } from '../redux/store';

const ClientSettings: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const client = useSelector((state: RootState) => state.client);
  const [status, setStatus] = useState(client.status);

  const handleUpdateStatus = () => {
    dispatch(updateClientStatus(status));
  };

  return (
    <div>
      <h2>Client Settings</h2>
      <select
        value={status}
        onChange={(e) =>
          setStatus(
            e.target.value as 'idle' | 'loading' | 'failed' | 'succeeded'
          )
        }
      >
        <option value="idle">Idle</option>
        <option value="loading">Loading</option>
        <option value="failed">Failed</option>
        <option value="succeeded">Succeeded</option>
      </select>
      <button onClick={handleUpdateStatus}>Update Status</button>
      <p>Current Status: {client.status}</p>
    </div>
  );
};

export default ClientSettings;

================
File: pages/Dashboard.tsx
================
import React, { useEffect, useState } from 'react';
import { useClientContext } from '../context/ClientContext';
import { CateringOrderService } from '../services/CateringOrderService';
import { MenuService } from '../services/MenuService';
import {
  Typography,
  Grid,
  Paper,
  CircularProgress,
  Button,
} from '@mui/material';
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
} from 'recharts';
import { OrderStatistics } from '../types/cateringOrderTypes';
import { MenuStatistics } from '../types/menuTypes';
import { fetchCateringOrders } from 'frontend/src/api/cateringOrderApi';
import { fetchMenuSummary } from 'frontend/src/api/menuApi';

const Dashboard: React.FC = () => {
  const { user } = useClientContext();
  const [orderStats, setOrderStats] = useState<OrderStatistics | null>(null);
  const [menuStats, setMenuStats] = useState<MenuStatistics | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      if (!user?.clientId) return;

      try {
        const endDate = new Date().toISOString();
        const startDate = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(); // Last 30 days
        const [orderStatsData, menuStatsData] = await Promise.all([
          CateringOrderService.getOrderStatistics(user.clientId, startDate, endDate),
          MenuService.getMenuStatistics(user.clientId, startDate, endDate),
        ]);
        setOrderStats(orderStatsData);
        setMenuStats(menuStatsData);
        setLoading(false);
      } catch (err) {
        setError('Failed to load dashboard data. Please try again.');
        setLoading(false);
      }
    };

    fetchData();
  }, [user?.clientId]);

  if (loading) return <CircularProgress />;
  if (error) return <Typography color="error">{error}</Typography>;

  const popularItemsData = menuStats?.mostPopularItems.map((item) => ({
    name: item.name,
    orders: item.orderCount,
  })) || [];

  return (
    <div>
      <Typography variant="h4" gutterBottom>
        Dashboard
      </Typography>
      <Grid container spacing={3}>
        <Grid item xs={12} sm={6} md={3}>
          <Paper style={{ padding: '20px' }}>
            <Typography variant="h6">Total Orders</Typography>
            <Typography variant="h4">{orderStats?.totalOrders}</Typography>
          </Paper>
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <Paper style={{ padding: '20px' }}>
            <Typography variant="h6">Total Revenue</Typography>
            <Typography variant="h4">
              ${orderStats?.totalRevenue.toFixed(2)}
            </Typography>
          </Paper>
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <Paper style={{ padding: '20px' }}>
            <Typography variant="h6">Average Order Value</Typography>
            <Typography variant="h4">
              ${orderStats?.averageOrderValue.toFixed(2)}
            </Typography>
          </Paper>
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <Paper style={{ padding: '20px' }}>
            <Typography variant="h6">Total Menu Items</Typography>
            <Typography variant="h4">{menuStats?.totalItems}</Typography>
          </Paper>
        </Grid>
        <Grid item xs={12}>
          <Paper style={{ padding: '20px' }}>
            <Typography variant="h6" gutterBottom>
              Most Popular Items
            </Typography>
            <ResponsiveContainer width="100%" height={300}>
              <BarChart data={popularItemsData}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="name" />
                <YAxis />
                <Tooltip />
                <Legend />
                <Bar dataKey="orders" fill="#8884d8" />
              </BarChart>
            </ResponsiveContainer>
          </Paper>
        </Grid>
      </Grid>
      <Button variant="contained" color="primary" style={{ marginTop: '20px' }}>
        View Detailed Reports
      </Button>
    </div>
  );
};

export default Dashboard;

================
File: pages/GlobalAdminDashboard.tsx
================
import React from 'react';
import ClientBuilderWizard from '../components/ClientBuilderWizard';

const GlobalAdminDashboard: React.FC = () => {
  return (
    <div>
      <h1>Global Admin Dashboard</h1>
      <ClientBuilderWizard />
    </div>
  );
};

export default GlobalAdminDashboard;

================
File: pages/GlobalAdminPanel.tsx
================
import React, { useEffect, useState } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import {
  fetchClients,
  createClient,
  updateClient,
  deleteClient,
} from '../redux/slices/clientSlice';
import { Client } from '../types/clientTypes';
import {
  TextField,
  Button,
  List,
  ListItem,
  IconButton,
  Typography,
  Box,
  Switch,
} from '@mui/material';
import DeleteIcon from '@mui/icons-material/Delete';

const GlobalAdminPanel: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { clients, status, error } = useSelector(
    (state: RootState) => state.client
  );
  const [newClient, setNewClient] = useState<Partial<Client>>({
    name: '',
    subdomain: '',
    active: true,
  });

  useEffect(() => {
    dispatch(fetchClients());
  }, [dispatch]);

  const handleCreateClient = () => {
    dispatch(createClient(newClient));
    setNewClient({ name: '', subdomain: '', active: true });
  };

  const handleUpdateClient = (client: Client) => {
    dispatch(updateClient(client));
  };

  const handleDeleteClient = (id: string) => {
    if (window.confirm('Are you sure you want to delete this client?')) {
      dispatch(deleteClient(id));
    }
  };

  if (status === 'loading') return <Typography>Loading...</Typography>;
  if (status === 'failed') return <Typography>Error: {error}</Typography>;

  return (
    <Box sx={{ padding: 3 }}>
      <Typography variant="h4" gutterBottom>
        Global Admin Panel
      </Typography>
      <Box sx={{ marginBottom: 2 }}>
        <TextField
          label="Client Name"
          value={newClient.name}
          onChange={(e) => setNewClient({ ...newClient, name: e.target.value })}
          sx={{ marginRight: 1 }}
        />
        <TextField
          label="Subdomain"
          value={newClient.subdomain}
          onChange={(e) =>
            setNewClient({ ...newClient, subdomain: e.target.value })
          }
          sx={{ marginRight: 1 }}
        />
        <Switch
          checked={newClient.active}
          onChange={(e) =>
            setNewClient({ ...newClient, active: e.target.checked })
          }
        />
        <Button onClick={handleCreateClient} variant="contained">
          Add Client
        </Button>
      </Box>

      <List>
        {clients.map((client) => (
          <ListItem key={client.id}>
            <TextField
              value={client.name}
              onChange={(e) =>
                handleUpdateClient({ ...client, name: e.target.value })
              }
              sx={{ marginRight: 1 }}
            />
            <TextField
              value={client.subdomain}
              onChange={(e) =>
                handleUpdateClient({ ...client, subdomain: e.target.value })
              }
              sx={{ marginRight: 1 }}
            />
            <Switch
              checked={client.active}
              onChange={(e) =>
                handleUpdateClient({ ...client, active: e.target.checked })
              }
              sx={{ marginRight: 1 }}
            />
            <IconButton onClick={() => handleDeleteClient(client.id)}>
              <DeleteIcon />
            </IconButton>
          </ListItem>
        ))}
      </List>
    </Box>
  );
};

export default GlobalAdminPanel;

================
File: pages/GuestLandingPage.tsx
================
import React, { useEffect, useState } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { Link } from 'react-router-dom';
import {
  Typography,
  Grid,
  Card,
  CardContent,
  CardMedia,
  Button,
  TextField,
  Container,
} from '@mui/material';
import { RootState, AppDispatch } from '../redux/store';
import { fetchLocations } from '../redux/slices/locationSlice';
import { Location } from '../types';

const GuestLandingPage: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const locations = useSelector((state: RootState) => state.location.locations);
  const [searchTerm, setSearchTerm] = useState('');

  useEffect(() => {
    dispatch(fetchLocations());
  }, [dispatch]);

  const filteredLocations = locations.filter(
    (location) =>
      location.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      location.address.toLowerCase().includes(searchTerm.toLowerCase()) ||
      location.city.toLowerCase().includes(searchTerm.toLowerCase())
  );

  return (
    <Container maxWidth="lg">
      <Typography variant="h2" component="h1" gutterBottom>
        Order from our locations
      </Typography>
      <TextField
        fullWidth
        variant="outlined"
        placeholder="Search locations..."
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        style={{ marginBottom: '2rem' }}
      />
      <Grid container spacing={4}>
        {filteredLocations.map((location: Location) => (
          <Grid item xs={12} sm={6} md={4} key={location.id}>
            <Card>
              <CardMedia
                component="img"
                height="140"
                image={
                  location.imageUrl || 'https://via.placeholder.com/300x140'
                }
                alt={location.name}
              />
              <CardContent>
                <Typography gutterBottom variant="h5" component="div">
                  {location.name}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  {location.address}, {location.city}, {location.state}{' '}
                  {location.zipCode}
                </Typography>
                <Button
                  component={Link}
                  to={`/order/${location.id}`}
                  variant="contained"
                  color="primary"
                  style={{ marginTop: '1rem' }}
                >
                  Order Now
                </Button>
              </CardContent>
            </Card>
          </Grid>
        ))}
      </Grid>
    </Container>
  );
};

export default GuestLandingPage;

================
File: pages/GuestMenuPage.tsx
================
import React, { useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';
import { useSelector, useDispatch } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import { fetchMenuItemsAsync } from '../redux/slices/menuItemsSlice';
import MenuItemCard from '../components/MenuItemCard';
import MenuItemModal from '../components/MenuItemModal';
import LoadingSpinner from '../components/LoadingSpinner';
import { MenuItem } from '../types/menuTypes';
import { useClientBranding } from '../hooks/useClientBranding';
import { Typography, Box, Alert, Grid } from '@mui/material';

const GuestMenuPage: React.FC = () => {
  const { locationId } = useParams<{ locationId: string }>();
  const dispatch = useDispatch<AppDispatch>();
  const menuItems = useSelector((state: RootState) => state.menuItems.items);
  const status = useSelector((state: RootState) => state.menuItems.status);
  const error = useSelector((state: RootState) => state.menuItems.error);
  const clientBranding = useClientBranding();

  const [selectedItem, setSelectedItem] = useState<MenuItem | null>(null);

  useEffect(() => {
    if (locationId) {
      dispatch(fetchMenuItemsAsync(locationId));
    }
  }, [dispatch, locationId]);

  if (status === 'loading') {
    return <LoadingSpinner />;
  }

  if (status === 'failed') {
    return <Alert severity="error">Error loading menu: {error}</Alert>;
  }

  return (
    <Box
      className="guest-menu-page"
      sx={{ backgroundColor: clientBranding?.backgroundColor }}
    >
      <Typography variant="h1" sx={{ color: clientBranding?.primaryColor }}>
        {clientBranding?.restaurantName} Menu
      </Typography>
      <Grid container spacing={2}>
        {menuItems.map((item: MenuItem) => (
          <Grid item xs={12} sm={6} md={4} key={item.id}>
            <MenuItemCard
              item={item}
              onSelect={() => setSelectedItem(item)}
            />
          </Grid>
        ))}
      </Grid>
      {selectedItem && (
        <MenuItemModal
          item={selectedItem}
          onClose={() => setSelectedItem(null)}
        />
      )}
    </Box>
  );
};

export default GuestMenuPage;

================
File: pages/GuestProfile.tsx
================
import React from 'react';
import { useSelector } from 'react-redux';
import { RootState, GuestProfile as GuestProfileType } from '../types';

const GuestProfile: React.FC = () => {
  const guestProfile = useSelector(
    (state: RootState) => state.guest.profile as GuestProfileType
  );

  if (!guestProfile) {
    return <div>Loading guest profile...</div>;
  }

  return (
    <div>
      <h2>Guest Profile</h2>
      <p>
        Name: {guestProfile.firstName} {guestProfile.lastName}
      </p>
      <p>Loyalty Points: {guestProfile.loyaltyPoints}</p>
      {guestProfile.loyaltyTier && (
        <p>Loyalty Tier: {guestProfile.loyaltyTier}</p>
      )}
    </div>
  );
};

export default GuestProfile;

================
File: pages/GuestProfilePage.tsx
================
import React, { useState, useEffect } from 'react';
import { useParams } from 'react-router-dom';
import { fetchGuestProfile } from '../api/guestApi';
import {
  getLoyaltyChallenges,
  getGuestChallengeProgress,
} from '../api/loyaltyChallengeApi';
import {
  GuestProfile,
  LoyaltyChallenge,
  LoyaltyChallengeProgress,
} from '../types';
import LoyaltyChallengeProgressComponent from '../components/LoyaltyChallengeProgressComponent';

const GuestProfilePage: React.FC = () => {
  const { guestId } = useParams<{ guestId: string }>();
  const [guestProfile, setGuestProfile] = useState<GuestProfile | null>(null);
  const [challenges, setChallenges] = useState<LoyaltyChallenge[]>([]);
  const [challengeProgress, setChallengeProgress] = useState<
    LoyaltyChallengeProgress[]
  >([]);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const profile = await fetchGuestProfile(parseInt(guestId));
        setGuestProfile(profile);

        const allChallenges = await getLoyaltyChallenges();
        const activeChallenges = allChallenges.filter(
          (challenge) => challenge.status === 'active'
        );
        setChallenges(activeChallenges);

        const progress = await getGuestChallengeProgress(parseInt(guestId));
        setChallengeProgress(progress);
      } catch (error) {
        console.error('Error fetching guest data:', error);
      }
    };

    fetchData();
  }, [guestId]);

  if (!guestProfile) {
    return <div>Loading...</div>;
  }

  return (
    <div className="guest-profile">
      <h1>
        {guestProfile.firstName} {guestProfile.lastName}&apos;s Profile
      </h1>
      <p>Email: {guestProfile.email}</p>
      <p>Loyalty Points: {guestProfile.loyaltyPoints}</p>
      <p>Loyalty Tier: {guestProfile.loyaltyTier}</p>

      <h2>Active Challenges</h2>
      {challenges.map((challenge) => {
        const progress = challengeProgress.find(
          (p) => p.challengeId === challenge.id
        );
        return progress ? (
          <LoyaltyChallengeProgressComponent
            key={challenge.id}
            challenge={challenge}
            progress={progress}
          />
        ) : null;
      })}
    </div>
  );
};

export default GuestProfilePage;

================
File: pages/HomePage.tsx
================
import React, { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useSelector, useDispatch } from 'react-redux';
import {
  Typography,
  Grid,
  TextField,
  Container,
  Box,
  Tabs,
  Tab,
} from '@mui/material';
import { MapContainer, TileLayer, Marker, Popup } from 'react-leaflet';
import MarkerClusterGroup from 'react-leaflet-markercluster';
import L from 'leaflet';
import 'leaflet/dist/leaflet.css';
import 'react-leaflet-markercluster/dist/styles.min.css';
import { RootState, AppDispatch } from '../redux/store';
import { fetchLocations } from '../redux/slices/locationSlice';
import { Location } from '../types/locationTypes';
import LocationCard from '../components/LocationCard';
import Button from '@mui/material/Button';

// Fix for default marker icon
delete (L.Icon.Default.prototype as any)._getIconUrl;
L.Icon.Default.mergeOptions({
  iconRetinaUrl: require('leaflet/dist/images/marker-icon-2x.png'),
  iconUrl: require('leaflet/dist/images/marker-icon.png'),
  shadowUrl: require('leaflet/dist/images/marker-shadow.png'),
});

const HomePage: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const locations = useSelector(
    (state: RootState) => state.location.locations
  );
  const [searchTerm, setSearchTerm] = useState('');
  const [tabValue, setTabValue] = useState(0);
  const navigate = useNavigate();

  useEffect(() => {
    dispatch(fetchLocations());
  }, [dispatch]);

  const filteredLocations = locations.filter(
    (location: Location) =>
      (location.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        location.address.toLowerCase().includes(searchTerm.toLowerCase()) ||
        location.city.toLowerCase().includes(searchTerm.toLowerCase())) &&
      (tabValue === 0 || (tabValue === 1 && location.isDropoffSite))
  );

  const mapCenter =
    locations.length > 0
      ? [locations[0].latitude, locations[0].longitude]
      : [0, 0];

  const handleTabChange = (event: React.SyntheticEvent, newValue: number) => {
    setTabValue(newValue);
  };

  const handleViewMenu = () => {
    navigate('/menu');
  };

  return (
    <Container maxWidth="lg">
      <Typography variant="h2" component="h1" gutterBottom>
        Welcome to Our Online Ordering Hub
      </Typography>
      <TextField
        fullWidth
        variant="outlined"
        placeholder="Search locations..."
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        style={{ marginBottom: '1rem' }}
      />
      <Tabs
        value={tabValue}
        onChange={handleTabChange}
        style={{ marginBottom: '1rem' }}
      >
        <Tab label="All Locations" />
        <Tab label="Dropoff Sites" />
      </Tabs>
      <Box sx={{ height: '400px', marginBottom: '2rem' }}>
        <MapContainer
          center={mapCenter as L.LatLngExpression}
          zoom={13}
          style={{ height: '100%', width: '100%' }}
        >
          <TileLayer
            url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
            attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
          />
          <MarkerClusterGroup>
            {filteredLocations.map((location) => (
              <Marker
                key={location.id}
                position={[location.latitude, location.longitude]}
              >
                <Popup>
                  <Typography variant="h6">{location.name}</Typography>
                  <Typography variant="body2">{location.address}</Typography>
                  {location.isDropoffSite && (
                    <Typography variant="body2" color="primary">
                      Dropoff Site Available
                    </Typography>
                  )}
                </Popup>
              </Marker>
            ))}
          </MarkerClusterGroup>
        </MapContainer>
      </Box>
      <Grid container spacing={4}>
        {filteredLocations.map((location: Location) => (
          <Grid item xs={12} sm={6} md={4} key={location.id}>
            <LocationCard location={location} />
          </Grid>
        ))}
      </Grid>
      <Button onClick={handleViewMenu}>View Menu</Button>
    </Container>
  );
};

export default HomePage;

================
File: pages/Inventory.tsx
================
import React from 'react';
import { useSelector } from 'react-redux';
import { RootState } from '../redux/store';
import { InventoryItem } from '../types';

const Inventory: React.FC = () => {
  const items = useSelector((state: RootState) => state.inventory.items);
  const status = useSelector((state: RootState) => state.inventory.status);
  const error = useSelector((state: RootState) => state.inventory.error);

  if (status === 'loading') {
    return <div>Loading inventory...</div>;
  }

  if (error) {
    return <div>Error fetching inventory: {error}</div>;
  }

  return (
    <div>
      <h2>Inventory</h2>
      <table>
        <thead>
          <tr>
            <th>Name</th>
            <th>Quantity</th>
            <th>Unit</th>
            <th>Reorder Point</th>
          </tr>
        </thead>
        <tbody>
          {items.map((item: InventoryItem) => (
            <tr key={item.id}>
              <td>{item.name}</td>
              <td>{item.quantity}</td>
              <td>{item.unit}</td>
              <td>{item.reorderPoint}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};

export default Inventory;

================
File: pages/InventoryManagement.tsx
================
import React, { useEffect, useState } from 'react';
import {
  Typography,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Button,
  Modal,
  TextField,
  Snackbar,
  Alert,
  CircularProgress,
} from '@mui/material';
import { InventoryItem } from '../types/inventoryTypes';
import { InventoryService } from '../services/inventoryService';
import { useAuth } from '../contexts/AuthContext';
import { fetchInventory, updateInventory } from 'frontend/src/api/inventoryApi';

const InventoryManagement: React.FC = () => {
  const [inventory, setInventory] = useState<InventoryItem[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const inventoryService = useMemo(() => new InventoryService(), []);

  useEffect(() => {
    const fetchInventory = async () => {
      try {
        const data = await inventoryService.getInventory();
        setInventory(data);
        setLoading(false);
      } catch (error) {
        console.error('Error fetching inventory:', error);
        setError('Failed to fetch inventory. Please try again.');
        setLoading(false);
      }
    };

    fetchInventory();
  }, [inventoryService]);

  const { user } = useAuth();
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [selectedItem, setSelectedItem] = useState<InventoryItem | null>(null);
  const [snackbar, setSnackbar] = useState<{
    message: string;
    severity: 'success' | 'error';
  } | null>(null);

  const handleAddItem = () => {
    setSelectedItem({
      id: 0,
      name: '',
      quantity: 0,
      unit: '',
      reorderPoint: 0,
      tenantId: user.tenantId,
    });
    setIsModalOpen(true);
  };

  const handleEditItem = (item: InventoryItem) => {
    setSelectedItem(item);
    setIsModalOpen(true);
  };

  const handleSaveItem = async () => {
    if (!selectedItem) return;

    try {
      let updatedItem;
      if (selectedItem.id === 0) {
        updatedItem = await inventoryService.createInventoryItem(
          user.tenantId,
          selectedItem
        );
        setInventory([...inventory, updatedItem]);
      } else {
        updatedItem = await inventoryService.updateInventoryItem(
          user.tenantId,
          selectedItem.id,
          selectedItem
        );
        setInventory(
          inventory.map((item) =>
            item.id === updatedItem.id ? updatedItem : item
          )
        );
      }
      setIsModalOpen(false);
      setSnackbar({
        message: 'Inventory item saved successfully',
        severity: 'success',
      });
    } catch (err) {
      setSnackbar({
        message: 'Failed to save inventory item. Please try again.',
        severity: 'error',
      });
    }
  };

  const handleDeleteItem = async (itemId: number) => {
    if (
      window.confirm('Are you sure you want to delete this inventory item?')
    ) {
      try {
        await inventoryService.deleteInventoryItem(user.tenantId, itemId);
        setInventory(inventory.filter((item) => item.id !== itemId));
        setSnackbar({
          message: 'Inventory item deleted successfully',
          severity: 'success',
        });
      } catch (err) {
        setSnackbar({
          message: 'Failed to delete inventory item. Please try again.',
          severity: 'error',
        });
      }
    }
  };

  if (loading) return <CircularProgress />;
  if (error) return <Typography color="error">{error}</Typography>;

  return (
    <div>
      <Typography variant="h4" gutterBottom>
        Inventory Management
      </Typography>
      <Button
        variant="contained"
        color="primary"
        onClick={handleAddItem}
        style={{ marginBottom: '20px' }}
      >
        Add New Item
      </Button>
      <TableContainer component={Paper}>
        <Table>
          <TableHead>
            <TableRow>
              <TableCell>Name</TableCell>
              <TableCell>Quantity</TableCell>
              <TableCell>Unit</TableCell>
              <TableCell>Reorder Point</TableCell>
              <TableCell>Actions</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {inventory.map((item) => (
              <TableRow key={item.id}>
                <TableCell>{item.name}</TableCell>
                <TableCell>{item.quantity}</TableCell>
                <TableCell>{item.unit}</TableCell>
                <TableCell>{item.reorderPoint}</TableCell>
                <TableCell>
                  <Button onClick={() => handleEditItem(item)}>Edit</Button>
                  <Button
                    onClick={() => handleDeleteItem(item.id)}
                    color="secondary"
                  >
                    Delete
                  </Button>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>
      <Modal open={isModalOpen} onClose={() => setIsModalOpen(false)}>
        <Paper
          style={{
            padding: '20px',
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            maxWidth: '400px',
            width: '100%',
          }}
        >
          {selectedItem && (
            <form
              onSubmit={(e) => {
                e.preventDefault();
                handleSaveItem();
              }}
            >
              <Typography variant="h6" gutterBottom>
                {selectedItem.id === 0 ? 'Add New Item' : 'Edit Item'}
              </Typography>
              <TextField
                label="Name"
                value={selectedItem.name}
                onChange={(e) =>
                  setSelectedItem({ ...selectedItem, name: e.target.value })
                }
                fullWidth
                margin="normal"
              />
              <TextField
                label="Quantity"
                type="number"
                value={selectedItem.quantity}
                onChange={(e) =>
                  setSelectedItem({
                    ...selectedItem,
                    quantity: Number(e.target.value),
                  })
                }
                fullWidth
                margin="normal"
              />
              <TextField
                label="Unit"
                value={selectedItem.unit}
                onChange={(e) =>
                  setSelectedItem({ ...selectedItem, unit: e.target.value })
                }
                fullWidth
                margin="normal"
              />
              <TextField
                label="Reorder Point"
                type="number"
                value={selectedItem.reorderPoint}
                onChange={(e) =>
                  setSelectedItem({
                    ...selectedItem,
                    reorderPoint: Number(e.target.value),
                  })
                }
                fullWidth
                margin="normal"
              />
              <Button
                type="submit"
                variant="contained"
                color="primary"
                fullWidth
                style={{ marginTop: '20px' }}
              >
                Save Item
              </Button>
            </form>
          )}
        </Paper>
      </Modal>
      <Snackbar
        open={!!snackbar}
        autoHideDuration={6000}
        onClose={() => setSnackbar(null)}
      >
        <Alert
          onClose={() => setSnackbar(null)}
          severity={snackbar?.severity}
          sx={{ width: '100%' }}
        >
          {snackbar?.message}
        </Alert>
      </Snackbar>
    </div>
  );
};

export default InventoryManagement;

================
File: pages/LocationManagement.tsx
================
import React from 'react';
import { useSelector } from 'react-redux';
import { RootState } from '../redux/store';
// Remove unused import: import { updateLocation } from '../redux/slices/locationSlice';

const LocationManagement: React.FC = () => {
  const locations = useSelector((state: RootState) => state.location.locations);

  // ... component logic

  return (
    <div>
      <h1>Location Management</h1>
      {locations.map((location) => (
        <div key={location.id}>{/* Render location details */}</div>
      ))}
    </div>
  );
};

export default LocationManagement;

================
File: pages/Login.tsx
================
import React, { useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { loginUser } from '../redux/slices/authSlice';
import { RootState, AppDispatch } from '../redux/store';
import { Client } from '../types';

const Login: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const client = useSelector((state: RootState) => state.clientConfig.client);
  const error = useSelector((state: RootState) => state.auth.error);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (client) {
      const loginData = {
        email,
        password,
        clientId: client.id,
        subdomain: client.subdomain || '',
      };
      dispatch(loginUser(loginData));
    } else {
      console.error('Client is null');
    }
  };

  return (
    <div className="login-container">
      <h2>Login</h2>
      <form onSubmit={handleSubmit}>
        <div>
          <label htmlFor="email">Email:</label>
          <input
            type="email"
            id="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
          />
        </div>
        <div>
          <label htmlFor="password">Password:</label>
          <input
            type="password"
            id="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            required
          />
        </div>
        <button type="submit">Login</button>
      </form>
      {error && <p className="error-message">{error}</p>}
    </div>
  );
};

export default Login;

================
File: pages/LoyaltyAdminPage.tsx
================
import React from 'react';
import { useSelector } from 'react-redux';
import { RootState } from '../redux/store';
import LoyaltyChallengeManager from '../components/LoyaltyChallengeManager';
import WalletDrop from '../components/WalletDrop';
import DiscountBuilder from '../components/DiscountBuilder';
import POSDiscountSync from '../components/POSDiscountSync';
import ClientAdminHub from '../components/ClientAdminHub';
import { UserRole } from '../types/userTypes';

const LoyaltyAdminPage: React.FC = () => {
  const user = useSelector((state: RootState) => state.auth.user);
  const isClientAdmin = user?.roles.includes(UserRole.CLIENT_ADMIN);

  return (
    <div>
      <h1>Loyalty Program Administration</h1>
      {isClientAdmin ? (
        <ClientAdminHub />
      ) : (
        <>
          <LoyaltyChallengeManager />
          <WalletDrop />
          <DiscountBuilder />
          <POSDiscountSync />
        </>
      )}
    </div>
  );
};

export default LoyaltyAdminPage;

================
File: pages/LoyaltyManagement.tsx
================
import React, { useEffect, useState } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import {
  fetchLoyaltyRewards,
  createLoyaltyReward,
  updateLoyaltyReward,
  deleteLoyaltyReward,
  fetchLoyaltyConfig,
  updateLoyaltyConfig,
  fetchLoyaltyProgram,
  updateLoyaltyProgram,
} from '../redux/slices/loyaltySlice';
import { LoyaltyReward, LoyaltyConfig } from '../types';
import { fetchLoyaltyProgram, updateLoyaltyProgram } from 'frontend/src/api/loyaltyApi';

const LoyaltyManagement: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { rewards, config, status, error } = useSelector(
    (state: RootState) => state.loyalty
  );
  const [newReward, setNewReward] = useState<Partial<LoyaltyReward>>({
    name: '',
    pointsRequired: 0,
    isActive: true,
  });
  const [editingConfig, setEditingConfig] = useState<LoyaltyConfig | null>(
    null
  );
  const [formError, setFormError] = useState<string | null>(null);

  useEffect(() => {
    dispatch(fetchLoyaltyRewards());
    dispatch(fetchLoyaltyConfig());
  }, [dispatch]);

  const validateReward = (reward: Partial<LoyaltyReward>): boolean => {
    if (!reward.name || reward.name.trim() === '') {
      setFormError('Reward name is required');
      return false;
    }
    if (reward.pointsRequired === undefined || reward.pointsRequired < 0) {
      setFormError('Points required must be a positive number');
      return false;
    }
    setFormError(null);
    return true;
  };

  const handleCreateReward = () => {
    if (validateReward(newReward)) {
      dispatch(createLoyaltyReward(newReward));
      setNewReward({ name: '', pointsRequired: 0, isActive: true });
    }
  };

  const handleUpdateReward = (reward: LoyaltyReward) => {
    if (validateReward(reward)) {
      dispatch(updateLoyaltyReward(reward));
    }
  };

  const handleDeleteReward = (id: number) => {
    if (window.confirm('Are you sure you want to delete this reward?')) {
      dispatch(deleteLoyaltyReward(id));
    }
  };

  const handleUpdateConfig = () => {
    if (editingConfig) {
      dispatch(updateLoyaltyConfig(editingConfig));
      setEditingConfig(null);
    }
  };

  if (status === 'loading') return <div>Loading...</div>;
  if (status === 'failed') return <div>Error: {error}</div>;

  return (
    <div className="loyalty-management">
      <h2>Loyalty Management</h2>

      <section className="loyalty-rewards">
        <h3>Loyalty Rewards</h3>
        <form
          onSubmit={(e) => {
            e.preventDefault();
            handleCreateReward();
          }}
          className="reward-form"
        >
          <input
            type="text"
            value={newReward.name}
            onChange={(e) =>
              setNewReward({ ...newReward, name: e.target.value })
            }
            placeholder="Reward Name"
            required
          />
          <input
            type="number"
            value={newReward.pointsRequired}
            onChange={(e) =>
              setNewReward({
                ...newReward,
                pointsRequired: parseInt(e.target.value),
              })
            }
            placeholder="Points Required"
            required
            min="0"
          />
          <button type="submit">Add Reward</button>
        </form>
        {formError && <p className="error-message">{formError}</p>}

        <ul className="rewards-list">
          {rewards.map((reward) => (
            <li key={reward.id} className="reward-item">
              <input
                type="text"
                value={reward.name}
                onChange={(e) =>
                  handleUpdateReward({ ...reward, name: e.target.value })
                }
              />
              <input
                type="number"
                value={reward.pointsRequired}
                onChange={(e) =>
                  handleUpdateReward({
                    ...reward,
                    pointsRequired: parseInt(e.target.value),
                  })
                }
                min="0"
              />
              <button
                onClick={() =>
                  handleUpdateReward({ ...reward, isActive: !reward.isActive })
                }
              >
                {reward.isActive ? 'Deactivate' : 'Activate'}
              </button>
              <button onClick={() => handleDeleteReward(reward.id)}>
                Delete
              </button>
            </li>
          ))}
        </ul>
      </section>

      <section className="loyalty-configuration">
        <h3>Loyalty Configuration</h3>
        {config && (
          <div className="tiers-config">
            <h4>Tiers</h4>
            {editingConfig ? (
              <>
                {editingConfig.tiers.map((tier, index) => (
                  <input
                    key={index}
                    type="text"
                    value={tier.tierName}
                    onChange={(e) => {
                      const newTiers = [...editingConfig.tiers];
                      newTiers[index] = { tierName: e.target.value };
                      setEditingConfig({ ...editingConfig, tiers: newTiers });
                    }}
                  />
                ))}
                <button
                  onClick={() =>
                    setEditingConfig({
                      ...editingConfig,
                      tiers: [...editingConfig.tiers, { tierName: '' }],
                    })
                  }
                >
                  Add Tier
                </button>
                <button onClick={handleUpdateConfig}>Save Configuration</button>
              </>
            ) : (
              <>
                <ul className="tiers-list">
                  {config.tiers.map((tier, index) => (
                    <li key={index}>{tier.tierName}</li>
                  ))}
                </ul>
                <button onClick={() => setEditingConfig(config)}>
                  Edit Configuration
                </button>
              </>
            )}
          </div>
        )}
      </section>
    </div>
  );
};

export default LoyaltyManagement;

================
File: pages/Menu.tsx
================
import React, { useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import { fetchMenus } from '../redux/slices/menuSlice';
import { useClientContext } from '../context/ClientContext';
import { Menu as MenuType, MenuGroup, MenuItem } from '../types';

const MenuPage: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const menus = useSelector((state: RootState) => state.menu.menus);
  const { clientId, isLoading, error } = useClientContext();

  useEffect(() => {
    if (clientId) {
      dispatch(fetchMenus(clientId));
    }
  }, [dispatch, clientId]);

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!clientId) return <div>No client ID available</div>;

  return (
    <div>
      <h2>Menu</h2>
      {menus.map((menu: MenuType) => (
        <div key={menu.id}>
          <h3>{menu.name}</h3>
          <ul>
            {menu.groups.map((group: MenuGroup) => (
              <li key={group.id}>
                <h4>{group.name}</h4>
                <ul>
                  {group.items.map((item: MenuItem) => (
                    <li key={item.id}>{item.name}</li>
                  ))}
                </ul>
              </li>
            ))}
          </ul>
        </div>
      ))}
    </div>
  );
};

export default MenuPage;

================
File: pages/MenuBuilder.tsx
================
import React, { useEffect, useState } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { DragDropContext, Droppable, Draggable, DropResult } from 'react-beautiful-dnd';
import { RootState, AppDispatch, Menu, MenuGroup } from '../types';
import { fetchMenus, updateMenu } from '../redux/slices/menuSlice';
import MenuGroupComponent from './MenuGroupComponent';
import {
  Button,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Typography,
  Box,
  CircularProgress,
} from '@mui/material';
import AddCircleOutlineIcon from '@mui/icons-material/AddCircleOutline';
import { useClientContext } from '../context/ClientContext';

const MenuBuilder: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const menus = useSelector((state: RootState) => state.menu.menus);
  const loading = useSelector((state: RootState) => state.menu.loading);
  const error = useSelector((state: RootState) => state.menu.error);
  const [activeMenu, setActiveMenu] = useState<Menu | null>(null);
  const [isAddGroupDialogOpen, setIsAddGroupDialogOpen] = useState(false);
  const [newGroupName, setNewGroupName] = useState('');
  const { clientId } = useClientContext();

  useEffect(() => {
    if (clientId) {
      dispatch(fetchMenus(clientId.toString()));
    }
  }, [dispatch, clientId]);

  const handleDragEnd = (result: DropResult) => {
    if (!result.destination || !activeMenu) {
      return;
    }

    const newGroups = Array.from(activeMenu.groups);
    const [reorderedGroup] = newGroups.splice(result.source.index, 1);
    newGroups.splice(result.destination.index, 0, reorderedGroup);

    const updatedMenu: Menu = {
      ...activeMenu,
      groups: newGroups,
    };

    setActiveMenu(updatedMenu);
    dispatch(updateMenu({ clientId: clientId.toString(), menuId: activeMenu.id, menuData: updatedMenu }));
  };

  const handleAddGroup = () => {
    if (activeMenu && newGroupName.trim()) {
      const updatedMenu: Menu = {
        ...activeMenu,
        groups: [
          ...activeMenu.groups,
          { id: Date.now().toString(), name: newGroupName.trim(), items: [] },
        ],
      };
      dispatch(updateMenu({ clientId: clientId.toString(), menuId: activeMenu.id, menuData: updatedMenu }));
      setIsAddGroupDialogOpen(false);
      setNewGroupName('');
    }
  };

  if (loading) {
    return <CircularProgress />;
  }

  if (error) {
    return <Typography color="error">{error}</Typography>;
  }

  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Menu Builder
      </Typography>
      <Box display="flex" flexWrap="wrap" gap={2} mb={2}>
        {menus.map((menu) => (
          <Button
            key={menu.id}
            variant={activeMenu?.id === menu.id ? 'contained' : 'outlined'}
            onClick={() => setActiveMenu(menu)}
            aria-label={`Select menu ${menu.name}`}
          >
            {menu.name}
          </Button>
        ))}
      </Box>
      {activeMenu && (
        <DragDropContext onDragEnd={handleDragEnd}>
          <Droppable droppableId="menu">
            {(provided) => (
              <Box {...provided.droppableProps} ref={provided.innerRef}>
                {activeMenu.groups.map((group, index) => (
                  <Draggable key={group.id} draggableId={group.id} index={index}>
                    {(provided) => (
                      <Box
                        ref={provided.innerRef}
                        {...provided.draggableProps}
                        {...provided.dragHandleProps}
                      >
                        <MenuGroupComponent
                          group={group}
                          index={index}
                          menuId={activeMenu.id}
                        />
                      </Box>
                    )}
                  </Draggable>
                ))}
                {provided.placeholder}
              </Box>
            )}
          </Droppable>
        </DragDropContext>
      )}
      <Button
        startIcon={<AddCircleOutlineIcon />}
        onClick={() => setIsAddGroupDialogOpen(true)}
        variant="contained"
        color="primary"
        style={{ marginTop: '16px' }}
        aria-label="Add new group"
      >
        Add Group
      </Button>
      <Dialog open={isAddGroupDialogOpen} onClose={() => setIsAddGroupDialogOpen(false)}>
        <DialogTitle>Add New Group</DialogTitle>
        <DialogContent>
          <TextField
            margin="dense"
            label="Group Name"
            fullWidth
            value={newGroupName}
            onChange={(e) => setNewGroupName(e.target.value)}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setIsAddGroupDialogOpen(false)}>Cancel</Button>
          <Button onClick={handleAddGroup} color="primary">
            Add
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default MenuBuilder;

================
File: pages/MenuManagementAdmin.tsx
================
import React, { useState, useEffect, useCallback, useMemo } from 'react';
import {
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Typography,
  Button,
  Modal,
  TextField,
  Paper,
  Snackbar,
  Alert,
  CircularProgress,
  ListItem,
  ListItemText,
  ListItemSecondaryAction,
  IconButton,
  Switch,
  FormControlLabel,
  List,
} from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import DeleteIcon from '@mui/icons-material/Delete';
import EditIcon from '@mui/icons-material/Edit';
import AddIcon from '@mui/icons-material/Add';
import SyncIcon from '@mui/icons-material/Sync';
import { useParams } from 'react-router-dom';
import { menuService } from '../services/menuService';
import { useAuth } from '../contexts/AuthContext';
import { Menu, MenuGroup, MenuItem, Modifier } from '../types/menuTypes';

interface SelectedItem {
  id: string;
  name: string;
  parentId?: string;
  grandParentId?: string;
  price?: number;
  description?: string;
  isAvailable?: boolean;
  menuId?: string;
  groupId?: string;
  itemId?: string;
}

const MenuManagementAdmin: React.FC = () => {
  const [menus, setMenus] = useState<Menu[]>([]);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [modalType, setModalType] = useState<
    'menu' | 'group' | 'item' | 'modifier'
  >('menu');
  const [selectedItem, setSelectedItem] = useState<SelectedItem | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [snackbar, setSnackbar] = useState<{
    message: string;
    severity: 'success' | 'error';
  } | null>(null);
  const [isSaving, setIsSaving] = useState(false);
  const [syncStatus, setSyncStatus] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState('');
  const [filteredMenus, setFilteredMenus] = useState<Menu[]>([]);

  const { clientId } = useParams<{ clientId: string }>();
  const { user } = useAuth();

  const loadMenus = useCallback(async () => {
    if (!clientId) return;
    try {
      const fetchedMenus = await menuService.getAllMenus(clientId);
      setMenus(fetchedMenus);
      setLoading(false);
    } catch (err) {
      setError('Failed to load menus. Please try again.');
      setLoading(false);
    }
  }, [clientId]);

  useEffect(() => {
    loadMenus();
  }, [loadMenus]);

  const handleSearch = (event: React.ChangeEvent<HTMLInputElement>) => {
    const query = event.target.value.toLowerCase();
    setSearchQuery(query);
    const filtered = menus.filter(
      (menu) =>
        menu.name.toLowerCase().includes(query) ||
        menu.menuGroups.some(
          (group) =>
            group.name.toLowerCase().includes(query) ||
            group.items.some((item) => item.name.toLowerCase().includes(query))
        )
    );
    setFilteredMenus(filtered);
  };

  const handleSave = async () => {
    if (!selectedItem || !clientId) return;
    setIsSaving(true);
    try {
      let result: Menu | MenuGroup | MenuItem;
      switch (modalType) {
        case 'menu':
          result =
            selectedItem.id === '0'
              ? await menuService.createMenu(clientId, selectedItem)
              : await menuService.updateMenu(
                  clientId,
                  selectedItem.id,
                  selectedItem
                );
          setMenus(menus.map((m) => (m.id === result.id ? result as Menu : m)));
          break;
        case 'group':
          if (selectedItem.parentId) {
            result =
              selectedItem.id === '0'
                ? await menuService.createMenuGroup(
                    clientId,
                    selectedItem.parentId,
                    selectedItem
                  )
                : await menuService.updateMenuGroup(
                    clientId,
                    selectedItem.parentId,
                    selectedItem.id,
                    selectedItem
                  );
            setMenus(
              menus.map((m) =>
                m.id === selectedItem.parentId
                  ? {
                      ...m,
                      menuGroups: m.menuGroups.map((g) =>
                        g.id === result.id ? result : g
                      ),
                    }
                  : m
              )
            );
          }
          break;
        case 'item':
          if (selectedItem.grandParentId && selectedItem.parentId) {
            result =
              selectedItem.id === '0'
                ? await menuService.createMenuItem(
                    clientId,
                    selectedItem.grandParentId,
                    selectedItem.parentId,
                    selectedItem
                  )
                : await menuService.updateMenuItem(
                    clientId,
                    selectedItem.grandParentId,
                    selectedItem.parentId,
                    selectedItem.id,
                    selectedItem
                  );
            setMenus(
              menus.map((m) =>
                m.id === selectedItem.grandParentId
                  ? {
                      ...m,
                      menuGroups: m.menuGroups.map((g) =>
                        g.id === selectedItem.parentId
                          ? {
                              ...g,
                              items: g.items.map((i) =>
                                i.id === result.id ? result : i
                              ),
                            }
                          : g
                      ),
                    }
                  : m
              )
            );
          }
          break;
        case 'modifier':
          if (
            selectedItem.menuId &&
            selectedItem.groupId &&
            selectedItem.itemId
          ) {
            result =
              selectedItem.id === '0'
                ? await menuService.createModifier(
                    clientId,
                    selectedItem.menuId,
                    selectedItem.groupId,
                    selectedItem.itemId,
                    selectedItem
                  )
                : await menuService.updateModifier(
                    clientId,
                    selectedItem.menuId,
                    selectedItem.groupId,
                    selectedItem.itemId,
                    selectedItem.id,
                    selectedItem
                  );
            setMenus(
              menus.map((m) =>
                m.id === selectedItem.menuId
                  ? {
                      ...m,
                      menuGroups: m.menuGroups.map((g) =>
                        g.id === selectedItem.groupId
                          ? {
                              ...g,
                              items: g.items.map((i) =>
                                i.id === selectedItem.itemId
                                  ? {
                                      ...i,
                                      modifiers: i.modifiers.map((mod) =>
                                        mod.id === result.id ? result : mod
                                      ),
                                    }
                                  : i
                              ),
                            }
                          : g
                      ),
                    }
                  : m
              )
            );
          }
          break;
      }
      setIsModalOpen(false);
      setSnackbar({ message: 'Item saved successfully', severity: 'success' });
    } catch (err) {
      setSnackbar({
        message: 'Failed to save item. Please try again.',
        severity: 'error',
      });
    } finally {
      setIsSaving(false);
    }
  };

  const handleEdit = (
    type: 'menu' | 'group' | 'item' | 'modifier',
    item: SelectedItem
  ) => {
    setModalType(type);
    setSelectedItem(item);
    setIsModalOpen(true);
  };

  const handleDelete = async (
    type: 'menu' | 'group' | 'item' | 'modifier',
    id: string
  ) => {
    if (!clientId) return;
    try {
      await menuService.deleteItem(clientId, type, id);
      setMenus(menus.filter((m) => m.id !== id));
      setSnackbar({
        message: 'Item deleted successfully',
        severity: 'success',
      });
    } catch (err) {
      setSnackbar({
        message: 'Failed to delete item. Please try again.',
        severity: 'error',
      });
    }
  };

  const handleAdd = (
    type: 'menu' | 'group' | 'item' | 'modifier',
    parentId?: string,
    grandParentId?: string
  ) => {
    setModalType(type);
    setSelectedItem({ id: '0', name: '', parentId, grandParentId });
    setIsModalOpen(true);
  };

  const handleSync = useCallback(async () => {
    if (!clientId) return;
    try {
      setSyncStatus('Syncing menus...');
      await menuService.syncMenus(clientId);
      setSyncStatus('Menus synced successfully');
      loadMenus();
    } catch (error) {
      setSyncStatus('Error syncing menus');
      console.error('Error syncing menus:', error);
    }
  }, [clientId, loadMenus]);

  const renderMenuStructure = (menu: Menu): JSX.Element => {
    return (
      <Accordion key={menu.id}>
        <AccordionSummary expandIcon={<ExpandMoreIcon />}>
          <Typography>{menu.name}</Typography>
        </AccordionSummary>
        <AccordionDetails>
          {menu.menuGroups.map((group) => (
            <Accordion key={group.id}>
              <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                <Typography>{group.name}</Typography>
              </AccordionSummary>
              <AccordionDetails>
                <List>
                  {group.items.map((item) => (
                    <ListItem key={item.id}>
                      <ListItemText
                        primary={item.name}
                        secondary={`$${item.price.toFixed(2)}`}
                      />
                      <ListItemSecondaryAction>
                        <IconButton
                          edge="end"
                          aria-label="edit"
                          onClick={() => handleEdit('item', item)}
                        >
                          <EditIcon />
                        </IconButton>
                        <IconButton
                          edge="end"
                          aria-label="delete"
                          onClick={() => handleDelete('item', item.id)}
                        >
                          <DeleteIcon />
                        </IconButton>
                      </ListItemSecondaryAction>
                    </ListItem>
                  ))}
                </List>
              </AccordionDetails>
            </Accordion>
          ))}
        </AccordionDetails>
      </Accordion>
    );
  };

  const renderModalContent = () => {
    if (!selectedItem) return null;

    return (
      <form onSubmit={(e) => { e.preventDefault(); handleSave(); }}>
        <Typography variant="h6">
          {modalType === 'menu' ? 'Menu' :
           modalType === 'group' ? 'Menu Group' :
           modalType === 'item' ? 'Menu Item' : 'Modifier'}
        </Typography>
        <TextField
          label="Name"
          value={selectedItem.name}
          onChange={(e) => setSelectedItem({ ...selectedItem, name: e.target.value })}
          fullWidth
          margin="normal"
        />
        {(modalType === 'item' || modalType === 'modifier') && (
          <TextField
            label="Price"
            type="number"
            value={selectedItem.price || ''}
            onChange={(e) => setSelectedItem({
              ...selectedItem,
              price: parseFloat(e.target.value),
            })}
            fullWidth
            margin="normal"
          />
        )}
        {modalType === 'item' && (
          <TextField
            label="Description"
            value={selectedItem.description || ''}
            onChange={(e) => setSelectedItem({ ...selectedItem, description: e.target.value })}
            fullWidth
            margin="normal"
            multiline
            rows={3}
          />
        )}
        {modalType !== 'menu' && (
          <FormControlLabel
            control={
              <Switch
                checked={selectedItem.isAvailable || false}
                onChange={(e) => setSelectedItem({
                  ...selectedItem,
                  isAvailable: e.target.checked,
                })}
              />
            }
            label="Available"
          />
        )}
        <Button type="submit" variant="contained" color="primary" disabled={isSaving}>
          {isSaving ? <CircularProgress size={24} /> : 'Save'}
        </Button>
      </form>
    );
  };

  if (loading) return <CircularProgress />;
  if (error) return <Typography color="error">{error}</Typography>;

  return (
    <div>
      <Typography variant="h4">Menu Management</Typography>
      <TextField
        label="Search Menu Items"
        variant="outlined"
        fullWidth
        margin="normal"
        value={searchQuery}
        onChange={handleSearch}
      />
      <Button onClick={handleSync} startIcon={<SyncIcon />}>
        Sync Menus
      </Button>
      {syncStatus && <Typography>{syncStatus}</Typography>}
      {(searchQuery ? filteredMenus : menus).map((menu) => (
        <Accordion key={menu.id}>
          <AccordionSummary expandIcon={<ExpandMoreIcon />}>
            <Typography>{menu.name}</Typography>
          </AccordionSummary>
          <AccordionDetails>{renderMenuStructure(menu)}</AccordionDetails>
        </Accordion>
      ))}
      <Button
        onClick={() => handleAdd('menu')}
        startIcon={<AddIcon />}
        variant="contained"
        color="primary"
      >
        Add Menu
      </Button>
      <Modal open={isModalOpen} onClose={() => setIsModalOpen(false)}>
        <Paper style={{ padding: '20px', maxWidth: '500px', margin: '20px auto' }}>
          {renderModalContent()}
        </Paper>
      </Modal>
      <Snackbar
        open={!!snackbar}
        autoHideDuration={6000}
        onClose={() => setSnackbar(null)}
      >
        <Alert
          onClose={() => setSnackbar(null)}
          severity={snackbar?.severity}
          sx={{ width: '100%' }}
        >
          {snackbar?.message}
        </Alert>
      </Snackbar>
    </div>
  );
};

export default MenuManagementAdmin;

================
File: pages/MenuPage.tsx
================
import React, { useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';
import { useSelector, useDispatch } from 'react-redux';
import { RootState } from '../redux/store';
import { fetchMenu } from '../redux/slices/menuSlice';
import { Menu, MenuGroup, MenuItem } from '../types/menuTypes';
import { MenuService } from '../services/menuService';
import MenuItemCard from '../components/MenuItemCard';
import LoadingSpinner from '../components/LoadingSpinner';
import ErrorMessage from '../components/ErrorMessage';

const MenuPage: React.FC = () => {
  const { clientId } = useParams<{ clientId: string }>();
  const dispatch = useDispatch();
  const menu = useSelector((state: RootState) => state.menu.currentMenu);
  const loading = useSelector((state: RootState) => state.menu.loading);
  const error = useSelector((state: RootState) => state.menu.error);
  const [menuStatistics, setMenuStatistics] = useState<MenuService.MenuStatistics | null>(null);

  useEffect(() => {
    if (clientId) {
      dispatch(fetchMenu(clientId));
      MenuService.getMenuStatistics(clientId)
        .then(stats => setMenuStatistics(stats))
        .catch(err => console.error('Failed to fetch menu statistics:', err));
    }
  }, [clientId, dispatch]);

  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage message={error} />;
  if (!menu) return <ErrorMessage message="Menu not found" />;

  return (
    <div className="menu-page">
      <h1>{menu.name}</h1>
      {menuStatistics && (
        <div className="menu-statistics">
          <p>Total Items: {menuStatistics.totalItems}</p>
          <h3>Most Popular Items:</h3>
          <ul>
            {menuStatistics.mostPopularItems.map((item) => (
              <li key={item.name}>{item.name} - Ordered {item.orderCount} times</li>
            ))}
          </ul>
        </div>
      )}
      {menu.menuGroups.map((group: MenuGroup) => (
        <div key={group.id} className="menu-group">
          <h2>{group.name}</h2>
          <div className="menu-items">
            {group.items.map((item: MenuItem) => (
              <MenuItemCard key={item.id} item={item} />
            ))}
          </div>
        </div>
      ))}
    </div>
  );
};

export default MenuPage;

================
File: pages/OrderConfirmation.tsx
================
import React from 'react';
import { Typography, Paper } from '@mui/material';
import { useParams } from 'react-router-dom';

const OrderConfirmation: React.FC = () => {
  const { orderId } = useParams<{ orderId: string }>();

  return (
    <Paper
      elevation={3}
      style={{ padding: '20px', maxWidth: '600px', margin: '0 auto' }}
    >
      <Typography variant="h4" gutterBottom>
        Order Confirmation
      </Typography>
      <Typography variant="h6" gutterBottom>
        Thank you for your order!
      </Typography>
      <Typography>
        Your order number is: <strong>{orderId}</strong>
      </Typography>
      <Typography>
        We&apos;ve sent a confirmation email with your order details.
      </Typography>
    </Paper>
  );
};

export default OrderConfirmation;

================
File: pages/OrderPage.tsx
================
import React, { useEffect, useState } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import { fetchMenu, selectMenu } from '../redux/slices/menuSlice';
import { addToCart, removeFromCart, updateCartItemQuantity, selectCartItems } from '../redux/slices/cartSlice';
import { Menu, MenuGroup, MenuItem, Modifier, CartItem } from '../types/menuTypes';
import { useSelectedLocation } from '../hooks/useSelectedLocation';

const OrderPage: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { selectedLocation } = useSelectedLocation();
  const menu = useSelector((state: RootState) => selectMenu(state));
  const cartItems = useSelector((state: RootState) => selectCartItems(state));
  const [itemQuantities, setItemQuantities] = useState<Record<string, number>>({});
  const [selectedModifiers, setSelectedModifiers] = useState<Record<string, Record<string, Modifier>>>({});
  const [activeGroup, setActiveGroup] = useState<string | null>(null);

  useEffect(() => {
    if (selectedLocation) {
      dispatch(fetchMenu(selectedLocation));
    }
  }, [dispatch, selectedLocation]);

  useEffect(() => {
    if (menu && menu.menuGroups.length > 0) {
      setActiveGroup(menu.menuGroups[0].id);
    }
  }, [menu]);

  const handleQuantityChange = (itemId: string, quantity: number) => {
    setItemQuantities(prev => ({ ...prev, [itemId]: quantity }));
  };

  const handleModifierSelection = (itemId: string, modifier: Modifier) => {
    setSelectedModifiers(prev => ({
      ...prev,
      [itemId]: {
        ...prev[itemId],
        [modifier.id]: modifier
      }
    }));
  };

  const handleAddToCart = (item: MenuItem) => {
    const quantity = itemQuantities[item.id] || 1;
    dispatch(addToCart({
      menuItem: {
        id: item.id,
        name: item.name,
        price: item.price
      },
      quantity: quantity,
      selectedModifiers: Object.values(selectedModifiers[item.id] || {})
    }));
    setItemQuantities(prev => ({ ...prev, [item.id]: 1 }));
    setSelectedModifiers(prev => ({ ...prev, [item.id]: {} }));
  };

  const handleRemoveFromCart = (itemId: string) => {
    dispatch(removeFromCart(itemId));
  };

  const handleUpdateCartQuantity = (itemId: string, quantity: number) => {
    dispatch(updateCartItemQuantity({ id: itemId, quantity }));
  };

  const getEffectivePrice = (item: MenuItem | Modifier) => {
    return item.localOverrides?.price ?? item.price;
  };

  const getEffectiveName = (item: MenuItem | Modifier) => {
    return item.localOverrides?.name ?? item.name;
  };

  const isItemAvailable = (item: MenuItem) => {
    return item.localOverrides?.isAvailable ?? item.isAvailable;
  };

  if (!menu) return <div>Loading menu...</div>;

  return (
    <div className="order-page">
      <h1>Order Page for {selectedLocation?.name}</h1>
      
      <div className="menu-navigation">
        {menu.menuGroups.map((group: MenuGroup) => (
          <button 
            key={group.id}
            onClick={() => setActiveGroup(group.id)}
            className={activeGroup === group.id ? 'active' : ''}
          >
            {group.name}
          </button>
        ))}
      </div>

      <div className="menu-container">
        {menu.menuGroups
          .filter((group: MenuGroup) => activeGroup === group.id)
          .map((group: MenuGroup) => (
          <div key={group.id} className="menu-group">
            <h2>{group.name}</h2>
            {group.items.map((item: MenuItem) => (
              <div key={item.id} className="menu-item">
                <h3>{getEffectiveName(item)} - ${getEffectivePrice(item).toFixed(2)}</h3>
                <p>{item.description}</p>
                {isItemAvailable(item) ? (
                  <>
                    <input 
                      type="number" 
                      value={itemQuantities[item.id] || 1} 
                      onChange={(e) => handleQuantityChange(item.id, Math.max(1, parseInt(e.target.value) || 1))}
                      min="1"
                    />
                    {item.modifiers && item.modifiers.map(modifier => (
                      <label key={modifier.id}>
                        <input
                          type="checkbox"
                          onChange={() => handleModifierSelection(item.id, modifier)}
                          checked={!!selectedModifiers[item.id]?.[modifier.id]}
                        />
                        {getEffectiveName(modifier)} (+${getEffectivePrice(modifier).toFixed(2)})
                      </label>
                    ))}
                    <button onClick={() => handleAddToCart(item)}>Add to Cart</button>
                  </>
                ) : (
                  <p>Currently unavailable</p>
                )}
              </div>
            ))}
          </div>
        ))}
      </div>

      <div className="cart-container">
        <h2>Cart</h2>
        {cartItems.map((cartItem: CartItem) => (
          <div key={cartItem.menuItem.id} className="cart-item">
            <h3>{cartItem.menuItem.name}</h3>
            <p>Price: ${cartItem.menuItem.price.toFixed(2)}</p>
            <p>Quantity: 
              <input 
                type="number" 
                value={cartItem.quantity} 
                onChange={(e) => handleUpdateCartQuantity(cartItem.menuItem.id, Math.max(1, parseInt(e.target.value) || 1))}
                min="1"
              />
            </p>
            {cartItem.selectedModifiers.length > 0 && (
              <div>
                <h4>Selected Modifiers:</h4>
                <ul>
                  {cartItem.selectedModifiers.map((modifier) => (
                    <li key={modifier.id}>{modifier.name} (+${modifier.price.toFixed(2)})</li>
                  ))}
                </ul>
              </div>
            )}
            <button onClick={() => handleRemoveFromCart(cartItem.menuItem.id)}>Remove</button>
          </div>
        ))}
      </div>
    </div>
  );
};

export default OrderPage;

================
File: pages/OrderScheduling.tsx
================
import React, { useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import { fetchLocations, selectLocations } from '../redux/slices/locationSlice';
import { Location } from '../types/locationTypes';

const OrderScheduling: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const locations = useSelector(selectLocations);

  useEffect(() => {
    dispatch(fetchLocations());
  }, [dispatch]);

  return (
    <div>
      <h2>Order Scheduling</h2>
      <select>
        {locations.map((location: Location) => (
          <option key={location.id} value={location.id}>
            {location.name}
          </option>
        ))}
      </select>
    </div>
  );
};

export default OrderScheduling;

================
File: pages/PosProfilePage.tsx
================
import React, { useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import { fetchLocationPOSProfiles, selectLocationPOSProfiles, selectPOSProfileLoading, selectPOSProfileError } from '../redux/slices/posProfileSlice';
import { LocationPOSProfile } from '../types/posTypes';
import { useSelectedLocation } from '../hooks/useSelectedLocation';

const PosProfilePage: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { selectedLocation } = useSelectedLocation();
  const locationProfiles = useSelector(selectLocationPOSProfiles);
  const loading = useSelector(selectPOSProfileLoading);
  const error = useSelector(selectPOSProfileError);

  useEffect(() => {
    if (selectedLocation) {
      dispatch(fetchLocationPOSProfiles(selectedLocation));
    }
  }, [dispatch, selectedLocation]);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <div>
      <h2>POS Profiles for Location: {selectedLocation}</h2>
      {locationProfiles.length === 0 ? (
        <p>No POS profiles found for this location.</p>
      ) : (
        locationProfiles.map((profile: LocationPOSProfile) => (
          <div key={profile.id}>
            <h3>Profile ID: {profile.id}</h3>
            <p>Core POS Profile ID: {profile.corePOSProfileId}</p>
            <p>Last Sync Status: {profile.lastSyncStatus}</p>
            {profile.lastSyncError && <p>Last Sync Error: {profile.lastSyncError}</p>}
            <h4>Custom Settings:</h4>
            <ul>
              {Object.entries(profile.customSettings).map(([key, value]) => (
                <li key={key}>{key}: {value.toString()}</li>
              ))}
            </ul>
          </div>
        ))
      )}
    </div>
  );
};

export default PosProfilePage;

================
File: pages/PosSettingsPage.tsx
================
import React, { useEffect, useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { AppDispatch, RootState } from '../redux/store';
import { fetchPOSSettings, updatePOSSettings, selectPOSSettingsForLocation } from '../redux/slices/posSettingsSlice';
import { useSelectedLocation } from '../hooks/useSelectedLocation';
import { POSSettings } from '../types/posSettingsTypes';

const PosSettingsPage: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { selectedLocation } = useSelectedLocation();
  const posSettings = useSelector((state: RootState) => 
    selectedLocation ? selectPOSSettingsForLocation(state, selectedLocation) : null
  );
  const [localSettings, setLocalSettings] = useState<Partial<POSSettings>>({});

  useEffect(() => {
    if (selectedLocation) {
      dispatch(fetchPOSSettings(selectedLocation));
    }
  }, [dispatch, selectedLocation]);

  useEffect(() => {
    if (posSettings) {
      setLocalSettings(posSettings);
    }
  }, [posSettings]);

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
    const { name, value, type } = e.target;
    setLocalSettings(prev => ({ 
      ...prev, 
      [name]: type === 'checkbox' ? (e.target as HTMLInputElement).checked : value 
    }));
  };

  const handleCustomSettingChange = (key: string, value: string | number | boolean) => {
    setLocalSettings(prev => ({
      ...prev,
      customSettings: {
        ...prev.customSettings,
        [key]: value
      }
    }));
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (selectedLocation) {
      dispatch(updatePOSSettings({ locationId: selectedLocation, settings: localSettings }));
    }
  };

  if (!posSettings) {
    return <div>Loading POS settings...</div>;
  }

  return (
    <div>
      <h1>POS Settings for {selectedLocation}</h1>
      <form onSubmit={handleSubmit}>
        <div>
          <label>POS System: {posSettings.posSystem}</label>
        </div>
        <div>
          <label htmlFor="apiKey">API Key:</label>
          <input
            type="text"
            id="apiKey"
            name="apiKey"
            value={localSettings.apiKey || ''}
            onChange={handleInputChange}
          />
        </div>
        <div>
          <label htmlFor="apiEndpoint">API Endpoint:</label>
          <input
            type="text"
            id="apiEndpoint"
            name="apiEndpoint"
            value={localSettings.apiEndpoint || ''}
            onChange={handleInputChange}
          />
        </div>
        <div>
          <label htmlFor="syncFrequency">Sync Frequency (minutes):</label>
          <input
            type="number"
            id="syncFrequency"
            name="syncFrequency"
            value={localSettings.syncFrequency || 0}
            onChange={handleInputChange}
          />
        </div>
        <div>
          <label htmlFor="menuSyncEnabled">Menu Sync Enabled:</label>
          <input
            type="checkbox"
            id="menuSyncEnabled"
            name="menuSyncEnabled"
            checked={localSettings.menuSyncEnabled || false}
            onChange={handleInputChange}
          />
        </div>
        <div>
          <label htmlFor="inventorySyncEnabled">Inventory Sync Enabled:</label>
          <input
            type="checkbox"
            id="inventorySyncEnabled"
            name="inventorySyncEnabled"
            checked={localSettings.inventorySyncEnabled || false}
            onChange={handleInputChange}
          />
        </div>
        <div>
          <label htmlFor="orderSyncEnabled">Order Sync Enabled:</label>
          <input
            type="checkbox"
            id="orderSyncEnabled"
            name="orderSyncEnabled"
            checked={localSettings.orderSyncEnabled || false}
            onChange={handleInputChange}
          />
        </div>
        <div>
          <label>Last Sync: {posSettings.lastSyncTimestamp ? new Date(posSettings.lastSyncTimestamp).toLocaleString() : 'Never'}</label>
        </div>
        <h2>Custom Settings</h2>
        {Object.entries(posSettings.customSettings || {}).map(([key, value]) => (
          <div key={key}>
            <label htmlFor={key}>{key}:</label>
            <input
              type={typeof value === 'boolean' ? 'checkbox' : 'text'}
              id={key}
              name={key}
              value={typeof value !== 'boolean' ? value : undefined}
              checked={typeof value === 'boolean' ? value : undefined}
              onChange={(e) => handleCustomSettingChange(key, e.target.type === 'checkbox' ? e.target.checked : e.target.value)}
            />
          </div>
        ))}
        <button type="submit">Save POS Settings</button>
      </form>
    </div>
  );
};

export default PosSettingsPage;

================
File: pages/ProfilePage.tsx
================
import React, { useState, useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import { updateUserProfile, selectCurrentUser } from '../redux/slices/userSlice';

const ProfilePage: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const userProfile = useSelector(selectCurrentUser);
  const [firstName, setFirstName] = useState(userProfile?.firstName || '');
  const [lastName, setLastName] = useState(userProfile?.lastName || '');
  const [email, setEmail] = useState(userProfile?.email || '');
  const [restaurantName, setRestaurantName] = useState(userProfile?.restaurantName || '');
  const [cuisineType, setCuisineType] = useState(userProfile?.cuisineType || '');
  const [phoneNumber, setPhoneNumber] = useState(userProfile?.phoneNumber || '');
  const [address, setAddress] = useState(userProfile?.address || '');
  const [timeZone, setTimeZone] = useState(userProfile?.timeZone || '');
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (userProfile) {
      setFirstName(userProfile.firstName);
      setLastName(userProfile.lastName);
      setEmail(userProfile.email);
      setRestaurantName(userProfile.restaurantName || '');
      setCuisineType(userProfile.cuisineType || '');
      setPhoneNumber(userProfile.phoneNumber || '');
      setAddress(userProfile.address || '');
      setTimeZone(userProfile.timeZone || '');
    }
  }, [userProfile]);

  const handleUpdateProfile = async () => {
    try {
      await dispatch(updateUserProfile({
        firstName,
        lastName,
        email,
        restaurantName,
        cuisineType,
        phoneNumber,
        address,
        timeZone
      })).unwrap();
      setError(null);
    } catch (err) {
      setError('Failed to update profile. Please try again.');
    }
  };

  if (!userProfile) {
    return <div>Loading...</div>;
  }

  return (
    <div className="profile-page">
      <h2>Restaurant Profile</h2>
      {error && <div className="error">{error}</div>}
      <div>
        <label htmlFor="firstName">First Name:</label>
        <input
          type="text"
          id="firstName"
          value={firstName}
          onChange={(e) => setFirstName(e.target.value)}
        />
      </div>
      <div>
        <label htmlFor="lastName">Last Name:</label>
        <input
          type="text"
          id="lastName"
          value={lastName}
          onChange={(e) => setLastName(e.target.value)}
        />
      </div>
      <div>
        <label htmlFor="email">Email:</label>
        <input
          type="email"
          id="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
        />
      </div>
      <div>
        <label htmlFor="restaurantName">Restaurant Name:</label>
        <input
          type="text"
          id="restaurantName"
          value={restaurantName}
          onChange={(e) => setRestaurantName(e.target.value)}
        />
      </div>
      <div>
        <label htmlFor="cuisineType">Cuisine Type:</label>
        <input
          type="text"
          id="cuisineType"
          value={cuisineType}
          onChange={(e) => setCuisineType(e.target.value)}
        />
      </div>
      <div>
        <label htmlFor="phoneNumber">Phone Number:</label>
        <input
          type="tel"
          id="phoneNumber"
          value={phoneNumber}
          onChange={(e) => setPhoneNumber(e.target.value)}
        />
      </div>
      <div>
        <label htmlFor="address">Address:</label>
        <input
          type="text"
          id="address"
          value={address}
          onChange={(e) => setAddress(e.target.value)}
        />
      </div>
      <div>
        <label htmlFor="timeZone">Time Zone:</label>
        <input
          type="text"
          id="timeZone"
          value={timeZone}
          onChange={(e) => setTimeZone(e.target.value)}
        />
      </div>
      <button onClick={handleUpdateProfile}>Update Profile</button>
    </div>
  );
};

export default ProfilePage;

================
File: pages/Register.tsx
================
import React, { useState, useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { AppDispatch, RootState } from '../redux/store';
import { register, selectAuthStatus } from '../redux/slices/authSlice';
import { useNavigate } from 'react-router-dom';

const Register: React.FC = () => {
  const [username, setUsername] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [error, setError] = useState<string | null>(null);

  const dispatch = useDispatch<AppDispatch>();
  const navigate = useNavigate();
  const status = useSelector(selectAuthStatus);

  useEffect(() => {
    if (status === 'succeeded') {
      navigate('/login');
    }
  }, [status, navigate]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);

    if (password !== confirmPassword) {
      setError("Passwords don't match");
      return;
    }

    try {
      await dispatch(register({ username, email, password })).unwrap();
    } catch (err) {
      setError('Registration failed. Please try again.');
    }
  };

  return (
    <div className="register-page">
      <h2>Register for Our Restaurant Ordering Hub</h2>
      {error && <div className="error">{error}</div>}
      <form onSubmit={handleSubmit}>
        <div>
          <label htmlFor="username">Username:</label>
          <input
            type="text"
            id="username"
            value={username}
            onChange={(e) => setUsername(e.target.value)}
            required
          />
        </div>
        <div>
          <label htmlFor="email">Email:</label>
          <input
            type="email"
            id="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
          />
        </div>
        <div>
          <label htmlFor="password">Password:</label>
          <input
            type="password"
            id="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            required
          />
        </div>
        <div>
          <label htmlFor="confirmPassword">Confirm Password:</label>
          <input
            type="password"
            id="confirmPassword"
            value={confirmPassword}
            onChange={(e) => setConfirmPassword(e.target.value)}
            required
          />
        </div>
        <button type="submit" disabled={status === 'loading'}>
          {status === 'loading' ? 'Registering...' : 'Register'}
        </button>
      </form>
    </div>
  );
};

export default Register;

================
File: pages/ReportingDashboard.tsx
================
import React, { useState, useEffect, lazy, Suspense } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { RootState, AppDispatch } from '../redux/store';
import { fetchDashboardData } from '../redux/slices/dashboardSlice';
import { selectCurrentUser, selectSelectedLocation } from '../redux/slices/userSlice';
import { CircularProgress, Grid, Paper, Typography, Button, Tabs, Tab, Box } from '@mui/material';
import { DateRange, DashboardParams, DashboardData, ChartData, LocationComparisonData } from '../types/dashboardTypes';
import { DateRangePicker } from '@mui/x-date-pickers-pro/DateRangePicker';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import LocationSelector from '../components/LocationSelector';

const LazyBarChart = lazy(() => import('../components/LazyBarChart'));
const LazyLocationComparisonChart = lazy(() => import('../components/LazyLocationComparisonChart'));

const ReportingDashboard: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { data, loading, error } = useSelector((state: RootState) => state.dashboard);
  const user = useSelector(selectCurrentUser);
  const selectedLocation = useSelector(selectSelectedLocation);
  const [dateRange, setDateRange] = useState<DateRange>({ startDate: null, endDate: null });
  const [activeTab, setActiveTab] = useState(0);
  const [showComparison, setShowComparison] = useState(false);

  useEffect(() => {
    if (dateRange.startDate && dateRange.endDate && selectedLocation) {
      const params: DashboardParams = {
        dateRange,
        clientId: user?.clientId,
        locationId: selectedLocation, // Change to locationId
      };
      dispatch(fetchDashboardData(params));
    }
  }, [dispatch, dateRange, user, selectedLocation]);

  const handleDateRangeChange = (newDateRange: DateRange) => {
    setDateRange(newDateRange);
  };

  const handleTabChange = (event: React.SyntheticEvent, newValue: number) => {
    setActiveTab(newValue);
  };

  const handleRefresh = () => {
    if (dateRange.startDate && dateRange.endDate && selectedLocation) {
      const params: DashboardParams = {
        dateRange,
        clientId: user?.clientId,
        locationId: selectedLocation, // Change to locationId
      };
      dispatch(fetchDashboardData(params));
    }
  };

  if (loading) return <CircularProgress />;
  if (error) return <Typography color="error">{error}</Typography>;
  if (!data) return <Typography>No data available</Typography>;

  return (
    <Box className="reporting-dashboard">
      <LocalizationProvider dateAdapter={AdapterDateFns}>
        <DateRangePicker
          value={[dateRange.startDate, dateRange.endDate]}
          onChange={(newValue: [Date | null, Date | null]) => 
            handleDateRangeChange({ startDate: newValue[0], endDate: newValue[1] })
          }
        />
      </LocalizationProvider>
      <Button onClick={handleRefresh} variant="contained" color="primary">Refresh Data</Button>
      
      <Grid container spacing={3} sx={{ mt: 2 }}>
        <Grid item xs={12} md={6}>
          <Paper className="p-4">
            <Typography variant="h6">Total Orders</Typography>
            <Typography variant="h4">{data?.totalOrders ?? 'N/A'}</Typography>
          </Paper>
        </Grid>
        <Grid item xs={12} md={3}>
          <Paper elevation={3} sx={{ p: 2 }}>
            <Typography variant="h6">Total Revenue</Typography>
            <Typography variant="h4">${data?.revenue?.toFixed(2) ?? 'N/A'}</Typography>
          </Paper>
        </Grid>
        <Grid item xs={12} md={3}>
          <Paper elevation={3} sx={{ p: 2 }}>
            <Typography variant="h6">Avg. Order Value</Typography>
            <Typography variant="h4">${data?.averageOrderValue?.toFixed(2) ?? 'N/A'}</Typography>
          </Paper>
        </Grid>
        <Grid item xs={12} md={3}>
          <Paper elevation={3} sx={{ p: 2 }}>
            <Typography variant="h6">Customer Retention</Typography>
            <Typography variant="h4">{data?.customerRetentionRate ? `${data?.customerRetentionRate}%` : 'N/A'}</Typography>
          </Paper>
        </Grid>
      </Grid>

      <Tabs value={activeTab} onChange={handleTabChange} sx={{ mt: 2 }}>
        <Tab label="Revenue" />
        <Tab label="Order Trends" />
        <Tab label="Menu Performance" />
        <Tab label="Customer Insights" />
      </Tabs>

      <Suspense fallback={<CircularProgress />}>
        {activeTab === 0 && data?.revenueOverTime && <LazyBarChart data={data.revenueOverTime} title="Revenue Over Time" />}
        {activeTab === 1 && data?.orderTrends && <LazyBarChart data={data.orderTrends} title="Order Trends" />}
        {activeTab === 2 && data?.menuPerformance && <LazyBarChart data={data.menuPerformance} title="Menu Performance" />}
        {activeTab === 3 && data?.customerInsights && <LazyBarChart data={data.customerInsights} title="Customer Insights" />}
      </Suspense>

      <Button onClick={() => setShowComparison(!showComparison)} variant="outlined" color="primary" sx={{ mt: 2 }}>
        {showComparison ? "Hide Comparison" : "Compare Locations"}
      </Button>

      {showComparison && data?.locationComparison && (
        <Suspense fallback={<CircularProgress />}>
          <LazyLocationComparisonChart data={data.locationComparison} />
        </Suspense>
      )}

    </Box>
  );
};

export default ReportingDashboard;

================
File: pages/UserManagement.tsx
================
import React, { useEffect, useState, useMemo } from 'react';
import {
  Typography,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Button,
  Modal,
  TextField,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  Snackbar,
  Alert,
  CircularProgress,
} from '@mui/material';
import { User, UserRole } from '../types/userTypes';
import { userService } from '../services/userService';

const UserManagement: React.FC = () => {
  const [users, setUsers] = useState<User[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [selectedUser, setSelectedUser] = useState<User | null>(null);
  const [snackbar, setSnackbar] = useState<{
    message: string;
    severity: 'success' | 'error';
  } | null>(null);

  const userServiceInstance = useMemo(() => new userService(), []);

  useEffect(() => {
    const fetchUsers = async () => {
      try {
        const data = await userServiceInstance.getUsers();
        setUsers(data);
        setLoading(false);
      } catch (error) {
        setError('Failed to load users. Please try again.');
        setLoading(false);
      }
    };

    fetchUsers();
  }, [userServiceInstance]);

  const handleAddUser = () => {
    setSelectedUser({
      id: '',
      email: '',
      role: UserRole.EMPLOYEE,
      clientId: '',
    });
    setIsModalOpen(true);
  };

  const handleEditUser = (user: User) => {
    setSelectedUser(user);
    setIsModalOpen(true);
  };

  const handleSaveUser = async () => {
    if (!selectedUser) return;

    try {
      let updatedUser: User;
      if (selectedUser.id === '') {
        updatedUser = await userServiceInstance.createUser(selectedUser);
        setUsers([...users, updatedUser]);
      } else {
        updatedUser = await userServiceInstance.updateUser(
          selectedUser.id,
          selectedUser
        );
        setUsers(
          users.map((user) => (user.id === updatedUser.id ? updatedUser : user))
        );
      }
      setIsModalOpen(false);
      setSnackbar({ message: 'User saved successfully', severity: 'success' });
    } catch (err) {
      setSnackbar({
        message: 'Failed to save user. Please try again.',
        severity: 'error',
      });
    }
  };

  const handleDeleteUser = async (userId: string) => {
    if (window.confirm('Are you sure you want to delete this user?')) {
      try {
        await userServiceInstance.deleteUser(userId);
        setUsers(users.filter((user) => user.id !== userId));
        setSnackbar({
          message: 'User deleted successfully',
          severity: 'success',
        });
      } catch (err) {
        setSnackbar({
          message: 'Failed to delete user. Please try again.',
          severity: 'error',
        });
      }
    }
  };

  if (loading) return <CircularProgress />;
  if (error) return <Typography color="error">{error}</Typography>;

  return (
    <div>
      <Typography variant="h4" component="h1" gutterBottom>
        User Management
      </Typography>
      <Button onClick={handleAddUser} variant="contained" color="primary">
        Add User
      </Button>
      <TableContainer component={Paper}>
        <Table>
          <TableHead>
            <TableRow>
              <TableCell>Email</TableCell>
              <TableCell>Role</TableCell>
              <TableCell>Actions</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {users.map((user) => (
              <TableRow key={user.id}>
                <TableCell>{user.email}</TableCell>
                <TableCell>{user.role}</TableCell>
                <TableCell>
                  <Button onClick={() => handleEditUser(user)}>Edit</Button>
                  <Button onClick={() => handleDeleteUser(user.id)}>
                    Delete
                  </Button>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>
      <Modal open={isModalOpen} onClose={() => setIsModalOpen(false)}>
        <Paper
          style={{
            padding: '20px',
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            maxWidth: '400px',
            width: '100%',
          }}
        >
          {selectedUser && (
            <form
              onSubmit={(e) => {
                e.preventDefault();
                handleSaveUser();
              }}
            >
              <Typography variant="h6" gutterBottom>
                {selectedUser.id === '' ? 'Add New User' : 'Edit User'}
              </Typography>
              <TextField
                label="Email"
                value={selectedUser.email}
                onChange={(e) =>
                  setSelectedUser({ ...selectedUser, email: e.target.value })
                }
                fullWidth
                margin="normal"
              />
              <FormControl fullWidth margin="normal">
                <InputLabel>Role</InputLabel>
                <Select
                  value={selectedUser.role}
                  onChange={(e) =>
                    setSelectedUser({
                      ...selectedUser,
                      role: e.target.value as UserRole,
                    })
                  }
                >
                  {Object.values(UserRole).map((role) => (
                    <MenuItem key={role} value={role}>
                      {role}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
              <Button
                type="submit"
                variant="contained"
                color="primary"
                fullWidth
                style={{ marginTop: '20px' }}
              >
                Save User
              </Button>
            </form>
          )}
        </Paper>
      </Modal>
      <Snackbar
        open={!!snackbar}
        autoHideDuration={6000}
        onClose={() => setSnackbar(null)}
      >
        <Alert
          onClose={() => setSnackbar(null)}
          severity={snackbar?.severity}
          sx={{ width: '100%' }}
        >
          {snackbar?.message}
        </Alert>
      </Snackbar>
    </div>
  );
};

export default UserManagement;

================
File: pages/Wallet.tsx
================
import React, { useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import {
  loadWalletData,
  fetchWalletBalance,
  selectWalletBalance,
  selectWalletRewards,
  selectWalletDiscounts,
} from '../redux/slices/walletSlice';
import { AppDispatch } from '../redux/store';

interface Reward {
  id: string;
  name: string;
}

interface Discount {
  id: string;
  name: string;
}

const Wallet: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const balance = useSelector(selectWalletBalance);
  const rewards = useSelector(selectWalletRewards);
  const discounts = useSelector(selectWalletDiscounts);

  useEffect(() => {
    dispatch(loadWalletData());
    dispatch(fetchWalletBalance());
  }, [dispatch]);

  return (
    <div>
      <h2>Your Wallet</h2>
      <p>Balance: ${(balance as number).toFixed(2)}</p>

      <h3>Rewards</h3>
      {(rewards as Reward[]).length > 0 ? (
        <ul>
          {(rewards as Reward[]).map((reward: Reward) => (
            <li key={reward.id}>{reward.name}</li>
          ))}
        </ul>
      ) : (
        <p>No rewards available</p>
      )}

      <h3>Discounts</h3>
      {(discounts as Discount[]).length > 0 ? (
        <ul>
          {(discounts as Discount[]).map((discount: Discount) => (
            <li key={discount.id}>{discount.name}</li>
          ))}
        </ul>
      ) : (
        <p>No discounts available</p>
      )}
    </div>
  );
};

export default Wallet;

================
File: redux/slices/abTestSlice.ts
================
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { ABTestService } from '../../services/abTestService';
import { ABTest } from '../../types/abTestTypes';
import { RootState } from '../rootReducer'; // Update this import if necessary
import { fetchABTests } from 'frontend/src/api/abTestApi';

interface ABTestState {
  tests: ABTest[];
  status: 'idle' | 'loading' | 'succeeded' | 'failed';
  error: string | null;
}

const initialState: ABTestState = {
  tests: [],
  status: 'idle',
  error: null,
};

export const fetchABTests = createAsyncThunk<ABTest[], void, { rejectValue: string }>(
  'abTest/fetchABTests',
  async (_, { rejectWithValue }) => {
    try {
      return await ABTestService.fetchABTests();
    } catch (error) {
      return rejectWithValue('Failed to fetch AB tests');
    }
  }
);

export const createABTest = createAsyncThunk<ABTest, Omit<ABTest, 'id'>, { rejectValue: string }>(
  'abTest/createABTest',
  async (abTest, { rejectWithValue }) => {
    try {
      return await ABTestService.createABTest(abTest);
    } catch (error) {
      return rejectWithValue('Failed to create AB test');
    }
  }
);

export const updateABTest = createAsyncThunk<ABTest, { id: string; abTest: Partial<ABTest> }, { rejectValue: string }>(
  'abTest/updateABTest',
  async ({ id, abTest }, { rejectWithValue }) => {
    try {
      return await ABTestService.updateABTest(id, abTest);
    } catch (error) {
      return rejectWithValue('Failed to update AB test');
    }
  }
);

const abTestSlice = createSlice({
  name: 'abTest',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchABTests.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchABTests.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.tests = action.payload;
      })
      .addCase(fetchABTests.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.payload || 'An unknown error occurred';
      })
      .addCase(createABTest.fulfilled, (state, action) => {
        state.tests.push(action.payload);
      })
      .addCase(updateABTest.fulfilled, (state, action) => {
        const index = state.tests.findIndex(test => test.id === action.payload.id);
        if (index !== -1) {
          state.tests[index] = action.payload;
        }
      });
  },
});

export default abTestSlice.reducer;

// Selectors
export const selectABTests = (state: RootState) => state.abTest.tests;
export const selectABTestStatus = (state: RootState) => state.abTest.status;
export const selectABTestError = (state: RootState) => state.abTest.error;

================
File: redux/slices/auditLogSlice.ts
================
import { createSlice, PayloadAction } from '@reduxjs/toolkit';

interface AuditLogEntry {
  id: string;
  userId: string;
  action: string;
  timestamp: string;
  details: Record<string, unknown>;
}

interface AuditLogState {
  logs: AuditLogEntry[];
  loading: boolean;
  error: string | null;
}

const initialState: AuditLogState = {
  logs: [],
  loading: false,
  error: null,
};

const auditLogSlice = createSlice({
  name: 'auditLog',
  initialState,
  reducers: {
    fetchLogsStart(state) {
      state.loading = true;
      state.error = null;
    },
    fetchLogsSuccess(state, action: PayloadAction<AuditLogEntry[]>) {
      state.logs = action.payload;
      state.loading = false;
    },
    fetchLogsFailure(state, action: PayloadAction<string>) {
      state.loading = false;
      state.error = action.payload;
    },
    addLogEntry(state, action: PayloadAction<AuditLogEntry>) {
      state.logs.unshift(action.payload);
    },
  },
});

export const {
  fetchLogsStart,
  fetchLogsSuccess,
  fetchLogsFailure,
  addLogEntry,
} = auditLogSlice.actions;

export default auditLogSlice.reducer;

================
File: redux/slices/authSlice.ts
================
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { RootState } from '../store';
import api from '../../services/api';

interface AuthState {
  isAuthenticated: boolean;
  user: {
    id: string;
    role: 'global_admin' | 'client_admin' | 'user';
    clientId?: string;
  } | null;
  token: string | null;
  status: 'idle' | 'loading' | 'succeeded' | 'failed';
  error: string | null;
}

const initialState: AuthState = {
  isAuthenticated: false,
  user: null,
  token: null,
  status: 'idle',
  error: null,
};

export const register = createAsyncThunk(
  'auth/register',
  async (userData: { username: string; email: string; password: string }, { rejectWithValue }) => {
    try {
      const response = await api.post('/auth/register', userData);
      return response.data;
    } catch (error) {
      return rejectWithValue('Registration failed. Please try again.');
    }
  }
);

const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    setCredentials: (state, action: PayloadAction<{ user: any; token: string }>) => {
      const { user, token } = action.payload;
      state.user = user;
      state.token = token;
      state.isAuthenticated = true;
    },
    logout: (state) => {
      state.user = null;
      state.token = null;
      state.isAuthenticated = false;
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(register.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(register.fulfilled, (state, action) => {
        state.status = 'succeeded';
        // You might want to automatically log in the user here,
        // or you might want to require email verification first
      })
      .addCase(register.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.payload as string;
      });
  },
});

export const { setCredentials, logout } = authSlice.actions;

export const selectCurrentUser = (state: RootState) => state.auth.user;
export const selectIsAuthenticated = (state: RootState) => state.auth.isAuthenticated;
export const selectAuthStatus = (state: RootState) => state.auth.status;

export default authSlice.reducer;

================
File: redux/slices/brandingSlice.ts
================
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { BrandingState, BrandingProfile } from '../../types';
import { brandingService } from '../../services/brandingService';

const initialState: BrandingState = {
  profiles: [],
  status: 'idle',
  error: null,
};

export const fetchBrandingProfiles = createAsyncThunk(
  'branding/fetchProfiles',
  async () => {
    return await brandingService.getBrandingProfiles();
  }
);

export const createBrandingProfile = createAsyncThunk(
  'branding/createProfile',
  async (profileData: Partial<BrandingProfile>) => {
    return await brandingService.createBrandingProfile(profileData);
  }
);

export const updateBrandingProfile = createAsyncThunk(
  'branding/updateProfile',
  async (profileData: BrandingProfile) => {
    return await brandingService.updateBrandingProfile(profileData);
  }
);

export const deleteBrandingProfile = createAsyncThunk(
  'branding/deleteProfile',
  async (id: number) => {
    await brandingService.deleteBrandingProfile(id);
    return id;
  }
);

const brandingSlice = createSlice({
  name: 'branding',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchBrandingProfiles.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchBrandingProfiles.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.profiles = action.payload;
      })
      .addCase(fetchBrandingProfiles.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.error.message || null;
      })
      .addCase(createBrandingProfile.fulfilled, (state, action) => {
        state.profiles.push(action.payload);
      })
      .addCase(updateBrandingProfile.fulfilled, (state, action) => {
        const index = state.profiles.findIndex(
          (profile) => profile.id === action.payload.id
        );
        if (index !== -1) {
          state.profiles[index] = action.payload;
        }
      })
      .addCase(deleteBrandingProfile.fulfilled, (state, action) => {
        state.profiles = state.profiles.filter(
          (profile) => profile.id !== action.payload
        );
      });
  },
});

export default brandingSlice.reducer;

================
File: redux/slices/cartSlice.ts
================
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState } from '../rootReducer';
import { CartItem } from '../../types';

interface CartState {
  items: CartItem[];
}

const initialState: CartState = {
  items: [],
};

const cartSlice = createSlice({
  name: 'cart',
  initialState,
  reducers: {
    addToCart: (state, action: PayloadAction<CartItem>) => {
      state.items.push(action.payload);
    },
    removeFromCart: (state, action: PayloadAction<string>) => {
      state.items = state.items.filter(item => item.menuItem.id !== action.payload);
    },
    updateCartItemQuantity: (state, action: PayloadAction<{ id: string; quantity: number }>) => {
      const item = state.items.find(item => item.menuItem.id === action.payload.id);
      if (item) {
        item.quantity = action.payload.quantity;
      }
    },
  },
});

export const { addToCart, removeFromCart, updateCartItemQuantity } = cartSlice.actions;

export const selectCartItems = (state: RootState) => state.cart.items;

export default cartSlice.reducer;

================
File: redux/slices/cateringOrderSlice.ts
================
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { RootState, CateringOrder } from '../../types';
import axios from 'axios';

interface CateringOrderState {
  cateringOrder: {
    orders: CateringOrder[];
    status: 'idle' | 'loading' | 'succeeded' | 'failed';
  };
}

const initialState: CateringOrderState = {
  cateringOrder: {
    orders: [],
    status: 'idle',
  },
};

export const fetchCateringOrders = createAsyncThunk(
  'cateringOrders/fetchCateringOrders',
  async (_, { rejectWithValue }) => {
    try {
      const response = await axios.get<CateringOrder[]>('/api/catering-orders');
      return response.data;
    } catch (error) {
      return rejectWithValue('Failed to fetch catering orders');
    }
  }
);

export const createCateringOrder = createAsyncThunk(
  'cateringOrders/createCateringOrder',
  async (order: Omit<CateringOrder, 'id'>, { rejectWithValue }) => {
    try {
      const response = await axios.post<CateringOrder>(
        '/api/catering-orders',
        order
      );
      return response.data;
    } catch (error) {
      return rejectWithValue('Failed to create catering order');
    }
  }
);

const cateringOrdersSlice = createSlice({
  name: 'cateringOrder',
  initialState,
  reducers: {
    // ... other reducers
  },
  extraReducers: (builder) => {
    builder.addCase(fetchCateringOrders.fulfilled, (state, action) => {
      state.cateringOrder.orders = action.payload;
      state.cateringOrder.status = 'succeeded';
    });
    // ... other cases
  },
});

export default cateringOrdersSlice.reducer;

export const selectCateringOrders = (state: RootState) =>
  state.cateringOrder.cateringOrder.orders;

================
File: redux/slices/challengeSlice.ts
================
import { createSlice, PayloadAction } from '@reduxjs/toolkit';

export type ChallengeType = 'purchase' | 'visit' | 'referral';
export type ChallengeStatus = 'active' | 'inactive';

export interface Challenge {
  id: string;
  name: string;
  description: string;
  challengeType: ChallengeType;
  targetValue: number;
  reward: number;
  status: ChallengeStatus;
}

interface ChallengeState {
  challenges: Challenge[];
  loading: boolean;
  error: string | null;
}

const initialState: ChallengeState = {
  challenges: [],
  loading: false,
  error: null,
};

const challengeSlice = createSlice({
  name: 'challenge',
  initialState,
  reducers: {
    fetchChallenges: (state) => {
      state.loading = true;
    },
    fetchChallengesSuccess: (state, action: PayloadAction<Challenge[]>) => {
      state.challenges = action.payload;
      state.loading = false;
    },
    fetchChallengesFailure: (state, action: PayloadAction<string>) => {
      state.error = action.payload;
      state.loading = false;
    },
    createChallenge: (state, action: PayloadAction<Challenge>) => {
      state.challenges.push(action.payload);
    },
    updateChallenge: (state, action: PayloadAction<Challenge>) => {
      const index = state.challenges.findIndex(c => c.id === action.payload.id);
      if (index !== -1) {
        state.challenges[index] = action.payload;
      }
    },
  },
});

export const {
  fetchChallenges,
  fetchChallengesSuccess,
  fetchChallengesFailure,
  createChallenge,
  updateChallenge,
} = challengeSlice.actions;

export default challengeSlice.reducer;

================
File: redux/slices/clientBrandingSlice.ts
================
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { fetchClientBranding } from 'frontend/src/api/clientApi';
import { ClientBrandingService } from '../../services/clientBrandingService';
import { ClientBranding } from '../../types/clientTypes';
import { RootState } from '../store';

interface ClientBrandingState {
  data: ClientBranding | null;
  status: 'idle' | 'loading' | 'succeeded' | 'failed';
  error: string | null;
}

const initialState: ClientBrandingState = {
  data: null,
  status: 'idle',
  error: null,
};

export const fetchClientBranding = createAsyncThunk<
  ClientBranding,
  string,
  { rejectValue: string }
>(
  'clientBranding/fetchClientBranding',
  async (clientId, { rejectWithValue }) => {
    try {
      return await ClientBrandingService.fetchClientBranding(clientId);
    } catch (error) {
      return rejectWithValue('Failed to fetch client branding');
    }
  }
);

export const updateClientBranding = createAsyncThunk<
  ClientBranding,
  { clientId: string; brandingData: Partial<ClientBranding> },
  { rejectValue: string }
>(
  'clientBranding/updateClientBranding',
  async ({ clientId, brandingData }, { rejectWithValue }) => {
    try {
      return await ClientBrandingService.updateClientBranding(clientId, brandingData);
    } catch (error) {
      return rejectWithValue('Failed to update client branding');
    }
  }
);

const clientBrandingSlice = createSlice({
  name: 'clientBranding',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchClientBranding.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchClientBranding.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.data = action.payload;
      })
      .addCase(fetchClientBranding.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.payload || 'An unknown error occurred';
      })
      .addCase(updateClientBranding.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(updateClientBranding.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.data = action.payload;
      })
      .addCase(updateClientBranding.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.payload || 'An unknown error occurred';
      });
  },
});

export default clientBrandingSlice.reducer;

// Selectors
export const selectClientBranding = (state: RootState) => state.clientBranding.data;
export const selectClientBrandingStatus = (state: RootState) => state.clientBranding.status;
export const selectClientBrandingError = (state: RootState) => state.clientBranding.error;

================
File: redux/slices/clientConfigSlice.ts
================
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { ClientService } from '../../services/clientService';
import { ClientConfig } from '../../types/clientTypes';
import { RootState } from '../store'; // Add this import
import { fetchClientConfig } from 'frontend/src/api/clientApi';

export const fetchClientConfig = createAsyncThunk<
  ClientConfig,
  void,
  { rejectValue: string }
>(
  'clientConfig/fetchClientConfig',
  async (_, { rejectWithValue }) => {
    try {
      const config = await ClientService.fetchClientConfig();
      return config;
    } catch (error) {
      if (error instanceof Error) {
        return rejectWithValue(error.message);
      }
      return rejectWithValue('An unknown error occurred');
    }
  }
);

const clientConfigSlice = createSlice({
  name: 'clientConfig',
  initialState: {
    config: null as ClientConfig | null,
    status: 'idle' as 'idle' | 'loading' | 'succeeded' | 'failed',
    error: null as string | null,
  },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchClientConfig.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchClientConfig.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.config = action.payload;
      })
      .addCase(fetchClientConfig.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.payload || 'An unknown error occurred';
      });
  },
});

export default clientConfigSlice.reducer;

// Selectors
export const selectClientConfig = (state: RootState) => state.clientConfig.config;
export const selectClientConfigStatus = (state: RootState) => state.clientConfig.status;
export const selectClientConfigError = (state: RootState) => state.clientConfig.error;

================
File: redux/slices/clientSlice.ts
================
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { ClientService } from '../../services/clientService';
import { ClientMetrics } from '../../types/clientTypes';
import { fetchClient } from 'frontend/src/api/clientApi';

interface ClientState {
  metrics: ClientMetrics | null;
  loading: boolean;
  error: string | null;
}

const initialState: ClientState = {
  metrics: null,
  loading: false,
  error: null,
};

export const fetchClientMetrics = createAsyncThunk<
  ClientMetrics,
  string,
  { rejectValue: string }
>(
  'client/fetchMetrics',
  async (locationId, { rejectWithValue }) => {
    try {
      return await ClientService.fetchClientMetrics(locationId);
    } catch (error) {
      return rejectWithValue('Failed to fetch client metrics');
    }
  }
);

const clientSlice = createSlice({
  name: 'client',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchClientMetrics.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchClientMetrics.fulfilled, (state, action) => {
        state.loading = false;
        state.metrics = action.payload;
      })
      .addCase(fetchClientMetrics.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || 'An unknown error occurred';
      });
  },
});

export default clientSlice.reducer;

================
File: redux/slices/dashboardSlice.ts
================
import { createSlice, PayloadAction, createAsyncThunk } from '@reduxjs/toolkit';
import { DashboardData, DashboardParams } from '../../types/dashboardTypes';
import { fetchDashboardDataAPI } from '../../services/dashboardService';

export const fetchDashboardData = createAsyncThunk<DashboardData, DashboardParams, { rejectValue: string }>(
  'dashboard/fetchDashboardData',
  async (params: DashboardParams, { rejectWithValue }) => {
    try {
      const response = await fetchDashboardDataAPI(params);
      return response;
    } catch (error) {
      if (error instanceof Error) {
        return rejectWithValue(error.message);
      }
      return rejectWithValue('An unknown error occurred');
    }
  }
);

interface DashboardState {
  data: DashboardData | null;
  loading: boolean;
  error: string | null;
}

const initialState: DashboardState = {
  data: null,
  loading: false,
  error: null,
};

const dashboardSlice = createSlice({
  name: 'dashboard',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchDashboardData.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchDashboardData.fulfilled, (state, action: PayloadAction<DashboardData>) => {
        state.loading = false;
        state.data = action.payload;
      })
      .addCase(fetchDashboardData.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload ?? 'An error occurred';
      });
  },
});

export default dashboardSlice.reducer;

================
File: redux/slices/discountSlice.ts
================
import { createSlice, PayloadAction, createAsyncThunk } from '@reduxjs/toolkit';
import { RootState } from '../store';
import { fetchDiscounts } from 'frontend/src/api/discountApi';

interface DiscountState {
  discounts: { id: string; name: string; value: number }[];
  status: 'idle' | 'loading' | 'succeeded' | 'failed';
  error: string | null;
}

const initialState: DiscountState = {
  discounts: [],
  status: 'idle',
  error: null,
};

export const fetchDiscounts = createAsyncThunk(
  'discounts/fetchDiscounts',
  async (clientId: number) => {
    const response = await fetchDiscountsByLocation(clientId);
    return response;
  }
);

const discountSlice = createSlice({
  name: 'discounts',
  initialState,
  reducers: {
    addDiscount: (
      state,
      action: PayloadAction<{ id: string; name: string; value: number }>
    ) => {
      state.discounts.push(action.payload);
    },
    updateDiscount: (
      state,
      action: PayloadAction<{ id: string; value: number }>
    ) => {
      const discount = state.discounts.find((d) => d.id === action.payload.id);
      if (discount) {
        discount.value = action.payload.value;
      }
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchDiscounts.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchDiscounts.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.discounts = action.payload;
      })
      .addCase(fetchDiscounts.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.error.message || null;
      });
  },
});

export const selectDiscounts = (state: RootState) => state.discount.discounts;
export const selectDiscountStatus = (state: RootState) => state.discount.status;
export const selectDiscountsError = (state: RootState) => state.discount.error;

export const { addDiscount, updateDiscount } = discountSlice.actions;

export default discountSlice.reducer;

================
File: redux/slices/guestSlice.ts
================
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { GuestMetrics } from '../../types/guestTypes';
import { GuestService } from '../../services/guestService';
import { fetchGuests } from 'frontend/src/api/guestApi';

interface GuestState {
  metrics: GuestMetrics | null;
  loading: boolean;
  error: string | null;
}

const initialState: GuestState = {
  metrics: null,
  loading: false,
  error: null,
};

export const fetchGuestMetrics = createAsyncThunk<
  GuestMetrics,
  string,
  { rejectValue: string }
>(
  'guest/fetchMetrics',
  async (locationId, { rejectWithValue }) => {
    try {
      return await GuestService.fetchGuestMetrics(locationId);
    } catch (error) {
      return rejectWithValue('Failed to fetch guest metrics');
    }
  }
);

const guestSlice = createSlice({
  name: 'guest',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchGuestMetrics.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchGuestMetrics.fulfilled, (state, action) => {
        state.loading = false;
        state.metrics = action.payload;
      })
      .addCase(fetchGuestMetrics.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || 'An unknown error occurred';
      });
  },
});

export default guestSlice.reducer;

================
File: redux/slices/inventorySlice.ts
================
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { RootState } from '../store';
import { InventoryItem } from '../../types';
import { fetchInventory } from 'frontend/src/api/inventoryApi';

interface InventoryState {
  items: InventoryItem[];
  status: 'idle' | 'loading' | 'succeeded' | 'failed';
  error: string | null;
}

const initialState: InventoryState = {
  items: [],
  status: 'idle',
  error: null,
};

export const fetchInventory = createAsyncThunk(
  'inventory/fetchInventory',
  async () => {
    const response = await inventoryService.getInventory();
    return response;
  }
);

export const updateInventoryItem = createAsyncThunk(
  'inventory/updateItem',
  async (item: InventoryItem) => {
    const response = await inventoryService.updateInventoryItem(item);
    return response;
  }
);

const inventorySlice = createSlice({
  name: 'inventory',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchInventory.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchInventory.fulfilled, (state, action: PayloadAction<InventoryItem[]>) => {
        state.status = 'succeeded';
        state.items = action.payload;
      })
      .addCase(fetchInventory.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.error.message || 'Failed to fetch inventory';
      })
      .addCase(updateInventoryItem.fulfilled, (state, action: PayloadAction<InventoryItem>) => {
        const index = state.items.findIndex((item) => item.id === action.payload.id);
        if (index !== -1) {
          state.items[index] = action.payload;
        }
      });
  },
});

export const selectInventoryItems = (state: RootState) => state.inventory.items;
export const selectInventoryStatus = (state: RootState) => state.inventory.status;
export const selectInventoryError = (state: RootState) => state.inventory.error;

export default inventorySlice.reducer;

================
File: redux/slices/LocationCard.tsx
================
import React from 'react';

interface LocationCardProps {
  name: string;
  address: string;
  imageUrl: string;
}

const LocationCard: React.FC<LocationCardProps> = ({
  name,
  address,
  imageUrl,
}) => {
  return (
    <div className="location-card">
      <img src={imageUrl} alt={name} />
      <h3>{name}</h3>
      <p>{address}</p>
    </div>
  );
};

export default LocationCard;

================
File: redux/slices/LocationSelectionPage.tsx
================
import React from 'react';

interface Location {
  id: number;
  name: string;
}

interface LocationSelectionPageProps {
  locations: Location[];
  onSelectLocation: (id: number) => void;
}

const LocationSelectionPage: React.FC<LocationSelectionPageProps> = ({
  locations,
  onSelectLocation,
}) => {
  const handleKeyPress = (
    event: React.KeyboardEvent<HTMLDivElement>,
    id: number
  ) => {
    if (event.key === 'Enter' || event.key === ' ') {
      onSelectLocation(id);
    }
  };

  return (
    <div className="location-selection-page">
      <h2>Select a Location</h2>
      <ul>
        {locations.map((location) => (
          <div
            key={location.id}
            tabIndex={0}
            role="button"
            onClick={() => onSelectLocation(location.id)}
            onKeyPress={(e) => handleKeyPress(e, location.id)}
          >
            {location.name}
          </div>
        ))}
      </ul>
    </div>
  );
};

export default LocationSelectionPage;

================
File: redux/slices/locationSlice.ts
================
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { RootState } from '../store';
import { Location } from '../../types/locationTypes';
import { fetchLocations } from 'frontend/src/api/locationApi';

interface LocationState {
  locations: Location[];
  loading: boolean;
  error: string | null;
}

const initialState: LocationState = {
  locations: [],
  loading: false,
  error: null,
};

export const fetchLocations = createAsyncThunk<Location[], void, { rejectValue: string }>(
  'location/fetchLocations',
  async (_, { rejectWithValue }) => {
    try {
      const response = await api.get('/locations');
      return response.data;
    } catch (error) {
      return rejectWithValue('Failed to fetch locations');
    }
  }
);

const locationSlice = createSlice({
  name: 'location',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchLocations.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchLocations.fulfilled, (state, action) => {
        state.locations = action.payload;
        state.loading = false;
      })
      .addCase(fetchLocations.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || 'An error occurred';
      });
  },
});

// Updated selector functions
export const selectLocations = (state: RootState) => state.location.locations;
export const selectLocationLoading = (state: RootState) => state.location.loading;
export const selectLocationError = (state: RootState) => state.location.error;

export default locationSlice.reducer;

================
File: redux/slices/loyaltySlice.ts
================
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { RootState } from '../store';
import { LoyaltyReward, LoyaltyConfig } from '../../types';
import { fetchLoyaltyProgram } from 'frontend/src/api/loyaltyApi';

interface LoyaltyState {
  rewards: LoyaltyReward[];
  config: LoyaltyConfig | null;
  status: 'idle' | 'loading' | 'succeeded' | 'failed';
  error: string | null;
}

const initialState: LoyaltyState = {
  rewards: [],
  config: null,
  status: 'idle',
  error: null,
};

export const fetchLoyaltyRewards = createAsyncThunk(
  'loyalty/fetchRewards',
  async () => {
    const response = await loyaltyService.getLoyaltyRewards();
    return response;
  }
);

export const createLoyaltyReward = createAsyncThunk(
  'loyalty/createReward',
  async (reward: Partial<LoyaltyReward>) => {
    const response = await loyaltyService.createLoyaltyReward(reward);
    return response;
  }
);

export const updateLoyaltyReward = createAsyncThunk(
  'loyalty/updateReward',
  async (reward: LoyaltyReward) => {
    const response = await loyaltyService.updateLoyaltyReward(reward);
    return response;
  }
);

export const deleteLoyaltyReward = createAsyncThunk(
  'loyalty/deleteReward',
  async (rewardId: number) => {
    await loyaltyService.deleteLoyaltyReward(rewardId);
    return rewardId;
  }
);

export const fetchLoyaltyConfig = createAsyncThunk(
  'loyalty/fetchConfig',
  async () => {
    const response = await loyaltyService.getLoyaltyConfig();
    return response;
  }
);

export const updateLoyaltyConfig = createAsyncThunk(
  'loyalty/updateConfig',
  async (config: LoyaltyConfig) => {
    const response = await loyaltyService.updateLoyaltyConfig(config);
    return response;
  }
);

const loyaltySlice = createSlice({
  name: 'loyalty',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchLoyaltyRewards.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchLoyaltyRewards.fulfilled, (state, action: PayloadAction<LoyaltyReward[]>) => {
        state.status = 'succeeded';
        state.rewards = action.payload;
      })
      .addCase(fetchLoyaltyRewards.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.error.message || 'Failed to fetch loyalty rewards';
      })
      .addCase(createLoyaltyReward.fulfilled, (state, action: PayloadAction<LoyaltyReward>) => {
        state.rewards.push(action.payload);
      })
      .addCase(updateLoyaltyReward.fulfilled, (state, action: PayloadAction<LoyaltyReward>) => {
        const index = state.rewards.findIndex((reward) => reward.id === action.payload.id);
        if (index !== -1) {
          state.rewards[index] = action.payload;
        }
      })
      .addCase(deleteLoyaltyReward.fulfilled, (state, action: PayloadAction<number>) => {
        state.rewards = state.rewards.filter((reward) => reward.id !== action.payload);
      })
      .addCase(fetchLoyaltyConfig.fulfilled, (state, action: PayloadAction<LoyaltyConfig>) => {
        state.config = action.payload;
      })
      .addCase(updateLoyaltyConfig.fulfilled, (state, action: PayloadAction<LoyaltyConfig>) => {
        state.config = action.payload;
      });
  },
});

export const selectLoyaltyRewards = (state: RootState) => state.loyalty.rewards;
export const selectLoyaltyConfig = (state: RootState) => state.loyalty.config;
export const selectLoyaltyStatus = (state: RootState) => state.loyalty.status;
export const selectLoyaltyError = (state: RootState) => state.loyalty.error;

export default loyaltySlice.reducer;

================
File: redux/slices/menuItemsSlice.ts
================
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState } from '../rootReducer';
import { Menu, MenuItem, MenuGroup } from '../../types/menuTypes';

interface MenuItemsState {
  items: MenuItem[];
}

const initialState: MenuItemsState = {
  items: [],
};

const menuItemsSlice = createSlice({
  name: 'menuItems',
  initialState,
  reducers: {
    setMenuItems: (state, action: PayloadAction<Menu>) => {
      const menu = action.payload;
      const allItems = menu.menuGroups.flatMap((group: MenuGroup) => group.items);
      state.items = allItems;
    },
  },
});

export const { setMenuItems } = menuItemsSlice.actions;

export const selectMenuItems = (state: RootState) => state.menuItems.items;

export default menuItemsSlice.reducer;

================
File: redux/slices/menuSlice.ts
================
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { RootState } from '../rootReducer';
import { Menu, MenuStatistics } from '../../types/menuTypes';
import { fetchMenu } from 'frontend/src/api/menuApi';

interface MenuState {
  menu: Menu | null;
  statistics: MenuStatistics | null;
  status: 'idle' | 'loading' | 'succeeded' | 'failed';
  error: string | null;
}

const initialState: MenuState = {
  menu: null,
  statistics: null,
  status: 'idle',
  error: null,
};

export const fetchMenu = createAsyncThunk<
  Menu,
  string,
  { rejectValue: string }
>(
  'menu/fetchMenu',
  async (locationId, { rejectWithValue }) => {
    try {
      const menu = await menuService.getMenu(locationId);
      return menu;
    } catch (error) {
      return rejectWithValue('Failed to fetch menu');
    }
  }
);

export const updateMenu = createAsyncThunk<
  Menu,
  { locationId: string; menuId: string; menuData: Partial<Menu> },
  { rejectValue: string }
>(
  'menu/updateMenu',
  async ({ locationId, menuId, menuData }, { rejectWithValue }) => {
    try {
      const updatedMenu = await menuService.updateMenu(locationId, menuId, menuData);
      return updatedMenu;
    } catch (error) {
      return rejectWithValue('Failed to update menu');
    }
  }
);

const menuSlice = createSlice({
  name: 'menu',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchMenu.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchMenu.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.menu = action.payload;
      })
      .addCase(fetchMenu.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.payload as string;
      })
      .addCase(updateMenu.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(updateMenu.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.menu = action.payload;
      })
      .addCase(updateMenu.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.payload as string;
      });
  },
});

export const selectMenu = (state: RootState) => state.menu.menu;
export const selectMenuStatus = (state: RootState) => state.menu.status;
export const selectMenuError = (state: RootState) => state.menu.error;

export default menuSlice.reducer;

================
File: redux/slices/orderSlice.ts
================
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState } from '../store';
import { fetchOrders } from 'frontend/src/api/orderApi';

interface Order {
  id: string;
  clientId: string;
  customerId: string;
  items: OrderItem[];
  total: number;
  status: OrderStatus;
  createdAt: Date;
  updatedAt: Date;
}

interface OrderItem {
  id: string;
  menuItemId: string;
  quantity: number;
  price: number;
  modifiers?: Modifier[];
}

interface Modifier {
  id: string;
  name: string;
  price: number;
}

enum OrderStatus {
  PENDING = 'PENDING',
  PROCESSING = 'PROCESSING',
  COMPLETED = 'COMPLETED',
  CANCELLED = 'CANCELLED'
}

interface OrderState {
  activeOrders: Order[];
}

const initialState: OrderState = {
  activeOrders: [],
};

const orderSlice = createSlice({
  name: 'order',
  initialState,
  reducers: {
    setActiveOrders: (state, action: PayloadAction<Order[]>) => {
      state.activeOrders = action.payload;
    },
    removeOrder: (state, action: PayloadAction<string>) => {
      state.activeOrders = state.activeOrders.filter(
        (order) => order.id !== action.payload
      );
    },
    updateOrder: (state, action: PayloadAction<Order>) => {
      state.activeOrders = state.activeOrders.map((order) => 
        order.id === action.payload.id ? action.payload : order
      );
    },
  },
});

export const { setActiveOrders, removeOrder, updateOrder } = orderSlice.actions;

export const selectActiveOrders = (state: RootState) => state.order.activeOrders;

export default orderSlice.reducer;

================
File: redux/slices/posIntegrationSlice.ts
================
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { fetchPOSIntegrations as fetchPOSIntegrationsAPI } from '../../api/posIntegrationApi';

export const fetchPOSIntegrations = createAsyncThunk(
  'posIntegration/fetchPOSIntegrations',
  async () => {
    const response = await fetchPOSIntegrationsAPI();
    return response.data;
  }
);

const posIntegrationSlice = createSlice({
  name: 'posIntegration',
  initialState: {
    integrations: [],
    status: 'idle',
    error: null,
  },
  reducers: {},
  extraReducers: (builder) => {
    builder.addCase(fetchPOSIntegrations.fulfilled, (state, action) => {
      state.integrations = action.payload;
    });
  },
});

export default posIntegrationSlice.reducer;

================
File: redux/slices/posProfileSlice.ts
================
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { RootState } from '../store';
import { LocationPOSProfile } from '../../types/posTypes';
import { fetchPOSProfiles } from 'frontend/src/api/posProfileApi';

interface POSProfileState {
  locationProfiles: LocationPOSProfile[];
  loading: boolean;
  error: string | null;
}

const initialState: POSProfileState = {
  locationProfiles: [],
  loading: false,
  error: null,
};

export const fetchLocationPOSProfiles = createAsyncThunk<
  LocationPOSProfile[],
  string,
  { rejectValue: string }
>(
  'posProfile/fetchLocationProfiles',
  async (locationId, { rejectWithValue }) => {
    try {
      const response = await api.get(`/locations/${locationId}/pos-profiles`);
      return response.data;
    } catch (error) {
      return rejectWithValue('Failed to fetch location POS profiles');
    }
  }
);

const posProfileSlice = createSlice({
  name: 'posProfile',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchLocationPOSProfiles.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchLocationPOSProfiles.fulfilled, (state, action) => {
        state.locationProfiles = action.payload;
        state.loading = false;
      })
      .addCase(fetchLocationPOSProfiles.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || 'An error occurred';
      });
  },
});

export const selectLocationPOSProfiles = (state: RootState) => state.posProfile.locationProfiles;
export const selectPOSProfileLoading = (state: RootState) => state.posProfile.loading;
export const selectPOSProfileError = (state: RootState) => state.posProfile.error;

export default posProfileSlice.reducer;

================
File: redux/slices/posSettingsSlice.ts
================
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { RootState } from '../store';
import { posSettingService } from '../../services/posSettingService';
import { POSSettings } from '../../types/posSettingsTypes';

interface POSSettingsState {
  settings: Record<string, POSSettings>;
  loading: boolean;
  error: string | null;
}

const initialState: POSSettingsState = {
  settings: {},
  loading: false,
  error: null,
};

export const fetchPOSSettings = createAsyncThunk<
  POSSettings,
  string,
  { rejectValue: string }
>(
  'posSettings/fetchSettings',
  async (locationId, { rejectWithValue }) => {
    try {
      const settings = await posSettingService.getSettings(locationId);
      return settings;
    } catch (error) {
      if (error instanceof Error) {
        return rejectWithValue(error.message);
      }
      return rejectWithValue('An unknown error occurred');
    }
  }
);

export const updatePOSSettings = createAsyncThunk<
  POSSettings,
  { locationId: string; settings: Partial<POSSettings> },
  { rejectValue: string }
>(
  'posSettings/updateSettings',
  async ({ locationId, settings }, { rejectWithValue }) => {
    try {
      // Changed from updateSyncSettings to updateSettings
      const updatedSettings = await posSettingService.updateSettings(locationId, settings);
      return updatedSettings;
    } catch (error) {
      if (error instanceof Error) {
        return rejectWithValue(error.message);
      }
      return rejectWithValue('An unknown error occurred');
    }
  }
);

const posSettingsSlice = createSlice({
  name: 'posSettings',
  initialState,
  reducers: {
    clearError: (state) => {
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchPOSSettings.pending, (state) => {
        state.loading = true;
        state.error = null;  // Clear error when starting a new fetch
      })
      .addCase(fetchPOSSettings.fulfilled, (state, action) => {
        state.settings[action.meta.arg] = action.payload;
        state.loading = false;
      })
      .addCase(fetchPOSSettings.rejected, (state, action) => {
        state.error = action.payload || 'An unknown error occurred';
        state.loading = false;
      })
      .addCase(updatePOSSettings.pending, (state) => {
        state.loading = true;
      })
      .addCase(updatePOSSettings.fulfilled, (state, action) => {
        state.settings[action.meta.arg.locationId] = action.payload;
        state.loading = false;
      })
      .addCase(updatePOSSettings.rejected, (state, action) => {
        state.error = action.payload || 'An unknown error occurred';
        state.loading = false;
      });
  },
});

export const { clearError } = posSettingsSlice.actions;

export const selectPOSSettingsForLocation = (state: RootState, locationId: string) => 
  state.posSettings.settings[locationId];

export const selectPOSSettings = (state: RootState) => state.posSettings.settings;
export const selectPOSSettingsLoading = (state: RootState) => state.posSettings.loading;
export const selectPOSSettingsError = (state: RootState) => state.posSettings.error;

export default posSettingsSlice.reducer;

================
File: redux/slices/providerSlice.ts
================
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { RootState } from '../store';
import { Provider, PaginatedResponse } from '../../types/providerTypes';
import { fetchProviders } from 'frontend/src/api/providerApi';

interface ProviderState {
  providers: Provider[];
  loading: boolean;
  error: string | null;
  totalProviders: number;
  currentPage: number;
  totalPages: number;
  pageSize: number;
}

const initialState: ProviderState = {
  providers: [],
  loading: false,
  error: null,
  totalProviders: 0,
  currentPage: 1,
  totalPages: 1,
  pageSize: 10,
};

export const fetchProviders = createAsyncThunk<
  PaginatedResponse<Provider>,
  { page: number; limit: number },
  { rejectValue: string }
>(
  'providers/fetchProviders',
  async ({ page, limit }, { rejectWithValue }) => {
    try {
      const response = await providerService.getProviders({ page, limit });
      return response;
    } catch (error) {
      if (error instanceof Error) {
        return rejectWithValue(error.message);
      }
      return rejectWithValue('An unknown error occurred');
    }
  }
);

const providerSlice = createSlice({
  name: 'provider',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchProviders.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchProviders.fulfilled, (state, action: PayloadAction<PaginatedResponse<Provider>>) => {
        state.loading = false;
        state.providers = action.payload.data;
        state.totalProviders = action.payload.total;
        state.currentPage = action.payload.page;
        state.totalPages = action.payload.totalPages;
        state.pageSize = action.payload.limit; // Changed from pageSize to limit
      })
      .addCase(fetchProviders.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || 'An unknown error occurred';
      });
  },
});

export const selectProviders = (state: RootState) => state.provider.providers;
export const selectProvidersLoading = (state: RootState) => state.provider.loading;
export const selectProvidersError = (state: RootState) => state.provider.error;
export const selectTotalProviders = (state: RootState) => state.provider.totalProviders;
export const selectCurrentPage = (state: RootState) => state.provider.currentPage;
export const selectTotalPages = (state: RootState) => state.provider.totalPages;
export const selectPageSize = (state: RootState) => state.provider.pageSize;

export default providerSlice.reducer;

================
File: redux/slices/realtimeMetricsSlice.ts
================
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState } from '../store';

interface TopSellingItem {
  id: string;
  name: string;
  quantity: number;
  revenue: number;
}

interface RealtimeMetrics {
  todaySales: number;
  todayOrders: number;
  averageOrderValue: number;
  newGuests: number;
  activeGuests: number;
  topSellingItems: TopSellingItem[];
}

interface RealtimeMetricsState {
  metrics: RealtimeMetrics;
  loading: boolean;
  error: string | null;
}

const initialState: RealtimeMetricsState = {
  metrics: {
    todaySales: 0,
    todayOrders: 0,
    averageOrderValue: 0,
    newGuests: 0,
    activeGuests: 0,
    topSellingItems: [],
  },
  loading: false,
  error: null,
};

const realtimeMetricsSlice = createSlice({
  name: 'realtimeMetrics',
  initialState,
  reducers: {
    updateMetrics: (state, action: PayloadAction<Partial<RealtimeMetrics>>) => {
      state.metrics = { ...state.metrics, ...action.payload };
    },
    setLoading: (state, action: PayloadAction<boolean>) => {
      state.loading = action.payload;
    },
    setError: (state, action: PayloadAction<string | null>) => {
      state.error = action.payload;
    },
  },
});

export const { updateMetrics, setLoading, setError } = realtimeMetricsSlice.actions;

export const selectRealtimeMetrics = (state: RootState) => state.realtimeMetrics.metrics;
export const selectRealtimeMetricsLoading = (state: RootState) => state.realtimeMetrics.loading;
export const selectRealtimeMetricsError = (state: RootState) => state.realtimeMetrics.error;

export default realtimeMetricsSlice.reducer;

================
File: redux/slices/revenueSlice.ts
================
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { RootState } from '../store';
import { fetchRevenueData } from '../../api/revenueApi';

interface RevenueData {
  date: string;
  amount: number;
}

interface RevenueState {
  data: RevenueData[];
  loading: boolean;
  error: string | null;
}

const initialState: RevenueState = {
  data: [],
  loading: false,
  error: null,
};

export const fetchRevenue = createAsyncThunk(
  'revenue/fetchRevenue',
  async (dateRange: { startDate: string; endDate: string }, { rejectWithValue }) => {
    try {
      const data = await fetchRevenueData(dateRange);
      return data;
    } catch (error: unknown) {
      if (error instanceof Error) {
        return rejectWithValue(error.message);
      }
      return rejectWithValue('An unknown error occurred');
    }
  }
);

const revenueSlice = createSlice({
  name: 'revenue',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchRevenue.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchRevenue.fulfilled, (state, action) => {
        state.loading = false;
        state.data = action.payload;
      })
      .addCase(fetchRevenue.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      });
  },
});

export const selectRevenueData = (state: RootState) => state.revenue.data;
export const selectRevenueLoading = (state: RootState) => state.revenue.loading;
export const selectRevenueError = (state: RootState) => state.revenue.error;

export default revenueSlice.reducer;

================
File: redux/slices/reviewSlice.ts
================
import { createSlice, PayloadAction, createAsyncThunk } from '@reduxjs/toolkit';
import { RootState } from '../store';
import { Review } from '../../types/reviewTypes';
import { fetchReviews } from 'frontend/src/api/reviewApi';

interface ReviewState {
  reviews: Review[];
  loading: boolean;
  error: string | null;
}

const initialState: ReviewState = {
  reviews: [],
  loading: false,
  error: null,
};

export const fetchReviews = createAsyncThunk<
  Review[],
  string,
  { rejectValue: string }
>(
  'review/fetchReviews',
  async (itemId, { rejectWithValue }) => {
    try {
      const reviews = await reviewService.getReviews(itemId);
      return reviews;
    } catch (error) {
      if (error instanceof Error) {
        return rejectWithValue(error.message);
      }
      return rejectWithValue('An unknown error occurred');
    }
  }
);

const reviewSlice = createSlice({
  name: 'review',
  initialState,
  reducers: {
    addReview: (state, action: PayloadAction<Review>) => {
      state.reviews.push(action.payload);
    },
    updateReview: (state, action: PayloadAction<Review>) => {
      const index = state.reviews.findIndex(review => review.id === action.payload.id);
      if (index !== -1) {
        state.reviews[index] = action.payload;
      }
    },
    deleteReview: (state, action: PayloadAction<string>) => {
      state.reviews = state.reviews.filter(review => review.id !== action.payload);
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchReviews.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchReviews.fulfilled, (state, action) => {
        state.loading = false;
        state.reviews = action.payload;
      })
      .addCase(fetchReviews.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || 'An unknown error occurred';
      });
  },
});

export const { addReview, updateReview, deleteReview } = reviewSlice.actions;

export const selectReviews = (state: RootState) => state.review.reviews;
export const selectReviewsLoading = (state: RootState) => state.review.loading;
export const selectReviewsError = (state: RootState) => state.review.error;

export default reviewSlice.reducer;

================
File: redux/slices/roleSlice.ts
================
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState } from '../rootReducer';
import { fetchRoles } from 'frontend/src/api/roleApi';

interface Role {
  id: string;
  name: string;
  permissions: string[];
}

interface RoleState {
  roles: Role[];
  status: 'idle' | 'loading' | 'succeeded' | 'failed';
  error: string | null;
}

const initialState: RoleState = {
  roles: [],
  status: 'idle',
  error: null,
};

const roleSlice = createSlice({
  name: 'roles',
  initialState,
  reducers: {
    addRole: (state, action: PayloadAction<Role>) => {
      state.roles.push(action.payload);
    },
    updateRole: (
      state,
      action: PayloadAction<{ id: string; permissions: string[] }>
    ) => {
      const role = state.roles.find((r) => r.id === action.payload.id);
      if (role) {
        role.permissions = action.payload.permissions;
      }
    },
  },
});

export const selectRoles = (state: RootState) => state.role.roles;
export const selectRoleStatus = (state: RootState) => state.role.status;
export const selectRoleError = (state: RootState) => state.role.error;

export const { addRole, updateRole } = roleSlice.actions;

export default roleSlice.reducer;

================
File: redux/slices/rootReducer.ts
================
import { combineReducers } from '@reduxjs/toolkit';
import authSlice from './authSlice'; // This import is correct
import abTestReducer from './abTestSlice';
import clientBrandingReducer from './clientBrandingSlice';
import clientConfigReducer from './clientConfigSlice';
import clientReducer from './clientSlice';
import walletReducer from './walletSlice';
import roleReducer from './roleSlice';
import locationReducer from './locationSlice';
import menuReducer from './menuSlice';
import orderReducer from './orderSlice';
import loyaltyReducer from './loyaltySlice';
import posIntegrationReducer from './posIntegrationSlice';
import userReducer from './userSlice';
import discountReducer from './discountSlice';
import serviceFeeReducer from './serviceFeeSlice';
import posProfileReducer from './posProfileSlice';
import providerReducer from './providerSlice';
import reviewReducer from './reviewSlice';
import guestReducer from './guestSlice';
import dashboardReducer from './dashboardSlice';
import cateringOrderReducer from './cateringOrderSlice';
import inventoryReducer from './inventorySlice';
import realtimeMetricsReducer from './realtimeMetricsSlice';

const rootReducer = combineReducers({
  auth: authSlice, // Remove .reducer, authSlice is already a reducer
  abTest: abTestReducer,
  clientBranding: clientBrandingReducer,
  clientConfig: clientConfigReducer,
  client: clientReducer,
  wallet: walletReducer,
  role: roleReducer,
  location: locationReducer,
  menu: menuReducer,
  order: orderReducer,
  loyalty: loyaltyReducer,
  posIntegration: posIntegrationReducer,
  user: userReducer,
  discount: discountReducer,
  serviceFee: serviceFeeReducer,
  posProfile: posProfileReducer,
  provider: providerReducer,
  review: reviewReducer,
  guest: guestReducer,
  dashboard: dashboardReducer,
  cateringOrder: cateringOrderReducer,
  inventory: inventoryReducer,
  realtimeMetrics: realtimeMetricsReducer,
});

export type RootState = ReturnType<typeof rootReducer>;

export default rootReducer;

================
File: redux/slices/salesReportSlice.ts
================
import { createSlice, PayloadAction } from '@reduxjs/toolkit';

interface SalesData {
  date: string;
  totalSales: number;
  orderCount: number;
  averageOrderValue: number;
}

interface SalesReportState {
  dailySales: SalesData[];
  monthlySales: SalesData[];
  loading: boolean;
  error: string | null;
}

const initialState: SalesReportState = {
  dailySales: [],
  monthlySales: [],
  loading: false,
  error: null,
};

const salesReportSlice = createSlice({
  name: 'salesReport',
  initialState,
  reducers: {
    fetchSalesReportStart(state) {
      state.loading = true;
      state.error = null;
    },
    fetchDailySalesSuccess(state, action: PayloadAction<SalesData[]>) {
      state.dailySales = action.payload;
      state.loading = false;
    },
    fetchMonthlySalesSuccess(state, action: PayloadAction<SalesData[]>) {
      state.monthlySales = action.payload;
      state.loading = false;
    },
    fetchSalesReportFailure(state, action: PayloadAction<string>) {
      state.loading = false;
      state.error = action.payload;
    },
  },
});

export const {
  fetchSalesReportStart,
  fetchDailySalesSuccess,
  fetchMonthlySalesSuccess,
  fetchSalesReportFailure,
} = salesReportSlice.actions;

export default salesReportSlice.reducer;

================
File: redux/slices/serviceFeeSlice.ts
================
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { RootState } from '../store';
import { ServiceFee } from '../../types/serviceFeeTypes';
import { fetchServiceFees } from 'frontend/src/api/serviceFeeApi';

interface ServiceFeeState {
  serviceFees: ServiceFee[];
  loading: boolean;
  error: string | null;
}

const initialState: ServiceFeeState = {
  serviceFees: [],
  loading: false,
  error: null,
};

export const fetchServiceFees = createAsyncThunk(
  'serviceFees/fetchServiceFees',
  async (clientId: string) => {
    const response = await fetchServiceFees(clientId);
    return response;
  }
);

export const createServiceFee = createAsyncThunk(
  'serviceFees/createServiceFee',
  async ({ clientId, serviceFee }: { clientId: string; serviceFee: Omit<ServiceFee, 'id'> }) => {
    const response = await createServiceFee(clientId, serviceFee);
    return response;
  }
);

const serviceFeeSlice = createSlice({
  name: 'serviceFee',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchServiceFees.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchServiceFees.fulfilled, (state, action) => {
        state.loading = false;
        state.serviceFees = action.payload;
      })
      .addCase(fetchServiceFees.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message || 'Failed to fetch service fees';
      })
      .addCase(createServiceFee.fulfilled, (state, action) => {
        state.serviceFees.push(action.payload);
      });
  },
});

export default serviceFeeSlice.reducer;

================
File: redux/slices/sessionSlice.ts
================
import { createSlice } from '@reduxjs/toolkit';
import { v4 as uuidv4 } from 'uuid';

const initialState = {
  id: localStorage.getItem('sessionId') || uuidv4(),
};

const sessionSlice = createSlice({
  name: 'session',
  initialState,
  reducers: {},
});

export default sessionSlice.reducer;

================
File: redux/slices/settingsSlice.ts
================
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import * as settingsApi from '../../api/settingsApi';
import { Settings } from '../../types/settingsTypes';

export const fetchSettings = createAsyncThunk(
  'settings/fetchSettings',
  async (clientId: number) => {
    return await settingsApi.fetchSettings(clientId);
  }
);

export const updateSettings = createAsyncThunk(
  'settings/updateSettings',
  async ({
    clientId,
    settings,
  }: {
    clientId: number;
    settings: Partial<Settings>;
  }) => {
    return await settingsApi.updateSettings(clientId, settings);
  }
);

interface SettingsState {
  data: Settings | null;
  status: 'idle' | 'loading' | 'succeeded' | 'failed';
  error: string | null;
}

const initialState: SettingsState = {
  data: null,
  status: 'idle',
  error: null,
};

const settingsSlice = createSlice({
  name: 'settings',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchSettings.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchSettings.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.data = action.payload;
      })
      .addCase(fetchSettings.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.error.message || 'Failed to fetch settings';
      })
      .addCase(updateSettings.fulfilled, (state, action) => {
        state.data = action.payload;
      });
  },
});

export default settingsSlice.reducer;

================
File: redux/slices/tailwind.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Custom styles */
body {
  @apply font-sans text-gray-900;
}

button {
  @apply bg-blue-500 text-white py-2 px-4 rounded hover:bg-blue-600;
}

input,
select,
textarea {
  @apply border border-gray-300 rounded p-2 w-full;
}

table {
  @apply min-w-full bg-white border border-gray-200;
}

thead {
  @apply bg-gray-100;
}

tbody tr:hover {
  @apply bg-gray-50;
}

================
File: redux/slices/types.ts
================
export interface AuthState {
  user: User | null;
  isAuthenticated: boolean;
  loading: boolean;
  error: string | null;
}

export interface MenuState {
  menus: Menu[];
  loading: boolean;
  error: string | null;
}

export interface ClientState {
  clients: Client[];
  loading: boolean;
  error: string | null;
}

export interface LocationState {
  locations: Location[];
  loading: boolean;
  error: string | null;
}

export interface OrderState {
  orders: Order[];
  loading: boolean;
  error: string | null;
}

export interface RoleState {
  roles: Role[];
  loading: boolean;
  error: string | null;
}

export interface User {
  id: number;
  username: string;
  email: string;
  role: string;
}

export interface Menu {
  id: number;
  name: string;
  groups: MenuGroup[];
}

export interface MenuGroup {
  id: number;
  name: string;
  items: MenuItem[];
}

export interface MenuItem {
  id: number;
  name: string;
  price: number;
  description: string;
}

export interface Client {
  id: number;
  name: string;
  subdomain: string;
  active: boolean;
}

export interface Location {
  id: number;
  name: string;
  address: string;
  posSystem: string;
  locationHours: string;
  posApiKey: string;
  posGuid: string;
  providerId?: number;
  serviceFee?: number;
}

export interface Order {
  id: number;
  clientId: number;
  items: OrderItem[];
  total: number;
  status: string;
}

export interface OrderItem {
  id: number;
  menuItemId: number;
  quantity: number;
  price: number;
}

export interface Role {
  id: number;
  name: string;
  permissions: string[];
}

export interface ServiceFee {
  id: number;
  name: string;
  amount: number;
}

export interface Provider {
  id: number;
  name: string;
  serviceFee: number;
}

export interface Discount {
  id: number;
  name: string;
  type: string;
  value: string;
  locationId: number | null;
  conditions: Record<string, unknown>;
  startDate: string;
  endDate: string;
}

================
File: redux/slices/userSlice.ts
================
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { RootState } from '../store';
import { fetchUsers } from 'frontend/src/api/userApi';

export interface User {
  id: string;
  username: string;
  email: string;
  firstName: string;
  lastName: string;
  role: 'global_admin' | 'client_admin' | 'restaurant_manager' | 'staff';
  clientId?: string;
  restaurantName?: string;
  cuisineType?: string;
  phoneNumber?: string;
  address?: string;
  timeZone?: string;
}

interface UserState {
  currentUser: User | null;
  selectedLocation: string | null;
  loading: boolean;
  error: string | null;
}

const initialState: UserState = {
  currentUser: null,
  selectedLocation: null,
  loading: false,
  error: null,
};

export const updateUserProfile = createAsyncThunk(
  'user/updateProfile',
  async (userData: Partial<User>, { rejectWithValue }) => {
    try {
      const response = await api.put('/user/profile', userData);
      return response.data;
    } catch (error) {
      return rejectWithValue('Failed to update profile');
    }
  }
);

const userSlice = createSlice({
  name: 'user',
  initialState,
  reducers: {
    setCurrentUser: (state, action: PayloadAction<User | null>) => {
      state.currentUser = action.payload;
    },
    setSelectedLocation: (state, action: PayloadAction<string | null>) => {
      state.selectedLocation = action.payload;
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(updateUserProfile.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(updateUserProfile.fulfilled, (state, action) => {
        state.loading = false;
        state.currentUser = action.payload;
      })
      .addCase(updateUserProfile.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      });
  },
});

export const { setCurrentUser, setSelectedLocation } = userSlice.actions;

export const selectCurrentUser = (state: RootState) => state.user.currentUser;
export const selectSelectedLocation = (state: RootState) => state.user.selectedLocation;

export default userSlice.reducer;

================
File: redux/slices/walletSlice.ts
================
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { RootState } from '../rootReducer';
import { Wallet, WalletTransaction } from '../../types/walletTypes';
import { fetchWallets } from 'frontend/src/api/walletApi';

interface Reward {
  id: string;
  name: string;
  // Add other relevant properties
}

interface Discount {
  id: string;
  name: string;
  // Add other relevant properties
}

interface WalletState {
  balance: number;
  rewards: Reward[];
  discounts: Discount[];
  loading: boolean;
  error: string | null;
}

const initialState: WalletState = {
  balance: 0,
  rewards: [],
  discounts: [],
  loading: false,
  error: null,
};

export const fetchWalletBalance = createAsyncThunk(
  'wallet/fetchBalance',
  async (_, { rejectWithValue }) => {
    try {
      const balance = await walletService.getBalance();
      return balance;
    } catch (error) {
      return rejectWithValue((error as Error).message);
    }
  }
);

export const addFunds = createAsyncThunk(
  'wallet/addFunds',
  async (amount: number, { rejectWithValue }) => {
    try {
      const updatedBalance = await walletService.addFunds(amount);
      return updatedBalance;
    } catch (error) {
      return rejectWithValue((error as Error).message);
    }
  }
);

// Ensure this async thunk is exported
export const loadWalletData = createAsyncThunk(
  'wallet/loadData',
  async (_, { rejectWithValue }) => {
    try {
      // Replace this with your actual API call
      const response = await fetch('/api/wallet');
      const data = await response.json();
      return data;
    } catch (error) {
      return rejectWithValue('Failed to load wallet data');
    }
  }
);

const walletSlice = createSlice({
  name: 'wallet',
  initialState,
  reducers: {
    // Add any synchronous actions here
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchWalletBalance.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchWalletBalance.fulfilled, (state, action: PayloadAction<number>) => {
        state.loading = false;
        state.balance = action.payload;
      })
      .addCase(fetchWalletBalance.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })
      .addCase(addFunds.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(addFunds.fulfilled, (state, action: PayloadAction<number>) => {
        state.loading = false;
        state.balance = action.payload;
      })
      .addCase(addFunds.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      });
  },
});

// Export the reducer
export default walletSlice.reducer;

// Export selectors
export const selectWalletBalance = (state: RootState) => state.wallet.balance;
export const selectWalletRewards = (state: RootState) => state.wallet.rewards;
export const selectWalletDiscounts = (state: RootState) => state.wallet.discounts;
export const selectWalletLoading = (state: RootState) => state.wallet.loading;
export const selectWalletError = (state: RootState) => state.wallet.error;

================
File: redux/rootReducer.ts
================
import { combineReducers } from '@reduxjs/toolkit';
import authReducer from './slices/authSlice';
import abTestReducer from './slices/abTestSlice';
import clientBrandingReducer from './slices/clientBrandingSlice';
import clientConfigReducer from './slices/clientConfigSlice';
import clientReducer from './slices/clientSlice';
import locationReducer from './slices/locationSlice';
import menuReducer from './slices/menuSlice';
import orderReducer from './slices/orderSlice';
import loyaltyReducer from './slices/loyaltySlice';
import posIntegrationReducer from './slices/posIntegrationSlice';
import userReducer from './slices/userSlice';
import walletReducer from './slices/walletSlice';
import discountReducer from './slices/discountSlice';
import serviceFeeReducer from './slices/serviceFeeSlice';
import posProfileReducer from './slices/posProfileSlice';
import providerReducer from './slices/providerSlice';
import reviewReducer from './slices/reviewSlice';
import roleReducer from './slices/roleSlice';
import guestReducer from './slices/guestSlice';
import revenueReducer from './slices/revenueSlice';
import dashboardReducer from './slices/dashboardSlice';
import cateringOrderReducer from './slices/cateringOrderSlice';
import inventoryReducer from './slices/inventorySlice';
import realtimeMetricsReducer from './slices/realtimeMetricsSlice';
import posSettingsReducer from './slices/posSettingsSlice';
import cartReducer from './slices/cartSlice'; // Add this line
import menuItemsReducer from './slices/menuItemsSlice';

const rootReducer = combineReducers({
  auth: authReducer,
  abTest: abTestReducer,
  clientBranding: clientBrandingReducer,
  clientConfig: clientConfigReducer,
  client: clientReducer,
  location: locationReducer,
  menu: menuReducer,
  order: orderReducer,
  loyalty: loyaltyReducer,
  posIntegration: posIntegrationReducer,
  user: userReducer,
  wallet: walletReducer,
  discount: discountReducer,
  serviceFee: serviceFeeReducer,
  posProfile: posProfileReducer,
  provider: providerReducer,
  review: reviewReducer,
  role: roleReducer,
  guest: guestReducer,
  revenue: revenueReducer,
  dashboard: dashboardReducer,
  cateringOrder: cateringOrderReducer,
  inventory: inventoryReducer,
  realtimeMetrics: realtimeMetricsReducer,
  posSettings: posSettingsReducer,
  cart: cartReducer, // Add this line
  menuItems: menuItemsReducer,
});

export type RootState = ReturnType<typeof rootReducer>;

export default rootReducer;

================
File: redux/store.ts
================
import { configureStore } from '@reduxjs/toolkit';
import rootReducer from './rootReducer';

export const store = configureStore({
  reducer: rootReducer,
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

================
File: services/abTestService.ts
================
import { ABTest } from '../types/abTestTypes';
import { fetchABTests, createABTest, updateABTest } from 'frontend/src/api/abTestApi';

export const ABTestService = {
  fetchABTests,
  createABTest,
  updateABTest,
};

================
File: services/analyticsService.ts
================
import { SalesByCategory } from '../types/analyticsTypes';
import { getSalesByCategory } from '../api/analyticsApi';

export class AnalyticsService {
  async getSalesByCategory(startDate?: string, endDate?: string): Promise<SalesByCategory[]> {
    return getSalesByCategory(startDate, endDate);
  }
}

================
File: services/api.ts
================
import axios, { AxiosInstance, InternalAxiosRequestConfig } from 'axios';

const api: AxiosInstance = axios.create({
  baseURL: process.env.REACT_APP_API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Add a request interceptor
api.interceptors.request.use((config: InternalAxiosRequestConfig) => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers = config.headers || {};
    config.headers['Authorization'] = `Bearer ${token}`;
  }
  return config;
}, (error) => {
  return Promise.reject(error);
});

// Add a response interceptor
api.interceptors.response.use((response) => {
  return response;
}, (error) => {
  if (error.response && error.response.status === 401) {
    // Handle unauthorized access (e.g., redirect to login)
  }
  return Promise.reject(error);
});

export default api;

================
File: services/brandingService.ts
================
import axios from 'axios';
import { BrandingProfile } from '../types';

const API_URL = '/api/branding';

export const brandingService = {
  getBrandingProfiles: async (): Promise<BrandingProfile[]> => {
    const response = await axios.get(API_URL);
    return response.data;
  },

  createBrandingProfile: async (
    profileData: Partial<BrandingProfile>
  ): Promise<BrandingProfile> => {
    const response = await axios.post(API_URL, profileData);
    return response.data;
  },

  updateBrandingProfile: async (
    profileData: BrandingProfile
  ): Promise<BrandingProfile> => {
    const response = await axios.put(
      `${API_URL}/${profileData.id}`,
      profileData
    );
    return response.data;
  },

  deleteBrandingProfile: async (id: number): Promise<void> => {
    await axios.delete(`${API_URL}/${id}`);
  },
};

================
File: services/cateringOrderService.ts
================
import { CateringOrder, OrderStatus } from '../types/cateringTypes';
import { fetchOrders, updateOrderStatus, deleteOrder } from 'frontend/src/api/cateringOrderApi';

export class CateringOrderService {
  async fetchOrders(clientId: string, status: string): Promise<CateringOrder[]> {
    return fetchOrders(clientId, status);
  }

  async updateOrderStatus(clientId: string, orderId: number, newStatus: OrderStatus): Promise<CateringOrder> {
    return updateOrderStatus(clientId, orderId, newStatus);
  }

  async deleteOrder(clientId: string, orderId: number): Promise<void> {
    return deleteOrder(clientId, orderId);
  }
}

================
File: services/cateringService.ts
================
import { CateringOrder } from '../types/cateringTypes';
import { fetchCateringOrders, updateCateringOrder, deleteCateringOrder } from 'frontend/src/api/cateringApi';

export const cateringService = {
  fetchCateringOrders,
  updateCateringOrder,
  deleteCateringOrder,
};

================
File: services/clientBrandingService.ts
================
import { ClientBranding } from '../types/clientTypes';
import { fetchClientBranding, updateClientBranding } from 'frontend/src/api/clientApi';

export const ClientBrandingService = {
  fetchClientBranding,
  updateClientBranding,
};

================
File: services/clientConfigService.ts
================
import { ClientConfig } from '../types/clientTypes';
import { getClientConfig, updateClientConfig } from 'frontend/src/api/clientApi';

export const clientConfigService = {
  getClientConfig,
  updateClientConfig,
};

================
File: services/clientService.ts
================
import { ClientConfig, ClientMetrics } from '../types/clientTypes';
import { fetchClientConfig, fetchClientMetrics } from 'frontend/src/api/clientApi';

export const ClientService = {
  fetchClientConfig,
  fetchClientMetrics,
};

================
File: services/corePOSProfileService.ts
================
import { POSProfile, POSIntegration } from '../types/posTypes';
import {
  getCorePOSProfiles,
  getCorePOSProfile,
  createCorePOSProfile,
  updateCorePOSProfile,
  deleteCorePOSProfile,
  getPOSIntegrations,
  getPOSIntegration,
  createPOSIntegration,
  updatePOSIntegration,
  deletePOSIntegration,
} from 'frontend/src/api/posProfileApi';

export const corePOSProfileService = {
  getCorePOSProfiles,
  getCorePOSProfile,
  createCorePOSProfile,
  updateCorePOSProfile,
  deleteCorePOSProfile,
  getPOSIntegrations,
  getPOSIntegration,
  createPOSIntegration,
  updatePOSIntegration,
  deletePOSIntegration,
};

================
File: services/dashboardService.ts
================
import axios from 'axios';
import { DashboardParams, DashboardData } from '../types/dashboardTypes';

export const fetchDashboardDataAPI = async (params: DashboardParams): Promise<DashboardData> => {
  const response = await axios.get<DashboardData>('/api/dashboard', { params });
  return response.data;
};

================
File: services/guestService.ts
================
import { GuestMetrics } from '../types/guestTypes';
import { fetchGuestMetrics } from 'frontend/src/api/guestApi';

export const GuestService = {
  fetchGuestMetrics,
};

================
File: services/inventoryService.ts
================
import { InventoryItem } from '../types';
import {
  getInventory,
  getInventoryItem,
  updateInventoryItem,
  createInventoryItem,
  deleteInventoryItem,
} from 'frontend/src/api/inventoryApi';

export const inventoryService = {
  getInventory,
  getInventoryItem,
  updateInventoryItem,
  createInventoryItem,
  deleteInventoryItem,
};

================
File: services/locationService.ts
================
import { Location } from '../types/locationTypes';
import { getLocations, getLocation } from 'frontend/src/api/locationApi';

export class LocationService {
  async getLocations(): Promise<Location[]> {
    return getLocations();
  }

  async getLocation(id: string): Promise<Location> {
    return getLocation(id);
  }
}

================
File: services/loyaltyService.ts
================
import { LoyaltyReward, LoyaltyConfig } from '../types';
import {
  getLoyaltyRewards,
  createLoyaltyReward,
  updateLoyaltyReward,
  deleteLoyaltyReward,
  getLoyaltyConfig,
  updateLoyaltyConfig,
} from 'frontend/src/api/loyaltyApi';

export const loyaltyService = {
  getLoyaltyRewards,
  createLoyaltyReward,
  updateLoyaltyReward,
  deleteLoyaltyReward,
  getLoyaltyConfig,
  updateLoyaltyConfig,
};

================
File: services/menuItemService.ts
================
import { MenuItem, MenuGroup } from '../types/menuTypes';
import {
  getAllMenuItems,
  getMenuItem,
  createMenuItem,
  updateMenuItem,
  deleteMenuItem,
  getAllCategories
} from 'frontend/src/api/menuApi';

export class MenuItemService {
  async getAllMenuItems(tenantId: string): Promise<MenuItem[]> {
    return getAllMenuItems(tenantId);
  }

  async getMenuItem(tenantId: string, menuItemId: number): Promise<MenuItem> {
    return getMenuItem(tenantId, menuItemId);
  }

  async createMenuItem(tenantId: string, menuItem: Omit<MenuItem, 'id'>): Promise<MenuItem> {
    return createMenuItem(tenantId, menuItem);
  }

  async updateMenuItem(tenantId: string, menuItemId: number, menuItem: MenuItem): Promise<MenuItem> {
    return updateMenuItem(tenantId, menuItemId, menuItem);
  }

  async deleteMenuItem(tenantId: string, menuItemId: number): Promise<void> {
    return deleteMenuItem(tenantId, menuItemId);
  }

  async getAllCategories(tenantId: string): Promise<MenuGroup[]> {
    return getAllCategories(tenantId);
  }
}

================
File: services/menuService.ts
================
import { Menu, MenuStatistics } from '../types/menuTypes';
import { getMenu, getMenuStatistics, updateMenu } from 'frontend/src/api/menuApi';

export const menuService = {
  getMenu: async (locationId: string): Promise<Menu> => {
    return getMenu(locationId);
  },

  getMenuStatistics: async (locationId: string): Promise<MenuStatistics> => {
    return getMenuStatistics(locationId);
  },

  updateMenu: async (locationId: string, menuId: string, menuData: Partial<Menu>): Promise<Menu> => {
    return updateMenu(locationId, menuId, menuData);
  },

  // Other methods...
};

================
File: services/posIntegrationService.ts
================
import { POSProfile } from '../types/posIntegrationTypes';
import {
  getProfiles,
  createProfile,
  updateProfile,
  deleteProfile,
  syncProfile
} from 'frontend/src/api/posIntegrationApi';

export const posIntegrationService = {
  getProfiles: async (): Promise<POSProfile[]> => {
    return getProfiles();
  },

  createProfile: async (profile: Partial<POSProfile>): Promise<POSProfile> => {
    return createProfile(profile);
  },

  updateProfile: async (profile: POSProfile): Promise<POSProfile> => {
    return updateProfile(profile);
  },

  deleteProfile: async (profileId: number): Promise<void> => {
    return deleteProfile(profileId);
  },

  syncProfile: async (profileId: number): Promise<void> => {
    return syncProfile(profileId);
  },
};

================
File: services/posProfileService.ts
================
import api from './api';
import { LocationPOSProfile } from '../types/posTypes';

export const posProfileService = {
  getLocationProfiles: async (locationId: string): Promise<LocationPOSProfile[]> => {
    const response = await api.get(`/locations/${locationId}/pos-profiles`);
    return response.data;
  },

  updateLocationProfile: async (locationId: string, profile: Partial<LocationPOSProfile>): Promise<LocationPOSProfile> => {
    const response = await api.put(`/locations/${locationId}/pos-profiles/${profile.id}`, profile);
    return response.data;
  },

  // Add other methods as needed
};

================
File: services/posSettingService.ts
================
import api from './api';
import { POSSettings } from '../types/posSettingsTypes';

export const posSettingService = {
  getSettings: async (locationId: string): Promise<POSSettings> => {
    const response = await api.get(`/locations/${locationId}/pos-settings`);
    return response.data;
  },

  updateSettings: async (locationId: string, settings: Partial<POSSettings>): Promise<POSSettings> => {
    const response = await api.put(`/locations/${locationId}/pos-settings`, settings);
    return response.data;
  },
};

================
File: services/providerService.ts
================
import api from './api';
import { Provider, PaginatedResponse } from '../types/providerTypes';

export const providerService = {
  getProviders: async ({ page, limit }: { page: number; limit: number }): Promise<PaginatedResponse<Provider>> => {
    const response = await api.get('/providers', { params: { page, limit } });
    return response.data;
  },
  // Add other provider-related methods as needed
};

================
File: services/reviewService.ts
================
import api from './api';
import { Review } from '../types/reviewTypes';

export const reviewService = {
  getReviews: async (itemId: string): Promise<Review[]> => {
    const response = await api.get(`/reviews/${itemId}`);
    return response.data;
  },
  // Add other review-related methods as needed
};

================
File: services/userService.ts
================
import apiClient from '../api/apiClient';
import { User } from '../types/userTypes';

export class userService {
  async getUsers(): Promise<User[]> {
    const response = await apiClient.get('/users');
    return response.data;
  }

  async createUser(user: User): Promise<User> {
    const response = await apiClient.post('/users', user);
    return response.data;
  }

  async updateUser(id: string, user: User): Promise<User> {
    const response = await apiClient.put(`/users/${id}`, user);
    return response.data;
  }

  async deleteUser(id: string): Promise<void> {
    await apiClient.delete(`/users/${id}`);
  }
}

================
File: services/walletService.ts
================
import apiClient from '../api/apiClient';

class WalletService {
  async getBalance(): Promise<number> {
    const response = await apiClient.get('/wallet/balance');
    return response.data.balance;
  }

  async addFunds(amount: number): Promise<number> {
    const response = await apiClient.post('/wallet/add-funds', { amount });
    return response.data.balance;
  }

  // Add other wallet-related methods here
}

export const walletService = new WalletService();

================
File: store/clientSlice.ts
================
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

export interface Client {
  id: number;
  name: string;
  subdomain: string;
  active: boolean;
}

interface ClientState {
  list: Client[];
  status: 'idle' | 'loading' | 'succeeded' | 'failed';
  error: string | null;
}

const initialState: ClientState = {
  list: [],
  status: 'idle',
  error: null,
};

// Async thunk for fetching clients
export const fetchClients = createAsyncThunk(
  'clients/fetchClients',
  async () => {
    const response = await fetch('/api/clients');
    if (!response.ok) throw new Error('Failed to fetch clients');
    return await response.json();
  }
);

// Async thunk for updating a client’s status
export const updateClientStatus = createAsyncThunk(
  'clients/updateClientStatus',
  async ({ clientId, status }: { clientId: number; status: boolean }) => {
    const response = await fetch(`/api/clients/${clientId}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ active: status }),
    });
    if (!response.ok) throw new Error('Failed to update client status');
    return await response.json();
  }
);

const clientSlice = createSlice({
  name: 'clients',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchClients.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchClients.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.list = action.payload;
      })
      .addCase(fetchClients.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.error.message || null;
      })
      .addCase(updateClientStatus.fulfilled, (state, action) => {
        const index = state.list.findIndex(
          (client) => client.id === action.payload.id
        );
        if (index !== -1) {
          state.list[index] = action.payload;
        }
      });
  },
});

export default clientSlice.reducer;

================
File: store/discountSlice.ts
================
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import axios from '../api/axios';

interface Discount {
  id: number;
  name: string;
  value: number;
  type: string;
}

interface DiscountState {
  list: Discount[];
  status: 'idle' | 'loading' | 'succeeded' | 'failed';
  error: string | null;
}

const initialState: DiscountState = {
  list: [],
  status: 'idle',
  error: null,
};

export const fetchDiscounts = createAsyncThunk(
  'discounts/fetchDiscounts',
  async () => {
    const response = await axios.get<Discount[]>('/api/discounts');
    return response.data;
  }
);

export const createDiscount = createAsyncThunk(
  'discounts/createDiscount',
  async (discount: Omit<Discount, 'id'>) => {
    const response = await axios.post<Discount>('/api/discounts', discount);
    return response.data;
  }
);

export const updateDiscount = createAsyncThunk(
  'discounts/updateDiscount',
  async (discount: Discount) => {
    const response = await axios.put<Discount>(
      `/api/discounts/${discount.id}`,
      discount
    );
    return response.data;
  }
);

export const scheduleDiscountDrop = createAsyncThunk(
  'discounts/scheduleDiscountDrop',
  async (scheduleData: {
    discountId: number;
    guestIds: number[];
    scheduleTime: string;
  }) => {
    const response = await axios.post(
      '/api/discounts/schedule-drop',
      scheduleData
    );
    return response.data;
  }
);

const discountSlice = createSlice({
  name: 'discounts',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchDiscounts.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(
        fetchDiscounts.fulfilled,
        (state, action: PayloadAction<Discount[]>) => {
          state.status = 'succeeded';
          state.list = action.payload;
        }
      )
      .addCase(fetchDiscounts.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.error.message || null;
      })
      .addCase(
        createDiscount.fulfilled,
        (state, action: PayloadAction<Discount>) => {
          state.list.push(action.payload);
        }
      )
      .addCase(
        updateDiscount.fulfilled,
        (state, action: PayloadAction<Discount>) => {
          const index = state.list.findIndex(
            (discount) => discount.id === action.payload.id
          );
          if (index !== -1) {
            state.list[index] = action.payload;
          }
        }
      )
      .addCase(scheduleDiscountDrop.fulfilled, () => {
        // Optionally handle the response from scheduling the discount drop
      });
  },
});

export default discountSlice.reducer;

================
File: store/index.ts
================
import { configureStore, combineReducers } from '@reduxjs/toolkit';
import authReducer from '../redux/slices/authSlice'; // Change to default import
import menuReducer from '../redux/slices/menuSlice';
import locationReducer from '../redux/slices/locationSlice';
import discountReducer from '../redux/slices/discountSlice';
import serviceFeeReducer from '../redux/slices/serviceFeeSlice';

export const store = configureStore({
  reducer: {
    auth: authReducer, // Use authReducer directly
    menu: menuReducer,
    locations: locationReducer,
    discounts: discountReducer,
    serviceFees: serviceFeeReducer,
  },
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

================
File: store/locationSlice.ts
================
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

interface Location {
  id: number;
  name: string;
  client: { name: string };
  isTestLocation: boolean;
}

interface LocationState {
  list: Location[];
  status: 'idle' | 'loading' | 'succeeded' | 'failed';
  error: string | null;
}

const initialState: LocationState = {
  list: [],
  status: 'idle',
  error: null,
};

export const fetchLocations = createAsyncThunk(
  'locations/fetchLocations',
  async () => {
    const response = await fetch('/api/locations');
    if (!response.ok) throw new Error('Failed to fetch locations');
    return await response.json();
  }
);

export const updateLocation = createAsyncThunk(
  'locations/updateLocation',
  async ({
    locationId,
    isTestLocation,
  }: {
    locationId: number;
    isTestLocation: boolean;
  }) => {
    const response = await fetch(`/api/locations/${locationId}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ isTestLocation }),
    });
    if (!response.ok) throw new Error('Failed to update location');
    return await response.json();
  }
);

const locationSlice = createSlice({
  name: 'locations',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchLocations.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchLocations.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.list = action.payload;
      })
      .addCase(fetchLocations.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.error.message || null;
      })
      .addCase(updateLocation.fulfilled, (state, action) => {
        const index = state.list.findIndex(
          (location) => location.id === action.payload.id
        );
        if (index !== -1) {
          state.list[index] = action.payload;
        }
      });
  },
});

export default locationSlice.reducer;

================
File: store/menuSlice.ts
================
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

// Interfaces for the hierarchical structure
interface Modifier {
  id: number;
  name: string;
  price: number;
}

interface MenuItem {
  id: number;
  name: string;
  price: number;
  modifiers: Modifier[];
}

interface MenuGroup {
  id: number;
  name: string;
  items: MenuItem[];
}

interface Menu {
  id: number;
  name: string;
  groups: MenuGroup[];
}

interface MenuState {
  menus: Menu[];
  status: 'idle' | 'loading' | 'succeeded' | 'failed';
  error: string | null;
}

const initialState: MenuState = {
  menus: [],
  status: 'idle',
  error: null,
};

// Async thunk for fetching menu data
export const fetchMenus = createAsyncThunk('menu/fetchMenus', async () => {
  const response = await fetch('/api/menu'); // Adjust the endpoint as needed
  if (!response.ok) throw new Error('Failed to fetch menu data');
  return await response.json();
});

const menuSlice = createSlice({
  name: 'menu',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchMenus.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchMenus.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.menus = action.payload;
      })
      .addCase(fetchMenus.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.error.message || null;
      });
  },
});

export default menuSlice.reducer;

================
File: styles/tailwind.css
================
/* Add styles for the inventory management and guest-facing features */

.menu-container {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 20px;
  padding: 20px;
}

.menu-item {
  background-color: #fff;
  border: 1px solid #ccc;
  padding: 10px;
  cursor: pointer;
  transition: background-color 0.3s;
}

.menu-item:hover {
  background-color: #f9f9f9;
}

.menu-item.unavailable {
  opacity: 0.5;
  pointer-events: none;
}

.unavailable-overlay {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-weight: bold;
  color: red;
}

.order-page {
  padding: 20px;
}

================
File: types/abTestTypes.ts
================
export interface ABTest {
    id: number;
    name: string;
    description: string;
    variantA: string;
    variantB: string;
    isActive: boolean;
    clientId: number;
    locationId: number;
    startDate: string;
    endDate: string;
    createdAt: string;
    updatedAt: string;
}

export enum ABTestStatus {
    DRAFT = 'DRAFT',
    RUNNING = 'RUNNING',
    PAUSED = 'PAUSED',
    COMPLETED = 'COMPLETED',
    ARCHIVED = 'ARCHIVED'
}

export interface ABTestVariation {
    id: string;
    name: string;
    description: string;
    isControl: boolean;
    config: Record<string, any>; // Configuration specific to this variation
}

export interface ABTestMetric {
    id: string;
    name: string;
    description: string;
    type: ABTestMetricType;
    goal: ABTestMetricGoal;
}

export enum ABTestMetricType {
    CONVERSION = 'CONVERSION',
    REVENUE = 'REVENUE',
    ENGAGEMENT = 'ENGAGEMENT',
    CUSTOM = 'CUSTOM'
}

export enum ABTestMetricGoal {
    INCREASE = 'INCREASE',
    DECREASE = 'DECREASE'
}

export interface ABTestResults {
    variationResults: ABTestVariationResult[];
    winner?: string; // ID of the winning variation
    confidenceLevel: number;
    reportUrl?: string;
}

export interface ABTestVariationResult {
    variationId: string;
    metrics: Record<string, number>; // Metric ID to value mapping
    sampleSize: number;
    conversionRate?: number;
}

export interface CreateABTestInput {
    name: string;
    description: string;
    startDate: string;
    endDate: string;
    variations: Omit<ABTestVariation, 'id'>[];
    metrics: Omit<ABTestMetric, 'id'>[];
    clientId: number;
}

export interface UpdateABTestInput {
    id: string;
    name?: string;
    description?: string;
    startDate?: string;
    endDate?: string;
    status?: ABTestStatus;
    variations?: Omit<ABTestVariation, 'id'>[];
    metrics?: Omit<ABTestMetric, 'id'>[];
}

export interface ABTestCreateData {
    name: string;
    description: string;
    variantA: string;
    variantB: string;
    isActive: boolean;
    clientId: number;
    locationId: number;
    startDate: string;
    endDate: string;
}

export interface ABTestResult {
    id: number;
    abTestId: number;
    variant: 'A' | 'B';
    conversions: number;
    impressions: number;
    createdAt: string;
    updatedAt: string;
}

================
File: types/analyticsTypes.ts
================
export interface SalesByCategory {
  name: string;
  value: number;
}

export interface TopSellingItem {
  id: string;
  name: string;
  quantity: number;
  revenue: number;
}

// Add other analytics-related types as needed

================
File: types/authTypes.ts
================
export interface User {
  id: string;
  username: string;
  email: string;
  roles: string[];
  // Add other user properties as needed
}

================
File: types/cateringOrderTypes.ts
================
import { Order, OrderItem } from './orderTypes';

export interface CateringOrder extends Omit<Order, 'id'> {
  id: number; // Override the id type to number
  eventDate: Date;
  eventType: string;
  deliveryAddress: string;
  specialInstructions?: string;
}

export interface CateringOrderItem extends OrderItem {
  cateringSpecificField?: string;
}

// Remove the duplicate CateringOrder interface
// export interface CateringOrder { ... }

export type OrderStatus = 'pending' | 'confirmed' | 'completed' | 'cancelled';

export interface OrderStatistics {
  totalOrders: number;
  totalRevenue: number;
  averageOrderValue: number;
  // ... other properties
}

// ... other types

export interface Provider {
  // Define provider properties
}

export interface PaginatedResponse<T> {
  data: T[];
  total: number;
  page: number;
  limit: number;
}

================
File: types/cateringTypes.ts
================
export interface CateringOrder {
  id: number;
  clientId: string;
  customerName: string;
  orderDate: string;
  deliveryDate: string;
  status: OrderStatus;
  total: number;
  items: CateringOrderItem[];
  // Add more fields as needed
}

export interface CateringOrderItem {
  id: number;
  name: string;
  quantity: number;
  price: number;
  // Add more fields as needed
}

export interface CateringOrderItemModifier {
  id: number;
  modifierId: number;
  name: string;
  price: number;
}

export enum OrderStatus {
  PENDING = 'pending',
  CONFIRMED = 'confirmed',
  PREPARING = 'preparing',
  READY = 'ready',
  OUT_FOR_DELIVERY = 'out_for_delivery',
  DELIVERED = 'delivered',
  CANCELLED = 'cancelled',
}

export interface OrderStatistics {
  totalOrders: number;
  pendingOrders: number;
  completedOrders: number;
  cancelledOrders: number;
  totalRevenue: number;
  // Add more statistics as needed
}

================
File: types/challengeTypes.ts
================
export interface Challenge {
  id: number;
  name: string;
  description: string;
  startDate: string;
  endDate: string;
  reward: string;
  // Add any other properties that a Challenge should have
}

================
File: types/clientTypes.ts
================
import { POSType } from './posIntegrationTypes';

export interface ClientPreferences {
  id: number;
  clientId: number;
  language: string;
  currency: string;
  timeFormat: '12h' | '24h';
  dateFormat: string;
  timezone: string;
}

export interface Client {
  id: number;
  name: string;
  subdomain: string;
  email: string;
  phoneNumber: string;
  address: string;
  city: string;
  state: string;
  zipCode: string;
  country: string;
  active: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface ClientBranding {
  id: number;
  clientId: number;
  logoUrl: string;
  primaryColor: string;
  secondaryColor: string;
  fontFamily: string;
  customCss: string;
}

export interface ClientConfig {
  id: string;
  name: string;
  settings: Record<string, any>;
  theme: string;
  features: string[]
  // Add other properties as needed
}

export interface ClientData {
  name: string;
  domain: string;
  primaryColor: string;
  secondaryColor: string;
  logo: string;
  features: {
    loyalty: boolean;
    onlineOrdering: boolean;
    tableReservations: boolean;
  };
}

export interface ClientCreateData {
  name: string;
  subdomain: string;
  email: string;
  phoneNumber: string;
  address: string;
  city: string;
  state: string;
  zipCode: string;
  country: string;
}

export interface ClientMetrics {
  totalClients: number;
  newClients: number;
  activeClients: number;
  averageOrderValue: number;
  repeatClientRate: number;
  clientRetentionRate: number;
  clientLifetimeValue: number;
  averageOrdersPerClient: number;
  topClients: {
    clientId: string;
    name: string;
    totalOrders: number;
    totalSpent: number;
  }[];
  clientSatisfactionScore: number;
  lastUpdated: string; // ISO date string
}

================
File: types/dashboardTypes.ts
================
import { Dayjs } from 'dayjs';

export interface DateRange {
  startDate: Date | null;
  endDate: Date | null;
}

export interface DashboardParams {
  dateRange: DateRange;
  clientId?: string;
  locationId?: string;
}

export interface DashboardData {
  totalOrders?: number;
  revenue?: number;
  averageOrderValue?: number;
  customerRetentionRate?: number;
  revenueOverTime?: ChartData;
  orderTrends?: ChartData;
  menuPerformance?: ChartData;
  customerInsights?: ChartData;
  locationComparison?: LocationComparisonData;
}

export interface ChartData {
  labels: string[];
  datasets: {
    label: string;
    data: number[];
    backgroundColor?: string;
    borderColor?: string;
    borderWidth?: number;
  }[];
}

export interface LocationComparisonData {
  labels: string[];
  datasets: {
    label: string;
    data: number[];
    backgroundColor: string;
  }[];
}

export interface DashboardStats {
    totalOrders: number;
    totalRevenue: number;
    averageOrderValue: number;
    topSellingItems: TopSellingItem[];
    newCustomers: number;
    returningCustomers: number;
  }
  
  export interface TopSellingItem {
    itemId: string;
    itemName: string;
    quantity: number;
    revenue: number;
  }

================
File: types/dateTypes.ts
================
export interface DateRange {
  startDate: Date | null;
  endDate: Date | null;
}

================
File: types/discountTypes.ts
================
export interface Discount {
    id: string;
    clientId: string;
    name: string;
    code: string;
    type: 'PERCENTAGE' | 'FIXED_AMOUNT';
    value: number;
    startDate: Date;
    endDate: Date;
    isActive: boolean;
    description?: string;
  }

================
File: types/guestTypes.ts
================
export interface Guest {
    id: string;
    name: string;
    email: string;
    phone?: string;
    lastVisit?: Date;
    visitCount: number;
    preferences?: string[];
  }

export interface GuestMetrics {
  totalGuests: number;
  newGuests: number;
  activeGuests: number;
  averageOrderValue: number;
  repeatGuestRate: number;
  guestRetentionRate: number;
  guestLifetimeValue: number;
  averageOrdersPerGuest: number;
  topGuests: {
    guestId: string;
    name: string;
    totalOrders: number;
    totalSpent: number;
  }[];
  guestSatisfactionScore: number;
  lastUpdated: string;
}

================
File: types/index.ts
================
import type {
  POSType as ImportedPOSType,
  CorePOSProfile,
  LocationPOSProfile,
  POSMenuItem,
  POSCategory,
  POSOrder,
  POSOrderItem,
} from './posTypes';
import type { User } from './userTypes';
import type { Order, OrderItem, OrderStatus } from './orderTypes';
import type { POSIntegration as POSIntegrationType } from './posIntegrationTypes';
import type { Provider } from './providerTypes';
import type { PaginatedResponse } from './paginationTypes';
import type { LocationProfile } from './locationTypes';
import type { Menu, MenuGroup } from './menuTypes';

export type { Provider, PaginatedResponse };

export * from './userTypes';
export * from './clientTypes';
export * from './locationTypes';
export * from './menuTypes';
export type { Order, OrderItem, OrderStatus };
export * from './cateringOrderTypes';
export * from './inventoryTypes';
export * from './posTypes';
export type { POSIntegrationType };
export * from './loyaltyTypes';
export * from './walletTypes';
export * from './guestTypes';
export * from './revenueTypes';
export * from './serviceFeeTypes';
export * from './discountTypes';

export type { POSType as POSTypeAlias } from './posTypes';

export interface RealtimeMetrics {
  todaySales: number;
  todayOrders: number;
  averageOrderValue: number;
  newGuests: number;
  activeGuests: number;
  topSellingItems: Array<{ itemId: string; itemName: string; quantity: number }>;
}

export interface Challenge {
  id: number;
  name: string;
  description: string;
  startDate: string;
  endDate: string;
  reward: string;
  clientId: string;
  locationId: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface TopSellingItem {
  id: number;
  name: string;
  quantity: number;
  revenue: number;
}

export interface ClientConfig {
  id: string;
  name: string;
  settings: Record<string, any>;
}

export interface AuthResponse {
  token: string;
  user: User;
}

export type UserRole = 'admin' | 'manager' | 'staff' | 'customer';

export type POSType = ImportedPOSType;

export interface ServiceFee {
  id: string;
  clientId: string;
  name: string;
  amount: number;
  type: 'FIXED' | 'PERCENTAGE';
}

export interface DashboardStats {
  totalOrders: number;
  totalRevenue: number;
  averageOrderValue: number;
  topSellingItems: { itemId: string; itemName: string; quantity: number }[];
}

export interface InventoryItem {
  id: string;
  name: string;
  quantity: number;
  unit: string;
  lowStockThreshold: number;
}

export interface Discount {
  id: string;
  clientId: string;
  name: string;
  code: string;
  type: 'PERCENTAGE' | 'FIXED_AMOUNT';
  value: number;
  startDate: string;
  endDate: string;
  isActive: boolean;
}

export interface Guest {
  id: string;
  name: string;
  email: string;
  phone?: string;
  lastVisit?: string;
}

export interface CateringOrder extends Order {
  eventDate: string;
  eventType: string;
  deliveryAddress: string;
  specialInstructions?: string;
}

export interface RevenueData {
  date: string;
  totalRevenue: number;
  orderCount: number;
}

export interface Settings {
  id: string;
  clientId: string;
  theme: {
    primaryColor: string;
    secondaryColor: string;
    fontFamily: string;
  };
  notifications: {
    email: boolean;
    sms: boolean;
    push: boolean;
  };
}

export type { Menu, MenuGroup, MenuItem } from './menuTypes';
export type { LocationProfile } from './locationTypes';

================
File: types/inventoryTypes.ts
================
export interface InventoryItem {
  id: number;
  name: string;
  quantity: number;
  unit: string;
  reorderPoint: number;
  tenantId: string;
}

================
File: types/locationTypes.ts
================
export interface LocationProfile {
  id: string;
  name: string;
  address: string;
  city: string;
  state: string;
  zipCode: string;
  country: string;
  gpsCoordinates: {
    latitude: number;
    longitude: number;
  };
  standardHours: {
    open: string;
    close: string;
  }[];
  temporaryHours?: {
    startDate: string;
    endDate: string;
    open: string;
    close: string;
  }[];
  image?: string;
}

export interface LocationUpdateData {
  name?: string;
  address?: string;
  phoneNumber?: string;
  // ... other updatable location fields
}

export interface Location {
  id: string;
  name: string;
  address: string;
  city: string;
  latitude: number;
  longitude: number;
  isDropoffSite: boolean;
  // Add other properties as needed
}

export interface LocationCreateData {
  name: string;
  address: string;
  city: string;
  state: string;
  zipCode: string;
  country: string;
  phoneNumber: string;
  email: string;
  timezone: string;
  isActive: boolean;
  clientId: number;
}

export interface LocationHours {
  id: number;
  locationId: number;
  dayOfWeek: number;
  openTime: string;
  closeTime: string;
  isClosed: boolean;
}

export interface LocationMenu {
  id: number;
  locationId: number;
  name: string;
  description: string;
  isActive: boolean;
  items: MenuItem[];
}

export interface MenuItem {
  id: number;
  menuId: number;
  name: string;
  description: string;
  price: number;
  isAvailable: boolean;
}

================
File: types/loyaltyTypes.ts
================
export interface LoyaltyReward {
    id: string;
    name: string;
    description: string;
    pointsRequired: number;
    reward: string;
  }
  
  export interface LoyaltyConfig {
    id: string;
    clientId: string;
    pointsPerDollar: number;
    expirationPeriod: number; // in days
  }
  
  export interface LoyaltyTransaction {
    id: string;
    userId: string;
    points: number;
    type: 'EARN' | 'REDEEM';
    description: string;
    createdAt: Date;
  }

================
File: types/menuTypes.ts
================
export interface Menu {
  id: string;
  locationId: string;
  name: string;
  menuGroups: MenuGroup[];
}

export interface MenuGroup {
  id: string;
  name: string;
  items: MenuItem[];
}

export interface MenuItem extends BaseMenuItem {
  localOverrides: LocalOverrides;
  modifierGroups: {
    id: string;
    name: string;
    modifiers: Modifier[];
  }[];
}

export interface BaseMenuItem {
  id: string;
  posId: string;
  name: string;
  description: string;
  price: number;
  // Other common fields
}

export interface Modifier extends BaseModifier {
  localOverrides: LocalOverrides;
}

export interface BaseModifier {
  id: string;
  posId: string;
  name: string;
  price: number;
  // Other common fields
}

export interface LocalOverrides {
  name?: string;
  description?: string;
  price?: number;
  onlineInventoryCount?: number;
  isAvailable?: boolean;
  loyaltyPointsPrice?: number;
  // Other fields that can be overridden
}

export interface CartItem {
  menuItem: {
    id: string;
    posId: string;
    name: string;
    price: number;
  };
  quantity: number;
  selectedModifiers: Modifier[];
}

export interface MenuStatistics {
  totalItems: number;
  averagePrice: number;
  mostPopularItem: string;
  leastPopularItem: string;
  averageOrderValue: number;
  // Add any other relevant statistics for your multi-location restaurant system
}

================
File: types/orderTypes.ts
================
export interface Order {
  id: string;
  clientId: string;
  customerId: string;
  items: OrderItem[];
  total: number;
  status: OrderStatus;
  createdAt: Date;
  updatedAt: Date;
}

export interface OrderItem {
  id: string;
  menuItemId: string;
  quantity: number;
  price: number;
  selectedModifiers: SelectedModifier[];
}

export interface SelectedModifier {
  id: string;
  name: string;
  price: number;
}

export interface Modifier {
  id: string;
  name: string;
  price: number;
}

export enum OrderStatus {
  PENDING = 'PENDING',
  PROCESSING = 'PROCESSING',
  COMPLETED = 'COMPLETED',
  CANCELLED = 'CANCELLED'
}

================
File: types/paginationTypes.ts
================
export interface PaginatedResponse<T> {
  data: T[];
  total: number;
  page: number;
  pageSize: number;
  totalPages: number;
}

================
File: types/posIntegrationTypes.ts
================
export interface POSIntegration {
  id: number;
  tenantId: string;
  posType: POSType;
  apiKey: string;
  isActive: boolean;
  lastSyncDate: string;
}

export enum POSType {
  TOAST = 'TOAST',
  SQUARE = 'SQUARE',
  CLOVER = 'CLOVER',
  REVEL = 'REVEL',
}

export interface POSProfile {
  id: number;
  tenantId: string;
  posType: POSType;
  apiKey: string;
  isActive: boolean;
  lastSyncDate: string;
  name: string;
  apiEndpoint: string;
}

================
File: types/posSettingsTypes.ts
================
export interface POSSettings {
  id: string;
  locationId: string;
  posProfileId: string; // References the template POS profile
  posSystem: string;
  apiKey: string;
  apiEndpoint: string;
  menuSyncEnabled: boolean;
  inventorySyncEnabled: boolean;
  orderSyncEnabled: boolean;
  lastSyncTimestamp: string | null;
  syncFrequency: number;
  customSettings: Record<string, string | number | boolean>;
}

================
File: types/posTypes.ts
================
export type POSType = 'Toast' | 'Square' | 'Clover' | 'Revel' | 'Other';

export interface CorePOSProfile {
  // Define your CorePOSProfile properties here
}

export interface LocationPOSProfile {
  id: string;
  locationId: string;
  corePOSProfileId: string;
  lastSyncStatus: 'SUCCESS' | 'FAILED' | 'IN_PROGRESS' | 'NOT_SYNCED';
  lastSyncError?: string;
  customSettings: Record<string, string | number | boolean>;
}

export interface POSMenuItem {
  id: string;
  name: string;
  description: string;
  price: number;
  categoryId: string;
  externalId: string;
}

export interface POSCategory {
  id: string;
  name: string;
  externalId: string;
}

export interface POSOrder {
  id: string;
  externalId: string;
  total: number;
  status: string;
  items: POSOrderItem[];
  createdAt: string;
  updatedAt: string;
}

export interface POSOrderItem {
  id: string;
  name: string;
  quantity: number;
  price: number;
  externalId: string;
}

export interface POSIntegration {
  id: string;
  name: string;
  type: string;
  // Add other properties as needed
}

export interface POSProfile {
  id: string;
  name: string;
  // Add other properties as needed
}

================
File: types/providerTypes.ts
================
export interface Provider {
  id: string;
  name: string;
  // Add other provider properties as needed
}

export interface PaginatedResponse<T> {
  data: T[];
  total: number;
  page: number;
  limit: number;
  totalPages: number; // Add this line
}

================
File: types/revenueTypes.ts
================
export interface RevenueData {
    date: string;
    totalRevenue: number;
    orderCount: number;
    averageOrderValue: number;
    topSellingItems: TopSellingItem[];
  }
  
  export interface TopSellingItem {
    itemId: string;
    itemName: string;
    quantity: number;
    revenue: number;
  }

================
File: types/reviewTypes.ts
================
export interface ReviewCreateData {
  orderId: string;
  rating: number;
  comment: string;
  // ... other fields needed for creating a review
}

export interface Review {
  id: string;
  orderId: string;
  rating: number;
  comment: string;
  createdAt: string;
  // ... other review fields
}

================
File: types/roleTypes.ts
================
export interface Role {
    id: string;
    name: string;
    permissions: string[];
  }
  
  export interface Permission {
    id: string;
    name: string;
    description: string;
  }

================
File: types/serviceFeeTypes.ts
================
export interface ServiceFee {
    id: string;
    clientId: string;
    name: string;
    amount: number;
    type: 'FIXED' | 'PERCENTAGE';
    description?: string;
  }

================
File: types/settingsTypes.ts
================
export interface Settings {
    id: string;
    clientId: string;
    theme: ThemeSettings;
    notifications: NotificationSettings;
    general: GeneralSettings;
  }
  
  export interface ThemeSettings {
    primaryColor: string;
    secondaryColor: string;
    fontFamily: string;
  }
  
  export interface NotificationSettings {
    email: boolean;
    sms: boolean;
    push: boolean;
  }
  
  export interface GeneralSettings {
    language: string;
    timezone: string;
  }

================
File: types/tenantTypes.ts
================
export interface Tenant {
  id: string;
  name: string;
  subdomain: string;
  plan: TenantPlan;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

export enum TenantPlan {
  BASIC = 'BASIC',
  PREMIUM = 'PREMIUM',
  ENTERPRISE = 'ENTERPRISE',
}

================
File: types/userTypes.ts
================
export enum UserRole {
  EMPLOYEE = 'EMPLOYEE',
  MANAGER = 'MANAGER',
  ADMIN = 'ADMIN',
  GUEST = 'GUEST',
  CLIENT_ADMIN = 'CLIENT_ADMIN',
  GLOBAL_ADMIN = 'GLOBAL_ADMIN',
  // Add other roles as needed
}

export interface User {
  id: string;
  email: string;
  role: UserRole;
  clientId: string;
}

export interface AuthResponse {
  token: string;
  user: User;
}

================
File: types/walletTypes.ts
================
export interface Wallet {
    id: string;
    balance: number;
    userId: string;
    // Add other relevant properties
}

export interface WalletTransaction {
    id: string;
    walletId: string;
    amount: number;
    type: 'CREDIT' | 'DEBIT';
    description: string;
    createdAt: Date;
    // Add other relevant properties
}

================
File: utils/abTestUtils.ts
================
import { SHA256 } from 'crypto-js';

export const generateConsistentHash = (
  userId: string | null,
  sessionId: string,
  testId: string
): number => {
  const input = `${userId || sessionId}-${testId}`;
  const hash = SHA256(input);
  return parseInt(hash.toString().slice(0, 8), 16);
};

export function getVariantForUser(
  userId: string,
  sessionId: string,
  testId: string,
  variantA: string,
  variantB: string
): string {
  // Implement your A/B test variant selection logic here
  // This is a simple example, you might want to use a more sophisticated method
  const hash = hashString(`${userId}${sessionId}${testId}`);
  return hash % 2 === 0 ? variantA : variantB;
}

function hashString(str: string): number {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32-bit integer
  }
  return Math.abs(hash);
}

================
File: utils/auth.ts
================
import React from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

export const withAuth = <P extends object>(
  WrappedComponent: React.ComponentType<P>
) => {
  const WithAuth: React.FC<P> = (props) => {
    const { user } = useAuth();
    const navigate = useNavigate();

    React.useEffect(() => {
      if (!user) {
        navigate('/login');
      }
    }, [user, navigate]);

    if (!user) {
      return null;
    }

    return React.createElement(WrappedComponent, props);
  };

  return WithAuth;
};

// Add other auth-related utility functions here

================
File: utils/errorHandler.js
================
import { toast } from 'react-toastify';

export const handleApiError = (error) => {
  const message =
    error.response?.data?.message || 'An unexpected error occurred';
  toast.error(message);
  console.error('API Error:', error);
};

================
File: utils/errorHandler.ts
================
import { toast } from 'react-toastify';
import { AxiosError } from 'axios';

export const handleApiError = (error: AxiosError | Error): void => {
  let errorMessage = 'An unexpected error occurred';

  if (error instanceof AxiosError) {
    if (error.response) {
      // The request was made and the server responded with a status code
      // that falls out of the range of 2xx
      errorMessage = error.response.data.message || 'An error occurred';
    } else if (error.request) {
      // The request was made but no response was received
      errorMessage = 'No response received from server';
    } else {
      // Something happened in setting up the request that triggered an Error
      errorMessage = error.message || 'An unexpected error occurred';
    }
  } else {
    errorMessage = error.message || 'An unexpected error occurred';
  }

  // Display error message using toast
  toast.error(errorMessage);

  // Log the error for debugging purposes
  console.error('API Error:', error);
};

================
File: utils/exportUtils.ts
================
import { Workbook } from 'exceljs';

interface ExportData {
  [key: string]: string | number | boolean | Date;
}

export const exportToCSV = (data: ExportData[], filename: string): void => {
  const csvContent =
    'data:text/csv;charset=utf-8,' +
    data.map((row) => Object.values(row).join(',')).join('\n');

  const encodedUri = encodeURI(csvContent);
  const link = document.createElement('a');
  link.setAttribute('href', encodedUri);
  link.setAttribute('download', `${filename}.csv`);
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};

export const exportToExcel = async (
  data: ExportData[],
  filename: string
): Promise<void> => {
  const workbook = new Workbook();
  const worksheet = workbook.addWorksheet('Sheet 1');

  // Add headers
  const headers = Object.keys(data[0]);
  worksheet.addRow(headers);

  // Add data
  data.forEach((item) => {
    worksheet.addRow(Object.values(item));
  });

  // Generate Excel file
  const buffer = await workbook.xlsx.writeBuffer();
  const blob = new Blob([buffer], {
    type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  });
  const url = window.URL.createObjectURL(blob);

  // Trigger download
  const link = document.createElement('a');
  link.href = url;
  link.download = `${filename}.xlsx`;
  link.click();

  // Clean up
  window.URL.revokeObjectURL(url);
};

================
File: utils/logger.ts
================
const logger = {
  error: (...args: any[]) => {
    console.error(...args);
  },
  warn: (...args: any[]) => {
    console.warn(...args);
  },
  info: (...args: any[]) => {
    console.log(...args);
  },
  debug: (...args: any[]) => {
    if (process.env.NODE_ENV !== 'production') {
      console.log(...args);
    }
  },
};

export default logger;

================
File: utils/socket.ts
================
import io from 'socket.io-client';
import { POSAlert } from '../types';

export const initializeSocket = () => {
  const socket = io('http://localhost:3001'); // Replace with your server URL

  socket.on('connect', () => {
    console.log('Connected to WebSocket server');
  });

  socket.on('disconnect', () => {
    console.log('Disconnected from WebSocket server');
  });

  socket.on('posAlert', (alert: POSAlert) => {
    console.log('Received POS Alert:', alert);
    // In a real application, you would dispatch an action to update the Redux store
  });

  return socket;
};

================
File: utils/subdomain.ts
================
export const getSubdomain = (): string | null => {
  const hostname = window.location.hostname;
  const parts = hostname.split('.');
  if (parts.length > 2 && parts[0] !== 'www') {
    return parts[0];
  }
  return null;
};

================
File: utils/themeUtils.ts
================
import { createTheme as createMuiTheme } from '@mui/material/styles';
import { ClientBranding } from '../types';

export const createTheme = (branding: ClientBranding) => {
  return createMuiTheme({
    palette: {
      primary: {
        main: branding.primaryColor,
      },
      secondary: {
        main: branding.secondaryColor,
      },
    },
    typography: {
      fontFamily: branding.fontFamily,
    },
    components: {
      MuiButton: {
        styleOverrides: {
          root: {
            borderRadius: branding.buttonStyle === 'rounded' ? '20px' : '0px',
          },
        },
      },
    },
  });
};

================
File: App.css
================
.App {
  text-align: center;
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: white;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

.App-link {
  color: #61dafb;
}

================
File: App.js
================
import React from 'react';
import { BrowserRouter as Router, Route, Routes } from 'react-router-dom';
import { AuthProvider } from './contexts/AuthContext';
import { CartProvider } from './contexts/CartContext';
import ProtectedRoute from './components/ProtectedRoute';
import Checkout from './components/guest/Checkout';
import Login from './components/Login'; // Update import path
import Home from './components/Home'; // Update import path

function App() {
  return (
    <AuthProvider>
      <CartProvider>
        <Router>
          <Routes>
            <Route path="/" element={<Home />} />
            <Route path="/login" element={<Login />} />
            <ProtectedRoute path="/checkout" component={Checkout} />
            {/* Add more routes as needed */}
          </Routes>
        </Router>
      </CartProvider>
    </AuthProvider>
  );
}

export default App;

================
File: App.tsx
================
import React from 'react';
import { AuthProvider } from './context/AuthContext';
import {
  BrowserRouter as Router,
  Route,
  Routes,
  Navigate,
} from 'react-router-dom';
import { useSelector } from 'react-redux';
import { RootState } from './redux/store';
import { ClientProvider } from './context/ClientContext';
import { useClientContext } from './context/ClientContext';
import AdminPanel from './components/AdminPanel';
import Menu from './components/Menu';
import Login from './components/Login';
import Dashboard from './pages/Dashboard';
import PrivateRoute from './components/PrivateRoute';
import HomePage from './pages/HomePage';
import BusinessAdminDashboard from './pages/BusinessAdminDashboard';
import AdminDashboard from './pages/AdminDashboard';
import CheckoutPage from './pages/CheckoutPage';
import UserManagement from './pages/UserManagement';
import OrderConfirmation from './pages/OrderConfirmation';
import { UserRole } from './types/userTypes';

const App: React.FC = () => {
  return (
    <AuthProvider>
      <Router>
        <Routes>
          <Route path="/" element={<HomePage />} />
          <Route path="/login" element={<Login />} />
          <Route path="/menu/:locationId" element={<Menu />} />

          <Route
            element={
              <PrivateRoute
                allowedRoles={[
                  UserRole.GUEST,
                  UserRole.CLIENT_ADMIN,
                  UserRole.GLOBAL_ADMIN,
                ]}
              />
            }
          >
            <Route path="/dashboard" element={<Dashboard />} />
            <Route path="/cart" element={<CheckoutPage />} />
            <Route path="/checkout" element={<CheckoutPage />} />
            <Route
              path="/order-confirmation/:orderId"
              element={<OrderConfirmation />}
            />
          </Route>

          <Route
            element={
              <PrivateRoute
                allowedRoles={[UserRole.CLIENT_ADMIN, UserRole.GLOBAL_ADMIN]}
              />
            }
          >
            <Route path="/admin" element={<AdminPanel />} />
            <Route path="/admin-dashboard" element={<AdminDashboard />} />
            <Route path="/business-admin" element={<BusinessAdminDashboard />} />
            <Route path="/user-management" element={<UserManagement />} />
          </Route>

          <Route path="*" element={<Navigate to="/login" replace />} />
        </Routes>
      </Router>
    </AuthProvider>
  );
};

const AppWithClientProvider: React.FC = () => (
  <ClientProvider>
    <App />
  </ClientProvider>
);

export default AppWithClientProvider;

================
File: ClientContext.tsx
================
import React, { createContext, useContext, useState, ReactNode } from 'react';

interface ClientContextType {
  clientId: string | null;
  setClientId: (id: string | null) => void;
}

const ClientContext = createContext<ClientContextType | undefined>(undefined);

export const ClientProvider: React.FC<{ children: ReactNode }> = ({
  children,
}) => {
  const [clientId, setClientId] = useState<string | null>(null);

  const value = React.useMemo(() => ({ clientId, setClientId }), [clientId]);

  return (
    <ClientContext.Provider value={value}>{children}</ClientContext.Provider>
  );
};

export const useClient = (): ClientContextType => {
  const context = useContext(ClientContext);
  if (context === undefined) {
    throw new Error('useClient must be used within a ClientProvider');
  }
  return context;
};

================
File: component-types.txt
================
(
()
(data
(dateRange
(discountedTotal
(error
(id
(item
(locationId
(user
0
0,
1
1,
2
2,
3,
345,
4
400,
6,
ABTest)
Challenge)
CustomerMetrics
Date
Discount[]
DropOffLocation)
DropResult)
Error)
Error,
ErrorInfo)
FC<LayoutProps>
InventoryItem[]
Item
KeyboardEvent<HTMLDivElement>)
Location
Location)
LocationUpdateData)
Location[]
LoginFormInputs)
LoyaltyChallenge
LoyaltyReward)
LoyaltyTier
Menu
MenuGroup
MenuItem
MenuItem)
MenuItem,
Modifier[]
Number(feeAmount),
Omit<CorePOSProfile,
Omit<Discount,
Omit<ServiceFee,
POSProfile)
POSType
Partial<CorePOSProfile>
Partial<LoyaltyChallenge>
Provider)
React
ReactNode
RevenueData[]
RootState)
SalesByCategory)
SelectChangeEvent<ChallengeType>)
State
SubmitHandler<LoginFormInputs>
Theme
UserRole[]
[
[Dayjs,
[]
[],
[number,
[string,
[updatedGroup]
activeMenu
any
any)
any,
boolean
boolean)
branding
challenge
clientId
data
defaultPosition
discountName,
e
editingCampaign
event
false,
feeName,
formData
formattedEndDate
formattedStartDate,
getAlertSeverity(alert
item
keyof
loc
location
name
new
newGroupName
newGroups,
newItemDescription,
newItemName,
newStatus
newTiers
null}
number
number)
number,
parseFloat(discountValue
parseFloat(e
parseFloat(minPurchaseAmount),
parseFloat(newItemPrice),
parseFloat(value),
parseInt(e
parseInt(maxUses,
string
string)
string,
true
true,
undefined
unknown
updatedItems
updatedLocation
updatedMenu
value
value,
{
{JSON
{alert
{challenge
{currentMetric[1]}
{currentProgress}
{error}
{error}<
{fee
{guestProfile
{item
{lastSyncTime
{location
{new
{posProfiles
{selectedLocation

================
File: defined-types.txt
================
AuthResponse
CateringOrder
Challenge
ClientConfig
DashboardStats
Discount
Guest
InventoryItem
Menu
MenuGroup
MenuItem
MenuItem
Modifier
POSType
RealtimeMetrics
RevenueData
ServiceFee
Settings
TopSellingItem
UserRole

================
File: env.d.ts
================
declare namespace NodeJS {
  interface ProcessEnv {
    NODE_ENV: 'development' | 'production' | 'test';
    PUBLIC_URL: string;
  }
}

================
File: index.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --color-primary: #3b82f6;
  --color-secondary: #1e40af;
  --color-accent: #f59e0b;
  --font-primary: 'Roboto', sans-serif;
  --font-secondary: 'Open Sans', sans-serif;
  --button-shape: 0.5rem;
}

body {
  font-family: var(--font-primary);
  background-color: var(--color-primary);
  color: var(--font-secondary);
}

h1, h2, h3, h4, h5, h6 {
  font-family: var(--font-primary);
  color: var(--color-secondary);
}

button {
  background-color: var(--color-accent);
  border-radius: var(--button-shape);
  font-family: var(--font-secondary);
  padding: 0.5rem 1rem;
  color: #fff;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

button:hover {
  background-color: var(--color-secondary);
}

a {
  color: var(--color-accent);
  text-decoration: none;
  font-family: var(--font-secondary);
}

a:hover {
  text-decoration: underline;
}

input, select, textarea {
  border: 1px solid var(--color-secondary);
  padding: 0.5rem;
  font-family: var(--font-primary);
  border-radius: var(--button-shape);
}

input:focus, select:focus, textarea:focus {
  outline: none;
  border-color: var(--color-accent);
}

.btn-primary {
  background-color: var(--color-primary);
  color: white;
  border-radius: var(--button-shape);
}

.btn-secondary {
  background-color: var(--color-secondary);
  color: white;
  border-radius: var(--button-shape);
}

.bg-primary { background-color: var(--color-primary); }
.bg-secondary { background-color: var(--color-secondary); }
.bg-accent { background-color: var(--color-accent); }
.text-primary { color: var(--color-primary); }
.text-secondary { color: var(--color-secondary); }
.text-accent { color: var(--color-accent); }

.brand-header {
  background-image: var(--header-background-url);
  background-color: var(--color-primary);
  color: var(--font-color);
  padding: 1rem;
}

.brand-footer {
  background-color: var(--color-secondary);
  color: var(--font-color);
  padding: 1rem;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 1rem;
}

@media (max-width: 768px) {
  body { font-size: 0.875rem; }
  h1 { font-size: 1.5rem; }
  .brand-header, .brand-footer { padding: 0.75rem; }
}

================
File: index.html
================
<!doctype html><html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><meta name="viewport" content="width=device-width"/><meta name="theme-color" content="#000"/><title>Grafana</title><base href="/"/><link rel="preload" href="public/fonts/roboto/RxZJdnzeo3R5zSexge8UUVtXRa8TVwTICgirnJhmVJw.woff2" as="font" crossorigin/><link rel="icon" type="image/png" href="public/img/fav32.png"/><link rel="apple-touch-icon" sizes="180x180" href="public/img/apple-touch-icon.png"/><link rel="mask-icon" href="public/img/grafana_mask_icon.svg" color="#F05A28"/><link rel="stylesheet" href="public/build/grafana.dark.6839ffb2aed352838f3a.css"/><script nonce="">performance.mark('frontend_boot_css_time_seconds');</script><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-TileColor" content="#2b5797"/><meta name="msapplication-config" content="public/img/browserconfig.xml"/></head><body class="theme-dark app-grafana"><style>.preloader {
        height: 100%;
        flex-direction: column;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      .preloader__enter {
        opacity: 0;
        animation-name: preloader-fade-in;
        animation-iteration-count: 1;
        animation-duration: 0.9s;
        animation-delay: 1.35s;
        animation-fill-mode: forwards;
      }

      .preloader__bounce {
        text-align: center;
        animation-name: preloader-bounce;
        animation-duration: 0.9s;
        animation-iteration-count: infinite;
      }

      .preloader__logo {
        display: inline-block;
        animation-name: preloader-squash;
        animation-duration: 0.9s;
        animation-iteration-count: infinite;
        width: 60px;
        height: 60px;
        background-repeat: no-repeat;
        background-size: contain;
        background-image: url('public/img/grafana_icon.svg');
      }

      .preloader__text {
        margin-top: 16px;
        font-weight: 500;
        font-size: 14px;
        font-family: Sans-serif;
        opacity: 0;
        animation-name: preloader-fade-in;
        animation-duration: 0.9s;
        animation-delay: 1.8s;
        animation-fill-mode: forwards;
      }

      .theme-light .preloader__text {
        color: #52545c;
      }

      .theme-dark .preloader__text {
        color: #d8d9da;
      }

      @keyframes preloader-fade-in {
        0% {
          opacity: 0;
           
          animation-timing-function: cubic-bezier(0, 0, 0.5, 1);
        }
        100% {
          opacity: 1;
        }
      }

      @keyframes preloader-bounce {
        from,
        to {
          transform: translateY(0px);
          animation-timing-function: cubic-bezier(0.3, 0, 0.1, 1);
        }
        50% {
          transform: translateY(-50px);
          animation-timing-function: cubic-bezier(0.9, 0, 0.7, 1);
        }
      }

      @keyframes preloader-squash {
        0% {
          transform: scaleX(1.3) scaleY(0.8);
          animation-timing-function: cubic-bezier(0.3, 0, 0.1, 1);
          transform-origin: bottom center;
        }
        15% {
          transform: scaleX(0.75) scaleY(1.25);
          animation-timing-function: cubic-bezier(0, 0, 0.7, 0.75);
          transform-origin: bottom center;
        }
        55% {
          transform: scaleX(1.05) scaleY(0.95);
          animation-timing-function: cubic-bezier(0.9, 0, 1, 1);
          transform-origin: top center;
        }
        95% {
          transform: scaleX(0.75) scaleY(1.25);
          animation-timing-function: cubic-bezier(0, 0, 0, 1);
          transform-origin: bottom center;
        }
        100% {
          transform: scaleX(1.3) scaleY(0.8);
          transform-origin: bottom center;
          animation-timing-function: cubic-bezier(0, 0, 0.7, 1);
        }
      }

       
      .preloader__text--fail {
        display: none;
      }

       
      .preloader--done .preloader__bounce,
      .preloader--done .preloader__logo {
        animation-name: none;
        display: none;
      }

      .preloader--done .preloader__logo,
      .preloader--done .preloader__text {
        display: none;
        color: #ff5705 !important;
        font-size: 15px;
      }

      .preloader--done .preloader__text--fail {
        display: block;
      }

      [ng\:cloak],
      [ng-cloak],
      .ng-cloak {
        display: none !important;
      }</style><div class="preloader"><div class="preloader__enter"><div class="preloader__bounce"><div class="preloader__logo"></div></div></div><div class="preloader__text">Loading Grafana</div><div class="preloader__text preloader__text--fail"><p><strong>If you're seeing this Grafana has failed to load its application files</strong><br/><br/></p><p>1. This could be caused by your reverse proxy settings.<br/><br/>2. If you host grafana under subpath make sure your grafana.ini root_url setting includes subpath. If not using a reverse proxy make sure to set serve_from_sub_path to true.<br/><br/>3. If you have a local dev build make sure you build frontend using: yarn start, yarn start:hot, or yarn build<br/><br/>4. Sometimes restarting grafana-server can help<br/><br/>5. Check if you are using a non-supported browser. For more information, refer to the list of <a href="https://grafana.com/docs/grafana/latest/installation/requirements/#supported-web-browsers">supported browsers</a>.</p></div><script nonce="">
        
        function checkBrowserCompatibility() {
          var isIE = navigator.userAgent.indexOf('MSIE') > -1;
          var isEdge = navigator.userAgent.indexOf('Edge/') > -1 || navigator.userAgent.indexOf('Edg/') > -1;
          var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
          var isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);

          

          var isEdgeVersion = /Edge\/([0-9.]+)/.exec(navigator.userAgent);

          if (isIE && parseFloat(/Trident\/([0-9.]+)/.exec(navigator.userAgent)[1]) <= 7) {
            return false;
          } else if (
            isEdge &&
            ((isEdgeVersion && parseFloat(isEdgeVersion[1]) <= 16) ||
              parseFloat(/Edg\/([0-9.]+)/.exec(navigator.userAgent)[1]) <= 16)
          ) {
            return false;
          } else if (isFirefox && parseFloat(/Firefox\/([0-9.]+)/.exec(navigator.userAgent)[1]) <= 64) {
            return false;
          } else if (isChrome && parseFloat(/Chrome\/([0-9.]+)/.exec(navigator.userAgent)[1]) <= 54) {
            return false;
          }

          return true;
        }

        if (!checkBrowserCompatibility()) {
          alert('Your browser is not fully supported, please try newer version.');
        }</script></div><div id="reactRoot"></div><script nonce="">window.grafanaBootData = {
        user: {"isSignedIn":false,"id":0,"login":"","email":"","name":"","lightTheme":false,"orgCount":0,"orgId":0,"orgName":"","orgRole":"","isGrafanaAdmin":false,"gravatarUrl":"","timezone":"browser","weekStart":"browser","locale":"en-US","helpFlags1":0,"hasEditPermissionInFolders":false},
        settings: {"alertingEnabled":false,"alertingErrorOrTimeout":"alerting","alertingMinInterval":1,"alertingNoDataOrNullValues":"no_data","allowOrgCreate":false,"appSubUrl":"","appUrl":"http://localhost:3000/","applicationInsightsConnectionString":"","applicationInsightsEndpointUrl":"","authProxyEnabled":false,"autoAssignOrg":true,"awsAllowedAuthProviders":["default","keys","credentials"],"awsAssumeRoleEnabled":true,"azure":{"cloud":"AzureCloud","managedIdentityEnabled":false},"buildInfo":{"buildstamp":1639154540,"commit":"30bb7a93ca","edition":"Open Source","env":"production","hasUpdate":true,"hideVersion":false,"isEnterprise":false,"latestVersion":"10.2.3","version":"8.3.3"},"caching":{"enabled":true},"datasources":{"-- Dashboard --":{"meta":{"id":"dashboard","type":"datasource","name":"-- Dashboard --","info":{"author":{"name":"","url":""},"description":"","links":null,"logos":{"small":"public/img/icn-datasource.svg","large":"public/img/icn-datasource.svg"},"build":{},"screenshots":null,"version":"","updated":""},"dependencies":{"grafanaDependency":"","grafanaVersion":"*","plugins":[]},"includes":null,"category":"","preload":false,"backend":false,"routes":null,"skipDataQuery":false,"autoEnabled":false,"annotations":false,"metrics":true,"alerting":false,"explore":false,"tables":false,"logs":false,"tracing":false,"builtIn":true,"streaming":false,"signature":"internal","module":"app/plugins/datasource/dashboard/module","baseUrl":"public/app/plugins/datasource/dashboard"},"name":"-- Dashboard --","type":"datasource"},"-- Grafana --":{"id":-1,"meta":{"id":"grafana","type":"datasource","name":"-- Grafana --","info":{"author":{"name":"","url":""},"description":"","links":null,"logos":{"small":"public/img/icn-datasource.svg","large":"public/img/icn-datasource.svg"},"build":{},"screenshots":null,"version":"","updated":""},"dependencies":{"grafanaDependency":"","grafanaVersion":"*","plugins":[]},"includes":null,"category":"","preload":false,"backend":false,"routes":null,"skipDataQuery":false,"autoEnabled":false,"annotations":true,"metrics":true,"alerting":false,"explore":false,"tables":false,"logs":false,"tracing":false,"builtIn":true,"streaming":false,"signature":"internal","module":"app/plugins/datasource/grafana/module","baseUrl":"public/app/plugins/datasource/grafana"},"name":"-- Grafana --","type":"datasource","uid":"grafana"},"-- Mixed --":{"meta":{"id":"mixed","type":"datasource","name":"-- Mixed --","info":{"author":{"name":"","url":""},"description":"","links":null,"logos":{"small":"public/img/icn-datasource.svg","large":"public/img/icn-datasource.svg"},"build":{},"screenshots":null,"version":"","updated":""},"dependencies":{"grafanaDependency":"","grafanaVersion":"*","plugins":[]},"includes":null,"category":"","preload":false,"backend":false,"routes":null,"skipDataQuery":false,"autoEnabled":false,"annotations":false,"metrics":true,"alerting":false,"explore":false,"tables":false,"logs":false,"tracing":false,"queryOptions":{"minInterval":true},"builtIn":true,"mixed":true,"streaming":false,"signature":"internal","module":"app/plugins/datasource/mixed/module","baseUrl":"public/app/plugins/datasource/mixed"},"name":"-- Mixed --","type":"datasource"}},"dateFormats":{"fullDate":"YYYY-MM-DD HH:mm:ss","useBrowserLocale":false,"interval":{"second":"HH:mm:ss","minute":"HH:mm","hour":"MM/DD HH:mm","day":"MM/DD","month":"YYYY-MM","year":"YYYY"},"defaultTimezone":"browser","defaultWeekStart":"browser"},"defaultDatasource":"-- Grafana --","disableLoginForm":false,"disableSanitizeHtml":false,"disableUserSignUp":true,"editorsCanAdmin":false,"exploreEnabled":true,"expressionsEnabled":true,"externalUserMngInfo":"","externalUserMngLinkName":"","externalUserMngLinkUrl":"","featureToggles":{},"googleAnalyticsId":"","http2Enabled":false,"ldapEnabled":false,"licenseInfo":{"edition":"Open Source","expiry":0,"hasLicense":false,"hasValidLicense":false,"licenseUrl":"https://grafana.com/oss/grafana?utm_source=grafana_footer","stateInfo":""},"liveEnabled":true,"loginHint":"email or username","minRefreshInterval":"5s","oauth":{},"panels":{"alertlist":{"baseUrl":"public/app/plugins/panel/alertlist","hideFromList":false,"id":"alertlist","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Shows list of alerts and their current status","links":null,"logos":{"small":"public/app/plugins/panel/alertlist/img/icn-singlestat-panel.svg","large":"public/app/plugins/panel/alertlist/img/icn-singlestat-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/alertlist/module","name":"Alert list","signature":"internal","skipDataQuery":true,"sort":15,"state":""},"annolist":{"baseUrl":"public/app/plugins/panel/annolist","hideFromList":false,"id":"annolist","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"List annotations","links":null,"logos":{"small":"public/app/plugins/panel/annolist/img/icn-annolist-panel.svg","large":"public/app/plugins/panel/annolist/img/icn-annolist-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/annolist/module","name":"Annotations list","signature":"internal","skipDataQuery":true,"sort":100,"state":""},"barchart":{"baseUrl":"public/app/plugins/panel/barchart","hideFromList":false,"id":"barchart","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Categorical charts with group support","links":null,"logos":{"small":"public/app/plugins/panel/barchart/img/barchart.svg","large":"public/app/plugins/panel/barchart/img/barchart.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/barchart/module","name":"Bar chart","signature":"internal","skipDataQuery":false,"sort":2,"state":"beta"},"bargauge":{"baseUrl":"public/app/plugins/panel/bargauge","hideFromList":false,"id":"bargauge","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Horizontal and vertical gauges","links":null,"logos":{"small":"public/app/plugins/panel/bargauge/img/icon_bar_gauge.svg","large":"public/app/plugins/panel/bargauge/img/icon_bar_gauge.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/bargauge/module","name":"Bar gauge","signature":"internal","skipDataQuery":false,"sort":5,"state":""},"candlestick":{"baseUrl":"public/app/plugins/panel/candlestick","hideFromList":false,"id":"candlestick","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"","links":null,"logos":{"small":"public/app/plugins/panel/candlestick/img/candlestick.svg","large":"public/app/plugins/panel/candlestick/img/candlestick.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/candlestick/module","name":"Candlestick","signature":"internal","skipDataQuery":false,"sort":100,"state":"beta"},"dashlist":{"baseUrl":"public/app/plugins/panel/dashlist","hideFromList":false,"id":"dashlist","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"List of dynamic links to other dashboards","links":null,"logos":{"small":"public/app/plugins/panel/dashlist/img/icn-dashlist-panel.svg","large":"public/app/plugins/panel/dashlist/img/icn-dashlist-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/dashlist/module","name":"Dashboard list","signature":"internal","skipDataQuery":true,"sort":16,"state":""},"gauge":{"baseUrl":"public/app/plugins/panel/gauge","hideFromList":false,"id":"gauge","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Standard gauge visualization","links":null,"logos":{"small":"public/app/plugins/panel/gauge/img/icon_gauge.svg","large":"public/app/plugins/panel/gauge/img/icon_gauge.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/gauge/module","name":"Gauge","signature":"internal","skipDataQuery":false,"sort":4,"state":""},"geomap":{"baseUrl":"public/app/plugins/panel/geomap","hideFromList":false,"id":"geomap","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Geomap panel","links":null,"logos":{"small":"public/app/plugins/panel/geomap/img/icn-geomap.svg","large":"public/app/plugins/panel/geomap/img/icn-geomap.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/geomap/module","name":"Geomap","signature":"internal","skipDataQuery":false,"sort":100,"state":"beta"},"gettingstarted":{"baseUrl":"public/app/plugins/panel/gettingstarted","hideFromList":true,"id":"gettingstarted","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"","links":null,"logos":{"small":"public/app/plugins/panel/gettingstarted/img/icn-dashlist-panel.svg","large":"public/app/plugins/panel/gettingstarted/img/icn-dashlist-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/gettingstarted/module","name":"Getting Started","signature":"internal","skipDataQuery":true,"sort":100,"state":""},"graph":{"baseUrl":"public/app/plugins/panel/graph","hideFromList":false,"id":"graph","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"The old default graph panel","links":null,"logos":{"small":"public/app/plugins/panel/graph/img/icn-graph-panel.svg","large":"public/app/plugins/panel/graph/img/icn-graph-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/graph/module","name":"Graph (old)","signature":"internal","skipDataQuery":false,"sort":13,"state":""},"heatmap":{"baseUrl":"public/app/plugins/panel/heatmap","hideFromList":false,"id":"heatmap","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Like a histogram over time","links":[{"name":"Brendan Gregg - Heatmaps","url":"http://www.brendangregg.com/heatmaps.html"},{"name":"Brendan Gregg - Latency Heatmaps","url":" http://www.brendangregg.com/HeatMaps/latency.html"}],"logos":{"small":"public/app/plugins/panel/heatmap/img/icn-heatmap-panel.svg","large":"public/app/plugins/panel/heatmap/img/icn-heatmap-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/heatmap/module","name":"Heatmap","signature":"internal","skipDataQuery":false,"sort":10,"state":""},"histogram":{"baseUrl":"public/app/plugins/panel/histogram","hideFromList":false,"id":"histogram","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"","links":null,"logos":{"small":"public/app/plugins/panel/histogram/img/histogram.svg","large":"public/app/plugins/panel/histogram/img/histogram.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/histogram/module","name":"Histogram","signature":"internal","skipDataQuery":false,"sort":12,"state":"beta"},"logs":{"baseUrl":"public/app/plugins/panel/logs","hideFromList":false,"id":"logs","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"","links":null,"logos":{"small":"public/app/plugins/panel/logs/img/icn-logs-panel.svg","large":"public/app/plugins/panel/logs/img/icn-logs-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/logs/module","name":"Logs","signature":"internal","skipDataQuery":false,"sort":100,"state":""},"news":{"baseUrl":"public/app/plugins/panel/news","hideFromList":false,"id":"news","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"RSS feed reader","links":null,"logos":{"small":"public/app/plugins/panel/news/img/news.svg","large":"public/app/plugins/panel/news/img/news.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/news/module","name":"News","signature":"internal","skipDataQuery":true,"sort":17,"state":"beta"},"nodeGraph":{"baseUrl":"public/app/plugins/panel/nodeGraph","hideFromList":false,"id":"nodeGraph","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"","links":null,"logos":{"small":"public/app/plugins/panel/nodeGraph/img/icn-node-graph.svg","large":"public/app/plugins/panel/nodeGraph/img/icn-node-graph.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/nodeGraph/module","name":"Node Graph","signature":"internal","skipDataQuery":false,"sort":100,"state":"beta"},"piechart":{"baseUrl":"public/app/plugins/panel/piechart","hideFromList":false,"id":"piechart","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"The new core pie chart visualization","links":null,"logos":{"small":"public/app/plugins/panel/piechart/img/icon_piechart.svg","large":"public/app/plugins/panel/piechart/img/icon_piechart.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/piechart/module","name":"Pie chart","signature":"internal","skipDataQuery":false,"sort":8,"state":""},"pluginlist":{"baseUrl":"public/app/plugins/panel/pluginlist","hideFromList":false,"id":"pluginlist","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Plugin List for Grafana","links":null,"logos":{"small":"public/app/plugins/panel/pluginlist/img/icn-dashlist-panel.svg","large":"public/app/plugins/panel/pluginlist/img/icn-dashlist-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/pluginlist/module","name":"Plugin list","signature":"internal","skipDataQuery":true,"sort":100,"state":""},"stat":{"baseUrl":"public/app/plugins/panel/stat","hideFromList":false,"id":"stat","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Big stat values \u0026 sparklines","links":null,"logos":{"small":"public/app/plugins/panel/stat/img/icn-singlestat-panel.svg","large":"public/app/plugins/panel/stat/img/icn-singlestat-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/stat/module","name":"Stat","signature":"internal","skipDataQuery":false,"sort":3,"state":""},"state-timeline":{"baseUrl":"public/app/plugins/panel/state-timeline","hideFromList":false,"id":"state-timeline","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"State changes and durations","links":null,"logos":{"small":"public/app/plugins/panel/state-timeline/img/timeline.svg","large":"public/app/plugins/panel/state-timeline/img/timeline.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/state-timeline/module","name":"State timeline","signature":"internal","skipDataQuery":false,"sort":9,"state":"beta"},"status-history":{"baseUrl":"public/app/plugins/panel/status-history","hideFromList":false,"id":"status-history","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Periodic status history","links":null,"logos":{"small":"public/app/plugins/panel/status-history/img/status.svg","large":"public/app/plugins/panel/status-history/img/status.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/status-history/module","name":"Status history","signature":"internal","skipDataQuery":false,"sort":11,"state":"beta"},"table":{"baseUrl":"public/app/plugins/panel/table","hideFromList":false,"id":"table","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Supports many column styles","links":null,"logos":{"small":"public/app/plugins/panel/table/img/icn-table-panel.svg","large":"public/app/plugins/panel/table/img/icn-table-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/table/module","name":"Table","signature":"internal","skipDataQuery":false,"sort":6,"state":""},"table-old":{"baseUrl":"public/app/plugins/panel/table-old","hideFromList":false,"id":"table-old","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Table Panel for Grafana","links":null,"logos":{"small":"public/app/plugins/panel/table-old/img/icn-table-panel.svg","large":"public/app/plugins/panel/table-old/img/icn-table-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/table-old/module","name":"Table (old)","signature":"internal","skipDataQuery":false,"sort":100,"state":"deprecated"},"text":{"baseUrl":"public/app/plugins/panel/text","hideFromList":false,"id":"text","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Supports markdown and html content","links":null,"logos":{"small":"public/app/plugins/panel/text/img/icn-text-panel.svg","large":"public/app/plugins/panel/text/img/icn-text-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/text/module","name":"Text","signature":"internal","skipDataQuery":true,"sort":14,"state":""},"timeseries":{"baseUrl":"public/app/plugins/panel/timeseries","hideFromList":false,"id":"timeseries","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Time based line, area and bar charts","links":null,"logos":{"small":"public/app/plugins/panel/timeseries/img/icn-timeseries-panel.svg","large":"public/app/plugins/panel/timeseries/img/icn-timeseries-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/timeseries/module","name":"Time series","signature":"internal","skipDataQuery":false,"sort":1,"state":""},"welcome":{"baseUrl":"public/app/plugins/panel/welcome","hideFromList":true,"id":"welcome","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"","links":null,"logos":{"small":"public/app/plugins/panel/welcome/img/icn-dashlist-panel.svg","large":"public/app/plugins/panel/welcome/img/icn-dashlist-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/welcome/module","name":"Welcome","signature":"internal","skipDataQuery":true,"sort":100,"state":""}},"passwordHint":"password","pluginAdminEnabled":true,"pluginAdminExternalManageEnabled":false,"pluginCatalogHiddenPlugins":[""],"pluginCatalogURL":"https://grafana.com/grafana/plugins/","pluginsToPreload":[],"recordedQueries":{"enabled":false},"rendererAvailable":false,"rendererVersion":"","rudderstackDataPlaneUrl":"","rudderstackWriteKey":"","samlEnabled":false,"samlName":"SAML","sentry":{"enabled":false,"dsn":"","customEndpoint":"/log","sampleRate":1},"sigV4AuthEnabled":false,"unifiedAlertingEnabled":true,"verifyEmailEnabled":false,"viewersCanEdit":false},
        navTree: [{"id":"dashboards","text":"Dashboards","section":"core","subTitle":"Manage dashboards and folders","icon":"apps","url":"/","sortWeight":-1800,"children":[{"id":"home","text":"Home","icon":"home-alt","url":"/","hideFromTabs":true},{"id":"divider","text":"Divider","divider":true,"hideFromTabs":true},{"id":"manage-dashboards","text":"Browse","icon":"sitemap","url":"/dashboards"},{"id":"playlists","text":"Playlists","icon":"presentation-play","url":"/playlists"}]},{"id":"alerting","text":"Alerting","section":"core","subTitle":"Alert rules and notifications","icon":"bell","url":"/alerting/list","sortWeight":-1600,"children":[{"id":"alert-list","text":"Alert rules","icon":"list-ul","url":"/alerting/list"},{"id":"silences","text":"Silences","icon":"bell-slash","url":"/alerting/silences"},{"id":"groups","text":"Alert groups","icon":"layer-group","url":"/alerting/groups"}]},{"id":"help","text":"Help","section":"config","subTitle":"Grafana v8.3.3 (30bb7a93ca)","icon":"question-circle","url":"#","sortWeight":-1100}],
        themePaths: {
          light: 'public/build/grafana.light.6839ffb2aed352838f3a.css',
          dark: 'public/build/grafana.dark.6839ffb2aed352838f3a.css'
        }
      };

      window.__grafana_load_failed = function() {
        var preloader = document.getElementsByClassName("preloader");
        if (preloader.length) {
          preloader[0].className = "preloader preloader--done";
        }
      }

      
      window.onload = function() {
        if (window.__grafana_app_bundle_loaded) {
          return;
        }
        window.__grafana_load_failed();
      };

      
      </script><script nonce="" src="public/build/runtime.6839ffb2aed352838f3a.js"></script><script nonce="" src="public/build/3144.6839ffb2aed352838f3a.js"></script><script nonce="" src="public/build/4210.6839ffb2aed352838f3a.js"></script><script nonce="" src="public/build/633.6839ffb2aed352838f3a.js"></script><script nonce="" src="public/build/6278.6839ffb2aed352838f3a.js"></script><script nonce="" src="public/build/7095.6839ffb2aed352838f3a.js"></script><script nonce="" src="public/build/app.6839ffb2aed352838f3a.js"></script><script nonce="">performance.mark('frontend_boot_js_done_time_seconds');</script></body></html>

================
File: index.html.1
================
<!doctype html><html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><meta name="viewport" content="width=device-width"/><meta name="theme-color" content="#000"/><title>Grafana</title><base href="/"/><link rel="preload" href="public/fonts/roboto/RxZJdnzeo3R5zSexge8UUVtXRa8TVwTICgirnJhmVJw.woff2" as="font" crossorigin/><link rel="icon" type="image/png" href="public/img/fav32.png"/><link rel="apple-touch-icon" sizes="180x180" href="public/img/apple-touch-icon.png"/><link rel="mask-icon" href="public/img/grafana_mask_icon.svg" color="#F05A28"/><link rel="stylesheet" href="public/build/grafana.dark.6839ffb2aed352838f3a.css"/><script nonce="">performance.mark('frontend_boot_css_time_seconds');</script><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-TileColor" content="#2b5797"/><meta name="msapplication-config" content="public/img/browserconfig.xml"/></head><body class="theme-dark app-grafana"><style>.preloader {
        height: 100%;
        flex-direction: column;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      .preloader__enter {
        opacity: 0;
        animation-name: preloader-fade-in;
        animation-iteration-count: 1;
        animation-duration: 0.9s;
        animation-delay: 1.35s;
        animation-fill-mode: forwards;
      }

      .preloader__bounce {
        text-align: center;
        animation-name: preloader-bounce;
        animation-duration: 0.9s;
        animation-iteration-count: infinite;
      }

      .preloader__logo {
        display: inline-block;
        animation-name: preloader-squash;
        animation-duration: 0.9s;
        animation-iteration-count: infinite;
        width: 60px;
        height: 60px;
        background-repeat: no-repeat;
        background-size: contain;
        background-image: url('public/img/grafana_icon.svg');
      }

      .preloader__text {
        margin-top: 16px;
        font-weight: 500;
        font-size: 14px;
        font-family: Sans-serif;
        opacity: 0;
        animation-name: preloader-fade-in;
        animation-duration: 0.9s;
        animation-delay: 1.8s;
        animation-fill-mode: forwards;
      }

      .theme-light .preloader__text {
        color: #52545c;
      }

      .theme-dark .preloader__text {
        color: #d8d9da;
      }

      @keyframes preloader-fade-in {
        0% {
          opacity: 0;
           
          animation-timing-function: cubic-bezier(0, 0, 0.5, 1);
        }
        100% {
          opacity: 1;
        }
      }

      @keyframes preloader-bounce {
        from,
        to {
          transform: translateY(0px);
          animation-timing-function: cubic-bezier(0.3, 0, 0.1, 1);
        }
        50% {
          transform: translateY(-50px);
          animation-timing-function: cubic-bezier(0.9, 0, 0.7, 1);
        }
      }

      @keyframes preloader-squash {
        0% {
          transform: scaleX(1.3) scaleY(0.8);
          animation-timing-function: cubic-bezier(0.3, 0, 0.1, 1);
          transform-origin: bottom center;
        }
        15% {
          transform: scaleX(0.75) scaleY(1.25);
          animation-timing-function: cubic-bezier(0, 0, 0.7, 0.75);
          transform-origin: bottom center;
        }
        55% {
          transform: scaleX(1.05) scaleY(0.95);
          animation-timing-function: cubic-bezier(0.9, 0, 1, 1);
          transform-origin: top center;
        }
        95% {
          transform: scaleX(0.75) scaleY(1.25);
          animation-timing-function: cubic-bezier(0, 0, 0, 1);
          transform-origin: bottom center;
        }
        100% {
          transform: scaleX(1.3) scaleY(0.8);
          transform-origin: bottom center;
          animation-timing-function: cubic-bezier(0, 0, 0.7, 1);
        }
      }

       
      .preloader__text--fail {
        display: none;
      }

       
      .preloader--done .preloader__bounce,
      .preloader--done .preloader__logo {
        animation-name: none;
        display: none;
      }

      .preloader--done .preloader__logo,
      .preloader--done .preloader__text {
        display: none;
        color: #ff5705 !important;
        font-size: 15px;
      }

      .preloader--done .preloader__text--fail {
        display: block;
      }

      [ng\:cloak],
      [ng-cloak],
      .ng-cloak {
        display: none !important;
      }</style><div class="preloader"><div class="preloader__enter"><div class="preloader__bounce"><div class="preloader__logo"></div></div></div><div class="preloader__text">Loading Grafana</div><div class="preloader__text preloader__text--fail"><p><strong>If you're seeing this Grafana has failed to load its application files</strong><br/><br/></p><p>1. This could be caused by your reverse proxy settings.<br/><br/>2. If you host grafana under subpath make sure your grafana.ini root_url setting includes subpath. If not using a reverse proxy make sure to set serve_from_sub_path to true.<br/><br/>3. If you have a local dev build make sure you build frontend using: yarn start, yarn start:hot, or yarn build<br/><br/>4. Sometimes restarting grafana-server can help<br/><br/>5. Check if you are using a non-supported browser. For more information, refer to the list of <a href="https://grafana.com/docs/grafana/latest/installation/requirements/#supported-web-browsers">supported browsers</a>.</p></div><script nonce="">
        
        function checkBrowserCompatibility() {
          var isIE = navigator.userAgent.indexOf('MSIE') > -1;
          var isEdge = navigator.userAgent.indexOf('Edge/') > -1 || navigator.userAgent.indexOf('Edg/') > -1;
          var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
          var isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);

          

          var isEdgeVersion = /Edge\/([0-9.]+)/.exec(navigator.userAgent);

          if (isIE && parseFloat(/Trident\/([0-9.]+)/.exec(navigator.userAgent)[1]) <= 7) {
            return false;
          } else if (
            isEdge &&
            ((isEdgeVersion && parseFloat(isEdgeVersion[1]) <= 16) ||
              parseFloat(/Edg\/([0-9.]+)/.exec(navigator.userAgent)[1]) <= 16)
          ) {
            return false;
          } else if (isFirefox && parseFloat(/Firefox\/([0-9.]+)/.exec(navigator.userAgent)[1]) <= 64) {
            return false;
          } else if (isChrome && parseFloat(/Chrome\/([0-9.]+)/.exec(navigator.userAgent)[1]) <= 54) {
            return false;
          }

          return true;
        }

        if (!checkBrowserCompatibility()) {
          alert('Your browser is not fully supported, please try newer version.');
        }</script></div><div id="reactRoot"></div><script nonce="">window.grafanaBootData = {
        user: {"isSignedIn":false,"id":0,"login":"","email":"","name":"","lightTheme":false,"orgCount":0,"orgId":0,"orgName":"","orgRole":"","isGrafanaAdmin":false,"gravatarUrl":"","timezone":"browser","weekStart":"browser","locale":"en-US","helpFlags1":0,"hasEditPermissionInFolders":false},
        settings: {"alertingEnabled":false,"alertingErrorOrTimeout":"alerting","alertingMinInterval":1,"alertingNoDataOrNullValues":"no_data","allowOrgCreate":false,"appSubUrl":"","appUrl":"http://localhost:3000/","applicationInsightsConnectionString":"","applicationInsightsEndpointUrl":"","authProxyEnabled":false,"autoAssignOrg":true,"awsAllowedAuthProviders":["default","keys","credentials"],"awsAssumeRoleEnabled":true,"azure":{"cloud":"AzureCloud","managedIdentityEnabled":false},"buildInfo":{"buildstamp":1639154540,"commit":"30bb7a93ca","edition":"Open Source","env":"production","hasUpdate":true,"hideVersion":false,"isEnterprise":false,"latestVersion":"10.2.3","version":"8.3.3"},"caching":{"enabled":true},"datasources":{"-- Dashboard --":{"meta":{"id":"dashboard","type":"datasource","name":"-- Dashboard --","info":{"author":{"name":"","url":""},"description":"","links":null,"logos":{"small":"public/img/icn-datasource.svg","large":"public/img/icn-datasource.svg"},"build":{},"screenshots":null,"version":"","updated":""},"dependencies":{"grafanaDependency":"","grafanaVersion":"*","plugins":[]},"includes":null,"category":"","preload":false,"backend":false,"routes":null,"skipDataQuery":false,"autoEnabled":false,"annotations":false,"metrics":true,"alerting":false,"explore":false,"tables":false,"logs":false,"tracing":false,"builtIn":true,"streaming":false,"signature":"internal","module":"app/plugins/datasource/dashboard/module","baseUrl":"public/app/plugins/datasource/dashboard"},"name":"-- Dashboard --","type":"datasource"},"-- Grafana --":{"id":-1,"meta":{"id":"grafana","type":"datasource","name":"-- Grafana --","info":{"author":{"name":"","url":""},"description":"","links":null,"logos":{"small":"public/img/icn-datasource.svg","large":"public/img/icn-datasource.svg"},"build":{},"screenshots":null,"version":"","updated":""},"dependencies":{"grafanaDependency":"","grafanaVersion":"*","plugins":[]},"includes":null,"category":"","preload":false,"backend":false,"routes":null,"skipDataQuery":false,"autoEnabled":false,"annotations":true,"metrics":true,"alerting":false,"explore":false,"tables":false,"logs":false,"tracing":false,"builtIn":true,"streaming":false,"signature":"internal","module":"app/plugins/datasource/grafana/module","baseUrl":"public/app/plugins/datasource/grafana"},"name":"-- Grafana --","type":"datasource","uid":"grafana"},"-- Mixed --":{"meta":{"id":"mixed","type":"datasource","name":"-- Mixed --","info":{"author":{"name":"","url":""},"description":"","links":null,"logos":{"small":"public/img/icn-datasource.svg","large":"public/img/icn-datasource.svg"},"build":{},"screenshots":null,"version":"","updated":""},"dependencies":{"grafanaDependency":"","grafanaVersion":"*","plugins":[]},"includes":null,"category":"","preload":false,"backend":false,"routes":null,"skipDataQuery":false,"autoEnabled":false,"annotations":false,"metrics":true,"alerting":false,"explore":false,"tables":false,"logs":false,"tracing":false,"queryOptions":{"minInterval":true},"builtIn":true,"mixed":true,"streaming":false,"signature":"internal","module":"app/plugins/datasource/mixed/module","baseUrl":"public/app/plugins/datasource/mixed"},"name":"-- Mixed --","type":"datasource"}},"dateFormats":{"fullDate":"YYYY-MM-DD HH:mm:ss","useBrowserLocale":false,"interval":{"second":"HH:mm:ss","minute":"HH:mm","hour":"MM/DD HH:mm","day":"MM/DD","month":"YYYY-MM","year":"YYYY"},"defaultTimezone":"browser","defaultWeekStart":"browser"},"defaultDatasource":"-- Grafana --","disableLoginForm":false,"disableSanitizeHtml":false,"disableUserSignUp":true,"editorsCanAdmin":false,"exploreEnabled":true,"expressionsEnabled":true,"externalUserMngInfo":"","externalUserMngLinkName":"","externalUserMngLinkUrl":"","featureToggles":{},"googleAnalyticsId":"","http2Enabled":false,"ldapEnabled":false,"licenseInfo":{"edition":"Open Source","expiry":0,"hasLicense":false,"hasValidLicense":false,"licenseUrl":"https://grafana.com/oss/grafana?utm_source=grafana_footer","stateInfo":""},"liveEnabled":true,"loginHint":"email or username","minRefreshInterval":"5s","oauth":{},"panels":{"alertlist":{"baseUrl":"public/app/plugins/panel/alertlist","hideFromList":false,"id":"alertlist","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Shows list of alerts and their current status","links":null,"logos":{"small":"public/app/plugins/panel/alertlist/img/icn-singlestat-panel.svg","large":"public/app/plugins/panel/alertlist/img/icn-singlestat-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/alertlist/module","name":"Alert list","signature":"internal","skipDataQuery":true,"sort":15,"state":""},"annolist":{"baseUrl":"public/app/plugins/panel/annolist","hideFromList":false,"id":"annolist","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"List annotations","links":null,"logos":{"small":"public/app/plugins/panel/annolist/img/icn-annolist-panel.svg","large":"public/app/plugins/panel/annolist/img/icn-annolist-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/annolist/module","name":"Annotations list","signature":"internal","skipDataQuery":true,"sort":100,"state":""},"barchart":{"baseUrl":"public/app/plugins/panel/barchart","hideFromList":false,"id":"barchart","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Categorical charts with group support","links":null,"logos":{"small":"public/app/plugins/panel/barchart/img/barchart.svg","large":"public/app/plugins/panel/barchart/img/barchart.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/barchart/module","name":"Bar chart","signature":"internal","skipDataQuery":false,"sort":2,"state":"beta"},"bargauge":{"baseUrl":"public/app/plugins/panel/bargauge","hideFromList":false,"id":"bargauge","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Horizontal and vertical gauges","links":null,"logos":{"small":"public/app/plugins/panel/bargauge/img/icon_bar_gauge.svg","large":"public/app/plugins/panel/bargauge/img/icon_bar_gauge.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/bargauge/module","name":"Bar gauge","signature":"internal","skipDataQuery":false,"sort":5,"state":""},"candlestick":{"baseUrl":"public/app/plugins/panel/candlestick","hideFromList":false,"id":"candlestick","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"","links":null,"logos":{"small":"public/app/plugins/panel/candlestick/img/candlestick.svg","large":"public/app/plugins/panel/candlestick/img/candlestick.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/candlestick/module","name":"Candlestick","signature":"internal","skipDataQuery":false,"sort":100,"state":"beta"},"dashlist":{"baseUrl":"public/app/plugins/panel/dashlist","hideFromList":false,"id":"dashlist","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"List of dynamic links to other dashboards","links":null,"logos":{"small":"public/app/plugins/panel/dashlist/img/icn-dashlist-panel.svg","large":"public/app/plugins/panel/dashlist/img/icn-dashlist-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/dashlist/module","name":"Dashboard list","signature":"internal","skipDataQuery":true,"sort":16,"state":""},"gauge":{"baseUrl":"public/app/plugins/panel/gauge","hideFromList":false,"id":"gauge","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Standard gauge visualization","links":null,"logos":{"small":"public/app/plugins/panel/gauge/img/icon_gauge.svg","large":"public/app/plugins/panel/gauge/img/icon_gauge.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/gauge/module","name":"Gauge","signature":"internal","skipDataQuery":false,"sort":4,"state":""},"geomap":{"baseUrl":"public/app/plugins/panel/geomap","hideFromList":false,"id":"geomap","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Geomap panel","links":null,"logos":{"small":"public/app/plugins/panel/geomap/img/icn-geomap.svg","large":"public/app/plugins/panel/geomap/img/icn-geomap.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/geomap/module","name":"Geomap","signature":"internal","skipDataQuery":false,"sort":100,"state":"beta"},"gettingstarted":{"baseUrl":"public/app/plugins/panel/gettingstarted","hideFromList":true,"id":"gettingstarted","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"","links":null,"logos":{"small":"public/app/plugins/panel/gettingstarted/img/icn-dashlist-panel.svg","large":"public/app/plugins/panel/gettingstarted/img/icn-dashlist-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/gettingstarted/module","name":"Getting Started","signature":"internal","skipDataQuery":true,"sort":100,"state":""},"graph":{"baseUrl":"public/app/plugins/panel/graph","hideFromList":false,"id":"graph","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"The old default graph panel","links":null,"logos":{"small":"public/app/plugins/panel/graph/img/icn-graph-panel.svg","large":"public/app/plugins/panel/graph/img/icn-graph-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/graph/module","name":"Graph (old)","signature":"internal","skipDataQuery":false,"sort":13,"state":""},"heatmap":{"baseUrl":"public/app/plugins/panel/heatmap","hideFromList":false,"id":"heatmap","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Like a histogram over time","links":[{"name":"Brendan Gregg - Heatmaps","url":"http://www.brendangregg.com/heatmaps.html"},{"name":"Brendan Gregg - Latency Heatmaps","url":" http://www.brendangregg.com/HeatMaps/latency.html"}],"logos":{"small":"public/app/plugins/panel/heatmap/img/icn-heatmap-panel.svg","large":"public/app/plugins/panel/heatmap/img/icn-heatmap-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/heatmap/module","name":"Heatmap","signature":"internal","skipDataQuery":false,"sort":10,"state":""},"histogram":{"baseUrl":"public/app/plugins/panel/histogram","hideFromList":false,"id":"histogram","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"","links":null,"logos":{"small":"public/app/plugins/panel/histogram/img/histogram.svg","large":"public/app/plugins/panel/histogram/img/histogram.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/histogram/module","name":"Histogram","signature":"internal","skipDataQuery":false,"sort":12,"state":"beta"},"logs":{"baseUrl":"public/app/plugins/panel/logs","hideFromList":false,"id":"logs","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"","links":null,"logos":{"small":"public/app/plugins/panel/logs/img/icn-logs-panel.svg","large":"public/app/plugins/panel/logs/img/icn-logs-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/logs/module","name":"Logs","signature":"internal","skipDataQuery":false,"sort":100,"state":""},"news":{"baseUrl":"public/app/plugins/panel/news","hideFromList":false,"id":"news","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"RSS feed reader","links":null,"logos":{"small":"public/app/plugins/panel/news/img/news.svg","large":"public/app/plugins/panel/news/img/news.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/news/module","name":"News","signature":"internal","skipDataQuery":true,"sort":17,"state":"beta"},"nodeGraph":{"baseUrl":"public/app/plugins/panel/nodeGraph","hideFromList":false,"id":"nodeGraph","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"","links":null,"logos":{"small":"public/app/plugins/panel/nodeGraph/img/icn-node-graph.svg","large":"public/app/plugins/panel/nodeGraph/img/icn-node-graph.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/nodeGraph/module","name":"Node Graph","signature":"internal","skipDataQuery":false,"sort":100,"state":"beta"},"piechart":{"baseUrl":"public/app/plugins/panel/piechart","hideFromList":false,"id":"piechart","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"The new core pie chart visualization","links":null,"logos":{"small":"public/app/plugins/panel/piechart/img/icon_piechart.svg","large":"public/app/plugins/panel/piechart/img/icon_piechart.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/piechart/module","name":"Pie chart","signature":"internal","skipDataQuery":false,"sort":8,"state":""},"pluginlist":{"baseUrl":"public/app/plugins/panel/pluginlist","hideFromList":false,"id":"pluginlist","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Plugin List for Grafana","links":null,"logos":{"small":"public/app/plugins/panel/pluginlist/img/icn-dashlist-panel.svg","large":"public/app/plugins/panel/pluginlist/img/icn-dashlist-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/pluginlist/module","name":"Plugin list","signature":"internal","skipDataQuery":true,"sort":100,"state":""},"stat":{"baseUrl":"public/app/plugins/panel/stat","hideFromList":false,"id":"stat","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Big stat values \u0026 sparklines","links":null,"logos":{"small":"public/app/plugins/panel/stat/img/icn-singlestat-panel.svg","large":"public/app/plugins/panel/stat/img/icn-singlestat-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/stat/module","name":"Stat","signature":"internal","skipDataQuery":false,"sort":3,"state":""},"state-timeline":{"baseUrl":"public/app/plugins/panel/state-timeline","hideFromList":false,"id":"state-timeline","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"State changes and durations","links":null,"logos":{"small":"public/app/plugins/panel/state-timeline/img/timeline.svg","large":"public/app/plugins/panel/state-timeline/img/timeline.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/state-timeline/module","name":"State timeline","signature":"internal","skipDataQuery":false,"sort":9,"state":"beta"},"status-history":{"baseUrl":"public/app/plugins/panel/status-history","hideFromList":false,"id":"status-history","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Periodic status history","links":null,"logos":{"small":"public/app/plugins/panel/status-history/img/status.svg","large":"public/app/plugins/panel/status-history/img/status.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/status-history/module","name":"Status history","signature":"internal","skipDataQuery":false,"sort":11,"state":"beta"},"table":{"baseUrl":"public/app/plugins/panel/table","hideFromList":false,"id":"table","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Supports many column styles","links":null,"logos":{"small":"public/app/plugins/panel/table/img/icn-table-panel.svg","large":"public/app/plugins/panel/table/img/icn-table-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/table/module","name":"Table","signature":"internal","skipDataQuery":false,"sort":6,"state":""},"table-old":{"baseUrl":"public/app/plugins/panel/table-old","hideFromList":false,"id":"table-old","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Table Panel for Grafana","links":null,"logos":{"small":"public/app/plugins/panel/table-old/img/icn-table-panel.svg","large":"public/app/plugins/panel/table-old/img/icn-table-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/table-old/module","name":"Table (old)","signature":"internal","skipDataQuery":false,"sort":100,"state":"deprecated"},"text":{"baseUrl":"public/app/plugins/panel/text","hideFromList":false,"id":"text","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Supports markdown and html content","links":null,"logos":{"small":"public/app/plugins/panel/text/img/icn-text-panel.svg","large":"public/app/plugins/panel/text/img/icn-text-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/text/module","name":"Text","signature":"internal","skipDataQuery":true,"sort":14,"state":""},"timeseries":{"baseUrl":"public/app/plugins/panel/timeseries","hideFromList":false,"id":"timeseries","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Time based line, area and bar charts","links":null,"logos":{"small":"public/app/plugins/panel/timeseries/img/icn-timeseries-panel.svg","large":"public/app/plugins/panel/timeseries/img/icn-timeseries-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/timeseries/module","name":"Time series","signature":"internal","skipDataQuery":false,"sort":1,"state":""},"welcome":{"baseUrl":"public/app/plugins/panel/welcome","hideFromList":true,"id":"welcome","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"","links":null,"logos":{"small":"public/app/plugins/panel/welcome/img/icn-dashlist-panel.svg","large":"public/app/plugins/panel/welcome/img/icn-dashlist-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/welcome/module","name":"Welcome","signature":"internal","skipDataQuery":true,"sort":100,"state":""}},"passwordHint":"password","pluginAdminEnabled":true,"pluginAdminExternalManageEnabled":false,"pluginCatalogHiddenPlugins":[""],"pluginCatalogURL":"https://grafana.com/grafana/plugins/","pluginsToPreload":[],"recordedQueries":{"enabled":false},"rendererAvailable":false,"rendererVersion":"","rudderstackDataPlaneUrl":"","rudderstackWriteKey":"","samlEnabled":false,"samlName":"SAML","sentry":{"enabled":false,"dsn":"","customEndpoint":"/log","sampleRate":1},"sigV4AuthEnabled":false,"unifiedAlertingEnabled":true,"verifyEmailEnabled":false,"viewersCanEdit":false},
        navTree: [{"id":"dashboards","text":"Dashboards","section":"core","subTitle":"Manage dashboards and folders","icon":"apps","url":"/","sortWeight":-1800,"children":[{"id":"home","text":"Home","icon":"home-alt","url":"/","hideFromTabs":true},{"id":"divider","text":"Divider","divider":true,"hideFromTabs":true},{"id":"manage-dashboards","text":"Browse","icon":"sitemap","url":"/dashboards"},{"id":"playlists","text":"Playlists","icon":"presentation-play","url":"/playlists"}]},{"id":"alerting","text":"Alerting","section":"core","subTitle":"Alert rules and notifications","icon":"bell","url":"/alerting/list","sortWeight":-1600,"children":[{"id":"alert-list","text":"Alert rules","icon":"list-ul","url":"/alerting/list"},{"id":"silences","text":"Silences","icon":"bell-slash","url":"/alerting/silences"},{"id":"groups","text":"Alert groups","icon":"layer-group","url":"/alerting/groups"}]},{"id":"help","text":"Help","section":"config","subTitle":"Grafana v8.3.3 (30bb7a93ca)","icon":"question-circle","url":"#","sortWeight":-1100}],
        themePaths: {
          light: 'public/build/grafana.light.6839ffb2aed352838f3a.css',
          dark: 'public/build/grafana.dark.6839ffb2aed352838f3a.css'
        }
      };

      window.__grafana_load_failed = function() {
        var preloader = document.getElementsByClassName("preloader");
        if (preloader.length) {
          preloader[0].className = "preloader preloader--done";
        }
      }

      
      window.onload = function() {
        if (window.__grafana_app_bundle_loaded) {
          return;
        }
        window.__grafana_load_failed();
      };

      
      </script><script nonce="" src="public/build/runtime.6839ffb2aed352838f3a.js"></script><script nonce="" src="public/build/3144.6839ffb2aed352838f3a.js"></script><script nonce="" src="public/build/4210.6839ffb2aed352838f3a.js"></script><script nonce="" src="public/build/633.6839ffb2aed352838f3a.js"></script><script nonce="" src="public/build/6278.6839ffb2aed352838f3a.js"></script><script nonce="" src="public/build/7095.6839ffb2aed352838f3a.js"></script><script nonce="" src="public/build/app.6839ffb2aed352838f3a.js"></script><script nonce="">performance.mark('frontend_boot_js_done_time_seconds');</script></body></html>

================
File: index.html.2
================
<!doctype html><html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><meta name="viewport" content="width=device-width"/><meta name="theme-color" content="#000"/><title>Grafana</title><base href="/"/><link rel="preload" href="public/fonts/roboto/RxZJdnzeo3R5zSexge8UUVtXRa8TVwTICgirnJhmVJw.woff2" as="font" crossorigin/><link rel="icon" type="image/png" href="public/img/fav32.png"/><link rel="apple-touch-icon" sizes="180x180" href="public/img/apple-touch-icon.png"/><link rel="mask-icon" href="public/img/grafana_mask_icon.svg" color="#F05A28"/><link rel="stylesheet" href="public/build/grafana.dark.6839ffb2aed352838f3a.css"/><script nonce="">performance.mark('frontend_boot_css_time_seconds');</script><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-TileColor" content="#2b5797"/><meta name="msapplication-config" content="public/img/browserconfig.xml"/></head><body class="theme-dark app-grafana"><style>.preloader {
        height: 100%;
        flex-direction: column;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      .preloader__enter {
        opacity: 0;
        animation-name: preloader-fade-in;
        animation-iteration-count: 1;
        animation-duration: 0.9s;
        animation-delay: 1.35s;
        animation-fill-mode: forwards;
      }

      .preloader__bounce {
        text-align: center;
        animation-name: preloader-bounce;
        animation-duration: 0.9s;
        animation-iteration-count: infinite;
      }

      .preloader__logo {
        display: inline-block;
        animation-name: preloader-squash;
        animation-duration: 0.9s;
        animation-iteration-count: infinite;
        width: 60px;
        height: 60px;
        background-repeat: no-repeat;
        background-size: contain;
        background-image: url('public/img/grafana_icon.svg');
      }

      .preloader__text {
        margin-top: 16px;
        font-weight: 500;
        font-size: 14px;
        font-family: Sans-serif;
        opacity: 0;
        animation-name: preloader-fade-in;
        animation-duration: 0.9s;
        animation-delay: 1.8s;
        animation-fill-mode: forwards;
      }

      .theme-light .preloader__text {
        color: #52545c;
      }

      .theme-dark .preloader__text {
        color: #d8d9da;
      }

      @keyframes preloader-fade-in {
        0% {
          opacity: 0;
           
          animation-timing-function: cubic-bezier(0, 0, 0.5, 1);
        }
        100% {
          opacity: 1;
        }
      }

      @keyframes preloader-bounce {
        from,
        to {
          transform: translateY(0px);
          animation-timing-function: cubic-bezier(0.3, 0, 0.1, 1);
        }
        50% {
          transform: translateY(-50px);
          animation-timing-function: cubic-bezier(0.9, 0, 0.7, 1);
        }
      }

      @keyframes preloader-squash {
        0% {
          transform: scaleX(1.3) scaleY(0.8);
          animation-timing-function: cubic-bezier(0.3, 0, 0.1, 1);
          transform-origin: bottom center;
        }
        15% {
          transform: scaleX(0.75) scaleY(1.25);
          animation-timing-function: cubic-bezier(0, 0, 0.7, 0.75);
          transform-origin: bottom center;
        }
        55% {
          transform: scaleX(1.05) scaleY(0.95);
          animation-timing-function: cubic-bezier(0.9, 0, 1, 1);
          transform-origin: top center;
        }
        95% {
          transform: scaleX(0.75) scaleY(1.25);
          animation-timing-function: cubic-bezier(0, 0, 0, 1);
          transform-origin: bottom center;
        }
        100% {
          transform: scaleX(1.3) scaleY(0.8);
          transform-origin: bottom center;
          animation-timing-function: cubic-bezier(0, 0, 0.7, 1);
        }
      }

       
      .preloader__text--fail {
        display: none;
      }

       
      .preloader--done .preloader__bounce,
      .preloader--done .preloader__logo {
        animation-name: none;
        display: none;
      }

      .preloader--done .preloader__logo,
      .preloader--done .preloader__text {
        display: none;
        color: #ff5705 !important;
        font-size: 15px;
      }

      .preloader--done .preloader__text--fail {
        display: block;
      }

      [ng\:cloak],
      [ng-cloak],
      .ng-cloak {
        display: none !important;
      }</style><div class="preloader"><div class="preloader__enter"><div class="preloader__bounce"><div class="preloader__logo"></div></div></div><div class="preloader__text">Loading Grafana</div><div class="preloader__text preloader__text--fail"><p><strong>If you're seeing this Grafana has failed to load its application files</strong><br/><br/></p><p>1. This could be caused by your reverse proxy settings.<br/><br/>2. If you host grafana under subpath make sure your grafana.ini root_url setting includes subpath. If not using a reverse proxy make sure to set serve_from_sub_path to true.<br/><br/>3. If you have a local dev build make sure you build frontend using: yarn start, yarn start:hot, or yarn build<br/><br/>4. Sometimes restarting grafana-server can help<br/><br/>5. Check if you are using a non-supported browser. For more information, refer to the list of <a href="https://grafana.com/docs/grafana/latest/installation/requirements/#supported-web-browsers">supported browsers</a>.</p></div><script nonce="">
        
        function checkBrowserCompatibility() {
          var isIE = navigator.userAgent.indexOf('MSIE') > -1;
          var isEdge = navigator.userAgent.indexOf('Edge/') > -1 || navigator.userAgent.indexOf('Edg/') > -1;
          var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
          var isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);

          

          var isEdgeVersion = /Edge\/([0-9.]+)/.exec(navigator.userAgent);

          if (isIE && parseFloat(/Trident\/([0-9.]+)/.exec(navigator.userAgent)[1]) <= 7) {
            return false;
          } else if (
            isEdge &&
            ((isEdgeVersion && parseFloat(isEdgeVersion[1]) <= 16) ||
              parseFloat(/Edg\/([0-9.]+)/.exec(navigator.userAgent)[1]) <= 16)
          ) {
            return false;
          } else if (isFirefox && parseFloat(/Firefox\/([0-9.]+)/.exec(navigator.userAgent)[1]) <= 64) {
            return false;
          } else if (isChrome && parseFloat(/Chrome\/([0-9.]+)/.exec(navigator.userAgent)[1]) <= 54) {
            return false;
          }

          return true;
        }

        if (!checkBrowserCompatibility()) {
          alert('Your browser is not fully supported, please try newer version.');
        }</script></div><div id="reactRoot"></div><script nonce="">window.grafanaBootData = {
        user: {"isSignedIn":false,"id":0,"login":"","email":"","name":"","lightTheme":false,"orgCount":0,"orgId":0,"orgName":"","orgRole":"","isGrafanaAdmin":false,"gravatarUrl":"","timezone":"browser","weekStart":"browser","locale":"en-US","helpFlags1":0,"hasEditPermissionInFolders":false},
        settings: {"alertingEnabled":false,"alertingErrorOrTimeout":"alerting","alertingMinInterval":1,"alertingNoDataOrNullValues":"no_data","allowOrgCreate":false,"appSubUrl":"","appUrl":"http://localhost:3000/","applicationInsightsConnectionString":"","applicationInsightsEndpointUrl":"","authProxyEnabled":false,"autoAssignOrg":true,"awsAllowedAuthProviders":["default","keys","credentials"],"awsAssumeRoleEnabled":true,"azure":{"cloud":"AzureCloud","managedIdentityEnabled":false},"buildInfo":{"buildstamp":1639154540,"commit":"30bb7a93ca","edition":"Open Source","env":"production","hasUpdate":true,"hideVersion":false,"isEnterprise":false,"latestVersion":"10.2.3","version":"8.3.3"},"caching":{"enabled":true},"datasources":{"-- Dashboard --":{"meta":{"id":"dashboard","type":"datasource","name":"-- Dashboard --","info":{"author":{"name":"","url":""},"description":"","links":null,"logos":{"small":"public/img/icn-datasource.svg","large":"public/img/icn-datasource.svg"},"build":{},"screenshots":null,"version":"","updated":""},"dependencies":{"grafanaDependency":"","grafanaVersion":"*","plugins":[]},"includes":null,"category":"","preload":false,"backend":false,"routes":null,"skipDataQuery":false,"autoEnabled":false,"annotations":false,"metrics":true,"alerting":false,"explore":false,"tables":false,"logs":false,"tracing":false,"builtIn":true,"streaming":false,"signature":"internal","module":"app/plugins/datasource/dashboard/module","baseUrl":"public/app/plugins/datasource/dashboard"},"name":"-- Dashboard --","type":"datasource"},"-- Grafana --":{"id":-1,"meta":{"id":"grafana","type":"datasource","name":"-- Grafana --","info":{"author":{"name":"","url":""},"description":"","links":null,"logos":{"small":"public/img/icn-datasource.svg","large":"public/img/icn-datasource.svg"},"build":{},"screenshots":null,"version":"","updated":""},"dependencies":{"grafanaDependency":"","grafanaVersion":"*","plugins":[]},"includes":null,"category":"","preload":false,"backend":false,"routes":null,"skipDataQuery":false,"autoEnabled":false,"annotations":true,"metrics":true,"alerting":false,"explore":false,"tables":false,"logs":false,"tracing":false,"builtIn":true,"streaming":false,"signature":"internal","module":"app/plugins/datasource/grafana/module","baseUrl":"public/app/plugins/datasource/grafana"},"name":"-- Grafana --","type":"datasource","uid":"grafana"},"-- Mixed --":{"meta":{"id":"mixed","type":"datasource","name":"-- Mixed --","info":{"author":{"name":"","url":""},"description":"","links":null,"logos":{"small":"public/img/icn-datasource.svg","large":"public/img/icn-datasource.svg"},"build":{},"screenshots":null,"version":"","updated":""},"dependencies":{"grafanaDependency":"","grafanaVersion":"*","plugins":[]},"includes":null,"category":"","preload":false,"backend":false,"routes":null,"skipDataQuery":false,"autoEnabled":false,"annotations":false,"metrics":true,"alerting":false,"explore":false,"tables":false,"logs":false,"tracing":false,"queryOptions":{"minInterval":true},"builtIn":true,"mixed":true,"streaming":false,"signature":"internal","module":"app/plugins/datasource/mixed/module","baseUrl":"public/app/plugins/datasource/mixed"},"name":"-- Mixed --","type":"datasource"}},"dateFormats":{"fullDate":"YYYY-MM-DD HH:mm:ss","useBrowserLocale":false,"interval":{"second":"HH:mm:ss","minute":"HH:mm","hour":"MM/DD HH:mm","day":"MM/DD","month":"YYYY-MM","year":"YYYY"},"defaultTimezone":"browser","defaultWeekStart":"browser"},"defaultDatasource":"-- Grafana --","disableLoginForm":false,"disableSanitizeHtml":false,"disableUserSignUp":true,"editorsCanAdmin":false,"exploreEnabled":true,"expressionsEnabled":true,"externalUserMngInfo":"","externalUserMngLinkName":"","externalUserMngLinkUrl":"","featureToggles":{},"googleAnalyticsId":"","http2Enabled":false,"ldapEnabled":false,"licenseInfo":{"edition":"Open Source","expiry":0,"hasLicense":false,"hasValidLicense":false,"licenseUrl":"https://grafana.com/oss/grafana?utm_source=grafana_footer","stateInfo":""},"liveEnabled":true,"loginHint":"email or username","minRefreshInterval":"5s","oauth":{},"panels":{"alertlist":{"baseUrl":"public/app/plugins/panel/alertlist","hideFromList":false,"id":"alertlist","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Shows list of alerts and their current status","links":null,"logos":{"small":"public/app/plugins/panel/alertlist/img/icn-singlestat-panel.svg","large":"public/app/plugins/panel/alertlist/img/icn-singlestat-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/alertlist/module","name":"Alert list","signature":"internal","skipDataQuery":true,"sort":15,"state":""},"annolist":{"baseUrl":"public/app/plugins/panel/annolist","hideFromList":false,"id":"annolist","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"List annotations","links":null,"logos":{"small":"public/app/plugins/panel/annolist/img/icn-annolist-panel.svg","large":"public/app/plugins/panel/annolist/img/icn-annolist-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/annolist/module","name":"Annotations list","signature":"internal","skipDataQuery":true,"sort":100,"state":""},"barchart":{"baseUrl":"public/app/plugins/panel/barchart","hideFromList":false,"id":"barchart","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Categorical charts with group support","links":null,"logos":{"small":"public/app/plugins/panel/barchart/img/barchart.svg","large":"public/app/plugins/panel/barchart/img/barchart.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/barchart/module","name":"Bar chart","signature":"internal","skipDataQuery":false,"sort":2,"state":"beta"},"bargauge":{"baseUrl":"public/app/plugins/panel/bargauge","hideFromList":false,"id":"bargauge","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Horizontal and vertical gauges","links":null,"logos":{"small":"public/app/plugins/panel/bargauge/img/icon_bar_gauge.svg","large":"public/app/plugins/panel/bargauge/img/icon_bar_gauge.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/bargauge/module","name":"Bar gauge","signature":"internal","skipDataQuery":false,"sort":5,"state":""},"candlestick":{"baseUrl":"public/app/plugins/panel/candlestick","hideFromList":false,"id":"candlestick","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"","links":null,"logos":{"small":"public/app/plugins/panel/candlestick/img/candlestick.svg","large":"public/app/plugins/panel/candlestick/img/candlestick.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/candlestick/module","name":"Candlestick","signature":"internal","skipDataQuery":false,"sort":100,"state":"beta"},"dashlist":{"baseUrl":"public/app/plugins/panel/dashlist","hideFromList":false,"id":"dashlist","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"List of dynamic links to other dashboards","links":null,"logos":{"small":"public/app/plugins/panel/dashlist/img/icn-dashlist-panel.svg","large":"public/app/plugins/panel/dashlist/img/icn-dashlist-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/dashlist/module","name":"Dashboard list","signature":"internal","skipDataQuery":true,"sort":16,"state":""},"gauge":{"baseUrl":"public/app/plugins/panel/gauge","hideFromList":false,"id":"gauge","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Standard gauge visualization","links":null,"logos":{"small":"public/app/plugins/panel/gauge/img/icon_gauge.svg","large":"public/app/plugins/panel/gauge/img/icon_gauge.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/gauge/module","name":"Gauge","signature":"internal","skipDataQuery":false,"sort":4,"state":""},"geomap":{"baseUrl":"public/app/plugins/panel/geomap","hideFromList":false,"id":"geomap","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Geomap panel","links":null,"logos":{"small":"public/app/plugins/panel/geomap/img/icn-geomap.svg","large":"public/app/plugins/panel/geomap/img/icn-geomap.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/geomap/module","name":"Geomap","signature":"internal","skipDataQuery":false,"sort":100,"state":"beta"},"gettingstarted":{"baseUrl":"public/app/plugins/panel/gettingstarted","hideFromList":true,"id":"gettingstarted","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"","links":null,"logos":{"small":"public/app/plugins/panel/gettingstarted/img/icn-dashlist-panel.svg","large":"public/app/plugins/panel/gettingstarted/img/icn-dashlist-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/gettingstarted/module","name":"Getting Started","signature":"internal","skipDataQuery":true,"sort":100,"state":""},"graph":{"baseUrl":"public/app/plugins/panel/graph","hideFromList":false,"id":"graph","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"The old default graph panel","links":null,"logos":{"small":"public/app/plugins/panel/graph/img/icn-graph-panel.svg","large":"public/app/plugins/panel/graph/img/icn-graph-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/graph/module","name":"Graph (old)","signature":"internal","skipDataQuery":false,"sort":13,"state":""},"heatmap":{"baseUrl":"public/app/plugins/panel/heatmap","hideFromList":false,"id":"heatmap","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Like a histogram over time","links":[{"name":"Brendan Gregg - Heatmaps","url":"http://www.brendangregg.com/heatmaps.html"},{"name":"Brendan Gregg - Latency Heatmaps","url":" http://www.brendangregg.com/HeatMaps/latency.html"}],"logos":{"small":"public/app/plugins/panel/heatmap/img/icn-heatmap-panel.svg","large":"public/app/plugins/panel/heatmap/img/icn-heatmap-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/heatmap/module","name":"Heatmap","signature":"internal","skipDataQuery":false,"sort":10,"state":""},"histogram":{"baseUrl":"public/app/plugins/panel/histogram","hideFromList":false,"id":"histogram","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"","links":null,"logos":{"small":"public/app/plugins/panel/histogram/img/histogram.svg","large":"public/app/plugins/panel/histogram/img/histogram.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/histogram/module","name":"Histogram","signature":"internal","skipDataQuery":false,"sort":12,"state":"beta"},"logs":{"baseUrl":"public/app/plugins/panel/logs","hideFromList":false,"id":"logs","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"","links":null,"logos":{"small":"public/app/plugins/panel/logs/img/icn-logs-panel.svg","large":"public/app/plugins/panel/logs/img/icn-logs-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/logs/module","name":"Logs","signature":"internal","skipDataQuery":false,"sort":100,"state":""},"news":{"baseUrl":"public/app/plugins/panel/news","hideFromList":false,"id":"news","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"RSS feed reader","links":null,"logos":{"small":"public/app/plugins/panel/news/img/news.svg","large":"public/app/plugins/panel/news/img/news.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/news/module","name":"News","signature":"internal","skipDataQuery":true,"sort":17,"state":"beta"},"nodeGraph":{"baseUrl":"public/app/plugins/panel/nodeGraph","hideFromList":false,"id":"nodeGraph","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"","links":null,"logos":{"small":"public/app/plugins/panel/nodeGraph/img/icn-node-graph.svg","large":"public/app/plugins/panel/nodeGraph/img/icn-node-graph.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/nodeGraph/module","name":"Node Graph","signature":"internal","skipDataQuery":false,"sort":100,"state":"beta"},"piechart":{"baseUrl":"public/app/plugins/panel/piechart","hideFromList":false,"id":"piechart","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"The new core pie chart visualization","links":null,"logos":{"small":"public/app/plugins/panel/piechart/img/icon_piechart.svg","large":"public/app/plugins/panel/piechart/img/icon_piechart.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/piechart/module","name":"Pie chart","signature":"internal","skipDataQuery":false,"sort":8,"state":""},"pluginlist":{"baseUrl":"public/app/plugins/panel/pluginlist","hideFromList":false,"id":"pluginlist","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Plugin List for Grafana","links":null,"logos":{"small":"public/app/plugins/panel/pluginlist/img/icn-dashlist-panel.svg","large":"public/app/plugins/panel/pluginlist/img/icn-dashlist-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/pluginlist/module","name":"Plugin list","signature":"internal","skipDataQuery":true,"sort":100,"state":""},"stat":{"baseUrl":"public/app/plugins/panel/stat","hideFromList":false,"id":"stat","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Big stat values \u0026 sparklines","links":null,"logos":{"small":"public/app/plugins/panel/stat/img/icn-singlestat-panel.svg","large":"public/app/plugins/panel/stat/img/icn-singlestat-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/stat/module","name":"Stat","signature":"internal","skipDataQuery":false,"sort":3,"state":""},"state-timeline":{"baseUrl":"public/app/plugins/panel/state-timeline","hideFromList":false,"id":"state-timeline","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"State changes and durations","links":null,"logos":{"small":"public/app/plugins/panel/state-timeline/img/timeline.svg","large":"public/app/plugins/panel/state-timeline/img/timeline.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/state-timeline/module","name":"State timeline","signature":"internal","skipDataQuery":false,"sort":9,"state":"beta"},"status-history":{"baseUrl":"public/app/plugins/panel/status-history","hideFromList":false,"id":"status-history","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Periodic status history","links":null,"logos":{"small":"public/app/plugins/panel/status-history/img/status.svg","large":"public/app/plugins/panel/status-history/img/status.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/status-history/module","name":"Status history","signature":"internal","skipDataQuery":false,"sort":11,"state":"beta"},"table":{"baseUrl":"public/app/plugins/panel/table","hideFromList":false,"id":"table","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Supports many column styles","links":null,"logos":{"small":"public/app/plugins/panel/table/img/icn-table-panel.svg","large":"public/app/plugins/panel/table/img/icn-table-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/table/module","name":"Table","signature":"internal","skipDataQuery":false,"sort":6,"state":""},"table-old":{"baseUrl":"public/app/plugins/panel/table-old","hideFromList":false,"id":"table-old","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Table Panel for Grafana","links":null,"logos":{"small":"public/app/plugins/panel/table-old/img/icn-table-panel.svg","large":"public/app/plugins/panel/table-old/img/icn-table-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/table-old/module","name":"Table (old)","signature":"internal","skipDataQuery":false,"sort":100,"state":"deprecated"},"text":{"baseUrl":"public/app/plugins/panel/text","hideFromList":false,"id":"text","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Supports markdown and html content","links":null,"logos":{"small":"public/app/plugins/panel/text/img/icn-text-panel.svg","large":"public/app/plugins/panel/text/img/icn-text-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/text/module","name":"Text","signature":"internal","skipDataQuery":true,"sort":14,"state":""},"timeseries":{"baseUrl":"public/app/plugins/panel/timeseries","hideFromList":false,"id":"timeseries","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"Time based line, area and bar charts","links":null,"logos":{"small":"public/app/plugins/panel/timeseries/img/icn-timeseries-panel.svg","large":"public/app/plugins/panel/timeseries/img/icn-timeseries-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/timeseries/module","name":"Time series","signature":"internal","skipDataQuery":false,"sort":1,"state":""},"welcome":{"baseUrl":"public/app/plugins/panel/welcome","hideFromList":true,"id":"welcome","info":{"author":{"name":"Grafana Labs","url":"https://grafana.com"},"description":"","links":null,"logos":{"small":"public/app/plugins/panel/welcome/img/icn-dashlist-panel.svg","large":"public/app/plugins/panel/welcome/img/icn-dashlist-panel.svg"},"build":{},"screenshots":null,"version":"","updated":""},"module":"app/plugins/panel/welcome/module","name":"Welcome","signature":"internal","skipDataQuery":true,"sort":100,"state":""}},"passwordHint":"password","pluginAdminEnabled":true,"pluginAdminExternalManageEnabled":false,"pluginCatalogHiddenPlugins":[""],"pluginCatalogURL":"https://grafana.com/grafana/plugins/","pluginsToPreload":[],"recordedQueries":{"enabled":false},"rendererAvailable":false,"rendererVersion":"","rudderstackDataPlaneUrl":"","rudderstackWriteKey":"","samlEnabled":false,"samlName":"SAML","sentry":{"enabled":false,"dsn":"","customEndpoint":"/log","sampleRate":1},"sigV4AuthEnabled":false,"unifiedAlertingEnabled":true,"verifyEmailEnabled":false,"viewersCanEdit":false},
        navTree: [{"id":"dashboards","text":"Dashboards","section":"core","subTitle":"Manage dashboards and folders","icon":"apps","url":"/","sortWeight":-1800,"children":[{"id":"home","text":"Home","icon":"home-alt","url":"/","hideFromTabs":true},{"id":"divider","text":"Divider","divider":true,"hideFromTabs":true},{"id":"manage-dashboards","text":"Browse","icon":"sitemap","url":"/dashboards"},{"id":"playlists","text":"Playlists","icon":"presentation-play","url":"/playlists"}]},{"id":"alerting","text":"Alerting","section":"core","subTitle":"Alert rules and notifications","icon":"bell","url":"/alerting/list","sortWeight":-1600,"children":[{"id":"alert-list","text":"Alert rules","icon":"list-ul","url":"/alerting/list"},{"id":"silences","text":"Silences","icon":"bell-slash","url":"/alerting/silences"},{"id":"groups","text":"Alert groups","icon":"layer-group","url":"/alerting/groups"}]},{"id":"help","text":"Help","section":"config","subTitle":"Grafana v8.3.3 (30bb7a93ca)","icon":"question-circle","url":"#","sortWeight":-1100}],
        themePaths: {
          light: 'public/build/grafana.light.6839ffb2aed352838f3a.css',
          dark: 'public/build/grafana.dark.6839ffb2aed352838f3a.css'
        }
      };

      window.__grafana_load_failed = function() {
        var preloader = document.getElementsByClassName("preloader");
        if (preloader.length) {
          preloader[0].className = "preloader preloader--done";
        }
      }

      
      window.onload = function() {
        if (window.__grafana_app_bundle_loaded) {
          return;
        }
        window.__grafana_load_failed();
      };

      
      </script><script nonce="" src="public/build/runtime.6839ffb2aed352838f3a.js"></script><script nonce="" src="public/build/3144.6839ffb2aed352838f3a.js"></script><script nonce="" src="public/build/4210.6839ffb2aed352838f3a.js"></script><script nonce="" src="public/build/633.6839ffb2aed352838f3a.js"></script><script nonce="" src="public/build/6278.6839ffb2aed352838f3a.js"></script><script nonce="" src="public/build/7095.6839ffb2aed352838f3a.js"></script><script nonce="" src="public/build/app.6839ffb2aed352838f3a.js"></script><script nonce="">performance.mark('frontend_boot_js_done_time_seconds');</script></body></html>

================
File: index.tsx
================
import React from 'react';
import ReactDOM from 'react-dom';
import { Provider } from 'react-redux';
import { PersistGate } from 'redux-persist/integration/react';
import { store, persistor } from './redux/store';
import App from './App';
import './index.css';
import * as serviceWorkerRegistration from './serviceWorkerRegistration';
import reportWebVitals from './reportWebVitals';
import { BrowserRouter as Router } from 'react-router-dom';
import { ThemeProvider } from './components/ThemeProvider';
import { ClientBrandingProvider } from './components/ClientBrandingProvider';
import { ErrorBoundary } from './components/ErrorBoundary';

ReactDOM.render(
  <React.StrictMode>
    <ErrorBoundary>
      <Provider store={store}>
        <PersistGate loading={null} persistor={persistor}>
          <Router>
            <ThemeProvider>
              <ClientBrandingProvider>
                <App />
              </ClientBrandingProvider>
            </ThemeProvider>
          </Router>
        </PersistGate>
      </Provider>
    </ErrorBoundary>
  </React.StrictMode>,
  document.getElementById('root')
);

// If you want your app to work offline and load faster, you can change
// unregister() to register() below. Note this comes with some pitfalls.
// Learn more about service workers: https://cra.link/PWA
serviceWorkerRegistration.register();

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();

// Add any additional initialization or global setup here

================
File: logo.svg
================
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 841.9 595.3"><g fill="#61DAFB"><path d="M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z"/><circle cx="420.9" cy="296.5" r="45.7"/><path d="M520.5 78.1z"/></g></svg>

================
File: missing-types.txt
================
(
()
(data
(dateRange
(discountedTotal
(error
(id
(item
(locationId
(user
0
0,
1
1,
2
2,
3,
345,
4
400,
6,
ABTest)
Challenge)
CustomerMetrics
Date
Discount[]
DropOffLocation)
DropResult)
Error)
Error,
ErrorInfo)
FC<LayoutProps>
InventoryItem[]
Item
KeyboardEvent<HTMLDivElement>)
Location
Location)
LocationUpdateData)
Location[]
LoginFormInputs)
LoyaltyChallenge
LoyaltyReward)
LoyaltyTier
MenuItem)
MenuItem,
Modifier[]
Number(feeAmount),
Omit<CorePOSProfile,
Omit<Discount,
Omit<ServiceFee,
POSProfile)
Partial<CorePOSProfile>
Partial<LoyaltyChallenge>
Provider)
React
ReactNode
RevenueData[]
RootState)
SalesByCategory)
SelectChangeEvent<ChallengeType>)
State
SubmitHandler<LoginFormInputs>
Theme
UserRole[]
[
[Dayjs,
[]
[],
[number,
[string,
[updatedGroup]
activeMenu
any
any)
any,
boolean
boolean)
branding
challenge
clientId
data
defaultPosition
discountName,
e
editingCampaign
event
false,
feeName,
formData
formattedEndDate
formattedStartDate,
getAlertSeverity(alert
item
keyof
loc
location
name
new
newGroupName
newGroups,
newItemDescription,
newItemName,
newStatus
newTiers
null}
number
number)
number,
parseFloat(discountValue
parseFloat(e
parseFloat(minPurchaseAmount),
parseFloat(newItemPrice),
parseFloat(value),
parseInt(e
parseInt(maxUses,
string
string)
string,
true
true,
undefined
unknown
updatedItems
updatedLocation
updatedMenu
value
value,
{
{JSON
{alert
{challenge
{currentMetric[1]}
{currentProgress}
{error}
{error}<
{fee
{guestProfile
{item
{lastSyncTime
{location
{new
{posProfiles
{selectedLocation

================
File: reducers.ts
================
import rootReducer from './redux/rootReducer';

export default rootReducer;

================
File: reportWebVitals.ts
================
import { ReportHandler } from 'web-vitals';

const reportWebVitals = (onPerfEntry?: ReportHandler) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;

================
File: routes.tsx
================
import React from 'react';
import { Routes, Route } from 'react-router-dom';
import { UserRole } from './types/userTypes';
import PrivateRoute from './components/PrivateRoute';
import Dashboard from './pages/Dashboard';
import GuestLandingPage from './pages/GuestLandingPage';
import Login from './pages/Login';
import Menu from './pages/Menu';
import OrderConfirmation from './pages/OrderConfirmation';
import LocationManagement from './pages/LocationManagement';
import MenuBuilder from './pages/MenuBuilder';
import OrderPage from './pages/OrderPage';
import OrderScheduling from './pages/OrderScheduling';
import PosProfilePage from './pages/PosProfilePage';
import ProfilePage from './pages/ProfilePage';
import Wallet from './pages/Wallet';
import ClientLocationsPage from './pages/ClientLocationsPage';
import ABTestManagement from './pages/ABTestManagement';
import AdminDashboard from './pages/AdminDashboard';
import AdminDiscounts from './pages/AdminDiscounts';
import AdminLocationManagement from './pages/AdminLocationManagement';
import AdminLoyaltyManagement from './pages/AdminLoyaltyManagement';
import AdminLoyaltyRewards from './pages/AdminLoyaltyRewards';
import AdminMenuManagement from './pages/AdminMenuManagement';
import AdminWalletManagement from './pages/AdminWalletManagement';
import BrandingManagement from './pages/BrandingManagement';
import BrandingSettings from './pages/BrandingSettings';
import BusinessAdminDashboard from './pages/BusinessAdminDashboard';
import CateringMenuItems from './pages/CateringMenuItems';
import CateringMenus from './pages/CateringMenus';
import CateringOrderAssignments from './pages/CateringOrderAssignments';
import CateringOrders from './pages/CateringOrders';
import ClientSettings from './pages/ClientSettings';
import GlobalAdminDashboard from './pages/GlobalAdminDashboard';
import GuestMenuPage from './pages/GuestMenuPage';
import GuestProfile from './pages/GuestProfile';
import HomePage from './pages/HomePage';
import Inventory from './pages/Inventory';
import InventoryManagement from './pages/InventoryManagement';
import LoyaltyManagement from './pages/LoyaltyManagement';
import MenuManagementAdmin from './pages/MenuManagementAdmin';
import MenuPage from './pages/MenuPage';
import POSSettingsPage from './pages/PosSettingsPage';
import Register from './pages/Register';
import ReportingDashboard from './pages/ReportingDashboard';
import UserManagement from './pages/UserManagement';
import AdminPanel from './pages/AdminPanel'; // Add this import

const AppRoutes: React.FC = () => {
  return (
    <Routes>
      <Route path="/" element={<GuestLandingPage />} />
      <Route path="/login" element={<Login />} />
      <Route path="/register" element={<Register />} />
      <Route path="/menu/:locationId" element={<Menu />} />
      <Route
        path="/order-confirmation/:orderId"
        element={<OrderConfirmation />}
      />
      <Route path="/guest-menu" element={<GuestMenuPage />} />
      <Route path="/home" element={<HomePage />} />

      <Route
        element={
          <PrivateRoute
            allowedRoles={[
              UserRole.GUEST,
              UserRole.CLIENT_ADMIN,
              UserRole.GLOBAL_ADMIN,
            ]}
          />
        }
      >
        <Route path="/dashboard" element={<Dashboard />} />
        <Route path="/profile" element={<ProfilePage />} />
        <Route path="/wallet" element={<Wallet />} />
        <Route path="/guest-profile" element={<GuestProfile />} />
        <Route path="/order" element={<OrderPage />} />
        <Route path="/order-scheduling" element={<OrderScheduling />} />
      </Route>

      <Route
        element={
          <PrivateRoute
            allowedRoles={[UserRole.CLIENT_ADMIN, UserRole.GLOBAL_ADMIN]}
          />
        }
      >
        <Route path="/admin-dashboard" element={<AdminDashboard />} />
        <Route
          path="/business-admin-dashboard"
          element={<BusinessAdminDashboard />}
        />
        <Route path="/locations" element={<AdminLocationManagement />} />
        <Route path="/menu-management" element={<AdminMenuManagement />} />
        <Route path="/menu-builder" element={<MenuBuilder />} />
        <Route
          path="/loyalty-management"
          element={<AdminLoyaltyManagement />}
        />
        <Route path="/loyalty-rewards" element={<AdminLoyaltyRewards />} />
        <Route path="/discounts" element={<AdminDiscounts />} />
        <Route path="/wallet-management" element={<AdminWalletManagement />} />
        <Route path="/branding-management" element={<BrandingManagement />} />
        <Route path="/branding-settings" element={<BrandingSettings />} />
        <Route path="/catering-menus" element={<CateringMenus />} />
        <Route path="/catering-menu-items" element={<CateringMenuItems />} />
        <Route path="/catering-orders" element={<CateringOrders />} />
        <Route
          path="/catering-order-assignments"
          element={<CateringOrderAssignments />}
        />
        <Route path="/inventory" element={<Inventory />} />
        <Route path="/inventory-management" element={<InventoryManagement />} />
        <Route path="/pos-settings" element={<POSSettingsPage />} />
        <Route path="/pos-profile" element={<PosProfilePage />} />
        <Route path="/reporting" element={<ReportingDashboard />} />
        <Route path="/user-management" element={<UserManagement />} />
        <Route path="/ab-test-management" element={<ABTestManagement />} />
        <Route path="/client-locations" element={<ClientLocationsPage />} />
        <Route path="/client-settings" element={<ClientSettings />} />
      </Route>

      <Route element={<PrivateRoute allowedRoles={[UserRole.GLOBAL_ADMIN]} />}>
        <Route
          path="/global-admin"
          element={<AdminPanel isGlobalAdmin={true} />}
        />
      </Route>
    </Routes>
  );
};

export default AppRoutes;

================
File: serviceWorker.ts
================
// This optional code is used to register a service worker.
// register() is not called by default.

// This lets the app load faster on subsequent visits in production, and gives
// it offline capabilities. However, it also means that developers (and users)
// will only see deployed updates on subsequent visits to a page, after all the
// existing tabs open on the page have been closed, since previously cached
// resources are updated in the background.

const isLocalhost = Boolean(
  window.location.hostname === 'localhost' ||
    // [::1] is the IPv6 localhost address.
    window.location.hostname === '[::1]' ||
    // 127.0.0.0/8 are considered localhost for IPv4.
    window.location.hostname.match(
      /^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/
    )
);

type Config = {
  onSuccess?: (registration: ServiceWorkerRegistration) => void;
  onUpdate?: (registration: ServiceWorkerRegistration) => void;
};

export function register(config?: Config) {
  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {
    // The URL constructor is available in all browsers that support SW.
    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);
    if (publicUrl.origin !== window.location.origin) {
      // Our service worker won't work if PUBLIC_URL is on a different origin
      // from what our page is served on. This might happen if a CDN is used to
      // serve assets; see https://github.com/facebook/create-react-app/issues/2374
      return;
    }

    window.addEventListener('load', () => {
      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;

      if (isLocalhost) {
        // This is running on localhost. Let's check if a service worker still exists or not.
        checkValidServiceWorker(swUrl, config);

        // Add some additional logging to localhost, pointing developers to the
        // service worker/PWA documentation.
        navigator.serviceWorker.ready.then(() => {
          console.log(
            'This web app is being served cache-first by a service ' +
              'worker. To learn more, visit https://bit.ly/CRA-PWA'
          );
        });
      } else {
        // Is not localhost. Just register service worker
        registerValidSW(swUrl, config);
      }
    });
  }
}

function registerValidSW(swUrl: string, config?: Config) {
  navigator.serviceWorker
    .register(swUrl)
    .then((registration) => {
      registration.onupdatefound = () => {
        const installingWorker = registration.installing;
        if (installingWorker == null) {
          return;
        }
        installingWorker.onstatechange = () => {
          if (installingWorker.state === 'installed') {
            if (navigator.serviceWorker.controller) {
              // At this point, the updated precached content has been fetched,
              // but the previous service worker will still serve the older
              // content until all client tabs are closed.
              console.log(
                'New content is available and will be used when all ' +
                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'
              );

              // Execute callback
              if (config && config.onUpdate) {
                config.onUpdate(registration);
              }
            } else {
              // At this point, everything has been precached.
              // It's the perfect time to display a
              // "Content is cached for offline use." message.
              console.log('Content is cached for offline use.');

              // Execute callback
              if (config && config.onSuccess) {
                config.onSuccess(registration);
              }
            }
          }
        };
      };
    })
    .catch((error) => {
      console.error('Error during service worker registration:', error);
    });
}

function checkValidServiceWorker(swUrl: string, config?: Config) {
  // Check if the service worker can be found. If it can't reload the page.
  fetch(swUrl, {
    headers: { 'Service-Worker': 'script' },
  })
    .then((response) => {
      // Ensure service worker exists, and that we really are getting a JS file.
      const contentType = response.headers.get('content-type');
      if (
        response.status === 404 ||
        (contentType != null && contentType.indexOf('javascript') === -1)
      ) {
        // No service worker found. Probably a different app. Reload the page.
        navigator.serviceWorker.ready.then((registration) => {
          registration.unregister().then(() => {
            window.location.reload();
          });
        });
      } else {
        // Service worker found. Proceed as normal.
        registerValidSW(swUrl, config);
      }
    })
    .catch(() => {
      console.log(
        'No internet connection found. App is running in offline mode.'
      );
    });
}

export function unregister() {
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.ready
      .then((registration) => {
        registration.unregister();
      })
      .catch((error) => {
        console.error(error.message);
      });
  }
}

================
File: serviceWorkerRegistration.ts
================
// serviceWorkerRegistration.ts

const isLocalhost = Boolean(
  window.location.hostname === 'localhost' ||
    window.location.hostname === '[::1]' ||
    window.location.hostname.match(/^127(?:\.[0-9]+){0,2}\.[0-9]+$/)
);

type Config = {
  onSuccess?: (registration: ServiceWorkerRegistration) => void;
  onUpdate?: (registration: ServiceWorkerRegistration) => void;
};

export function register(config?: Config) {
  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {
    const publicUrl = new URL(
      process.env.PUBLIC_URL || '',
      window.location.href
    );

    if (publicUrl.origin !== window.location.origin) {
      return;
    }

    window.addEventListener('load', () => {
      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;

      if (isLocalhost) {
        checkValidServiceWorker(swUrl, config);

        navigator.serviceWorker.ready.then(() => {
          console.log(
            'This web app is being served cache-first by a service ' +
              'worker. To learn more, visit https://cra.link/PWA'
          );
        });
      } else {
        registerValidSW(swUrl, config);
      }
    });
  }
}

function registerValidSW(swUrl: string, config?: Config) {
  navigator.serviceWorker
    .register(swUrl)
    .then((registration) => {
      registration.onupdatefound = () => {
        const installingWorker = registration.installing;
        if (installingWorker == null) {
          return;
        }
        installingWorker.onstatechange = () => {
          if (installingWorker.state === 'installed') {
            if (navigator.serviceWorker.controller) {
              console.log(
                'New content is available and will be used when all ' +
                  'tabs for this page are closed. See https://cra.link/PWA.'
              );

              if (config && config.onUpdate) {
                config.onUpdate(registration);
              }
            } else {
              console.log('Content is cached for offline use.');

              if (config && config.onSuccess) {
                config.onSuccess(registration);
              }
            }
          }
        };
      };
    })
    .catch((error) => {
      console.error('Error during service worker registration:', error);
    });
}

function checkValidServiceWorker(swUrl: string, config?: Config) {
  fetch(swUrl, {
    headers: { 'Service-Worker': 'script' },
  })
    .then((response) => {
      const contentType = response.headers.get('content-type');
      if (
        response.status === 404 ||
        (contentType != null && contentType.indexOf('javascript') === -1)
      ) {
        navigator.serviceWorker.ready.then((registration) => {
          registration.unregister().then(() => {
            window.location.reload();
          });
        });
      } else {
        registerValidSW(swUrl, config);
      }
    })
    .catch(() => {
      console.log(
        'No internet connection found. App is running in offline mode.'
      );
    });
}

export function unregister() {
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.ready
      .then((registration) => {
        registration.unregister();
      })
      .catch((error) => {
        console.error(error.message);
      });
  }
}

================
File: setupProxy.js
================
import { createProxyMiddleware } from 'http-proxy-middleware';

export default function setupProxy(app) {
  app.use(
    '/api',
    createProxyMiddleware({
      target: 'https://localhost:5000',
      changeOrigin: true,
      secure: false, // Accept self-signed certificates
    })
  );
}

================
File: theme.ts
================
import { createTheme } from '@mui/material/styles';
import { DefaultTheme } from 'styled-components';

const muiTheme = createTheme({
  palette: {
    primary: {
      main: '#1976d2',
    },
    secondary: {
      main: '#dc004e',
    },
  },
});

const styledTheme: DefaultTheme = {
  colors: {
    primary: muiTheme.palette.primary.main,
    secondary: muiTheme.palette.secondary.main,
    background: muiTheme.palette.background.default,
    text: muiTheme.palette.text.primary,
  },
  fontSizes: {
    small: '0.8rem',
    medium: '1rem',
    large: '1.2rem',
  },
};

export { muiTheme as default, styledTheme };

================
File: types.ts
================
import { store } from './redux/store';

// Define RootState and AppDispatch types
export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

// Define the UserRole type
export type UserRole = 'admin' | 'manager' | 'user';

// Define the OrderType
export type OrderType = 'pickup' | 'delivery' | 'dine-in' | 'catering';

// Define the Reward interface
export interface Reward {
  id: string;
  name: string;
  description: string;
  pointsRequired: number;
}

// Define the interfaces for various entities used in the app

export interface LoyaltyReward {
  id: number;
  name: string;
  pointsRequired: number;
  description?: string;
  expirationDate?: string;
  isActive: boolean;
}

export interface LoyaltyTier {
  id: number;
  firstName: string;
  lastName: string;
  loyaltyPoints: number;
}

export interface Location {
  id: number;
  name: string;
  address: string;
  city: string;
  state: string;
  zipCode: string;
  phoneNumber: string;
  email: string;
  latitude: number;
  longitude: number;
  imageUrl?: string;
  corePOSProfileId?: number;
  posApis?: string[];
  isDropoffSite?: boolean;
  dropOffLocations?: DropOffLocation[];
  twoFactorException: boolean;
  paymentGatewayExceptions: PaymentGateway[];
}

export interface Wallet {
  balance: number;
  guestId: number;
  id?: number;
  discounts?: Discount[];
}

export interface MenuItem {
  id: string;
  name: string;
  description: string;
  price: number;
  image: string;
  modifiers: Modifier[];
  defaultModifiers: Modifier[];
  reviewsEnabled: boolean;
  averageRating?: number;
  reviewCount?: number;
  showQuantityAvailable: boolean;
  quantityAvailable?: number;
}

export interface Modifier {
  id: string;
  name: string;
  price: number;
}

export interface MenuGroup {
  id: number;
  name: string;
  items: MenuItem[];
}

export interface Menu {
  id: number;
  name: string;
  description?: string;
  groups: MenuGroup[];
}

export interface BrandingProfile {
  id: number;
  clientId: number;
  name: string;
  logoUrl: string;
  primaryColor: string;
  secondaryColor: string;
  fontColor: string;
  secondaryFontColor?: string;
}

export interface BrandingState {
  profiles: BrandingProfile[];
  status: 'idle' | 'loading' | 'failed' | 'succeeded';
  error: string | null;
}

export interface ServiceFee {
  id: number;
  name: string;
  amount: number;
  value: number;
}

export interface Client {
  id: number;
  name: string;
  subdomain: string;
  active: boolean;
}

export interface Order {
  id: string;
  items: CartItem[];
  orderType: OrderType;
  subtotal: number;
  tax: number;
  total: number;
  appliedDiscounts: Reward[];
  kitchenTip?: number;
  driverTip?: number;
}

export interface OrderItem {
  id: string;
  name: string;
  quantity: number;
  modifications?: string[];
}

export interface Role {
  id: number;
  name: string;
  permissions: string[];
}

export interface User {
  id: number;
  name: string;
  email: string;
  role: UserRole;
  firstName?: string;
  lastName?: string;
}

export interface POSProfile {
  id: number;
  name: string;
  provider: string;
}

export interface POSProfileState {
  profiles: POSProfile[];
  status: 'idle' | 'loading' | 'failed' | 'succeeded';
  error: string | null;
}

export interface Discount {
  id: number;
  name: string;
  type: 'percentage' | 'fixed' | 'bogo';
  value: number;
  code?: string;
  startDate: Date;
  endDate: Date;
  isActive: boolean;
  usageLimit?: number;
  usageCount: number;
  minPurchaseAmount?: number;
  maxDiscountAmount?: number;
  applicableItems?: string;
  applicableCategories?: string;
}

export interface LoyaltyConfig {
  tiers: { tierName: string }[];
}

export interface CartItem {
  menuItem: {
    id: string;
    name: string;
    price: number;
  };
  quantity: number;
  selectedModifiers: {
    [key: string]: string | number | boolean;
  };
}

export interface DashboardStat {
  id: number;
  label: string;
  value: number | string;
}

export interface CateringOrder extends Order {
  eventDate: string;
  specialInstructions: string;
}

export interface InventoryItem {
  id: number;
  name: string;
  quantity: number;
  unit: string;
  reorderPoint: number;
}

// Redux Slice State Types
export interface ClientState {
  clients: Client[];
  status: 'idle' | 'loading' | 'failed' | 'succeeded';
  error: string | null;
}

export interface OrderState {
  orders: Order[];
  status: 'idle' | 'loading' | 'failed' | 'succeeded';
  error: string | null;
}

export interface AuthState {
  user: User | null;
  token: string | null;
  isAuthenticated: boolean;
  permissions: string[];
  status: 'idle' | 'loading' | 'failed' | 'succeeded';
  error: string | null;
}

export interface WalletState {
  balance: number;
  rewards: LoyaltyReward[];
  discounts: Discount[];
  status: 'idle' | 'loading' | 'failed' | 'succeeded';
  error: string | null;
}

export interface LocationState {
  locations: Location[];
  selectedLocation: Location | null;
  status: 'idle' | 'loading' | 'failed' | 'succeeded';
  error: string | null;
}

export interface MenuState {
  menus: Menu[];
  status: 'idle' | 'loading' | 'failed' | 'succeeded';
  error: string | null;
}

export interface BrandingState {
  profiles: BrandingProfile[];
  status: 'idle' | 'loading' | 'failed' | 'succeeded';
  error: string | null;
}

export interface LoyaltyState {
  rewards: LoyaltyReward[];
  config: LoyaltyConfig;
  userPoints: number;
  status: 'idle' | 'loading' | 'succeeded' | 'failed';
  error: string | null;
}

export interface RoleState {
  roles: Role[];
  status: 'idle' | 'loading' | 'failed' | 'succeeded';
  error: string | null;
}

export interface DiscountState {
  list: Discount[];
  status: 'idle' | 'loading' | 'succeeded' | 'failed';
  error: string | null;
}

export interface CartState {
  items: CartItem[];
  discount: Discount | null;
}

export interface GuestState {
  profile: unknown;
  status: 'idle' | 'loading' | 'failed' | 'succeeded';
  error: string | null;
}

export interface UserState {
  profile: User | null;
  rewards: unknown[];
  status: 'idle' | 'loading' | 'failed' | 'succeeded';
  error: string | null;
}

export interface ServiceFeeState {
  serviceFees: ServiceFee[];
  status: 'idle' | 'loading' | 'failed' | 'succeeded';
  error: string | null;
}

export interface InventoryState {
  items: InventoryItem[];
  status: 'idle' | 'loading' | 'failed' | 'succeeded';
  error: string | null;
}

export interface GuestProfile {
  id: number;
  firstName: string;
  lastName: string;
  name: string;
  email: string;
  loyaltyPoints: number;
  loyaltyTier: string;
}

export interface DashboardState {
  stats: DashboardStat[];
  status: 'idle' | 'loading' | 'succeeded' | 'failed';
  error: string | null;
}

export interface CateringOrderState {
  orders: CateringOrder[];
  status: 'idle' | 'loading' | 'succeeded' | 'failed';
  error: string | null;
}

// General Utility Types
export interface ApiResponse<T> {
  data: T;
  success: boolean;
  message: string;
}

export interface ClientBranding {
  id: string;
  clientId: string;
  logo: string;
  favicon: string;
  primaryColor: string;
  secondaryColor: string;
  accentColor: string;
  fontFamily: string;
  buttonStyle: 'rounded' | 'square';
  headerStyle: 'centered' | 'left-aligned';
  footerContent: string;
}

// Define the AuthResponse type
export interface AuthResponse {
  user: User;
  token: string;
  permissions?: string[]; // Include permissions if it's part of the response
}

export interface DropOffTime {
  id: number;
  time: string;
}

export interface DropOffLocation {
  id: number;
  name: string;
  address: string;
  city: string;
  state: string;
  zipCode: string;
  parentLocationId: number;
  dropOffTimes: DropOffTime[];
}

export interface LoyaltyChallenge {
  id: number;
  name: string;
  description: string;
  conditions: {
    itemCount: number;
    timeframe: string;
    minSpend: number;
    frequency:
      | 'unlimited'
      | 'once_per_day'
      | 'once_per_week'
      | 'once_per_month';
    restrictedMenuItems?: number[];
    restrictedMenuGroups?: number[];
  };
  rewardConfig: {
    reward: string;
    points: number;
    discount: number;
  };
  challengeType: 'purchase-based' | 'engagement-based';
  startDate: Date;
  endDate: Date;
  status: 'active' | 'inactive' | 'completed' | 'archived';
  participantCount: number;
  locationId: number;
  clientId: number;
}

// Add this to the existing types
export interface LoyaltyChallengeProgress {
  id: number;
  challengeId: number;
  guestId: number;
  progress: {
    itemCount?: number;
    totalSpend?: number;
    // Add other relevant progress fields
  };
  isCompleted: boolean;
  completedAt?: Date;
}

export interface POSAlert {
  id: number;
  posProfileId: number;
  errorCode: string;
  message: string;
  timestamp: Date;
}

export interface RealtimeMetrics {
  todaySales: number;
  todayOrders: number;
  averageOrderValue: number;
  newGuests: number;
  returningGuests: number;
  mostPopularItem: string;
}

export enum PaymentGateway {
  STRIPE = 'stripe',
  PAYPAL = 'paypal',
  FINIX = 'finix',
  AEDYN = 'aedyn',
  WORLDPAY = 'worldpay',
}

export interface ClientSettings {
  companyName: string;
  supportEmail: string;
  twoFactorRequired: boolean;
  defaultPaymentGateways: PaymentGateway[];
}
